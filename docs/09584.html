<html>
<head>
<title>Introducing Responsive React Components 🔥</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引入响应式React组件🔥</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/introducing-responsive-react-components-f6cd14976570?source=collection_archive---------0-----------------------#2018-11-25">https://medium.com/hackernoon/introducing-responsive-react-components-f6cd14976570?source=collection_archive---------0-----------------------#2018-11-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e74d1a88cd376c4199e06e25b46aa9ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XmXA0975oYQNDFwl.png"/></div></div></figure><p id="6329" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">TL；DR </strong> — <em class="ka">你可以在React中用一行程序渲染特定于视口的组件</em></p><p id="9b58" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">React很牛逼，全世界一致同意。当我们把一切都看作组件时，开发会快得多，也容易得多。由于一切都是JavaScript驱动的，<strong class="je hv"> React只根据应用程序的状态</strong>呈现必要的代码。即使你有超过一千个组件和数万行代码也没关系。<strong class="je hv">如果你</strong> <a class="ae kb" href="https://medium.freecodecamp.org/how-to-use-react-lazy-and-suspense-for-components-lazy-loading-8d420ecac58" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">懒加载</strong> </a> <strong class="je hv">你的组件，你只加载用户需要的东西，我认为这是使用React </strong>的最大赢家。</p><p id="ea89" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">也就是说，您有没有想过在React代码库中编写媒体查询时会发生什么？</p><p id="758f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你渲染那些不应该出现在特定视窗中的元素，并使用css隐藏它们。</p><p id="de60" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个例子中</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="271c" class="kl km hu kh b fv kn ko l kp kq">import React from 'react';<br/>import './Example.style.scss';<br/><br/>const Example = () =&gt; {<br/>  return (<br/>    &lt;div className="example"&gt;<br/>      &lt;div className="mobile-only"&gt;I'm a fancy mobile div&lt;/div&gt;<br/>      &lt;div className="desktop-only"&gt;I'm a heavy desktop div&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="d79c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kr ks kt kh b">Example.style.scss</code>文件</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="dd7a" class="kl km hu kh b fv kn ko l kp kq">.example {<br/>  .mobile-only {<br/>    @media (min-width: 768px){<br/>      display: none;<br/>    }<br/>  }<br/>  .desktop-only {<br/>    @media (max-width: 767px){<br/>      display: none;<br/>    }<br/>  }<br/>}</span></pre><p id="b504" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当<code class="eh kr ks kt kh b">Example</code>组件渲染时，<strong class="je hv"/><code class="eh kr ks kt kh b">.mobile-only</code>和<code class="eh kr ks kt kh b">.desktop-only</code>元素<strong class="je hv">都将在DOM中渲染</strong>，而<code class="eh kr ks kt kh b">.mobile-only</code> div将在较大的视口中隐藏，<code class="eh kr ks kt kh b">.desktop-only</code> div将在较小的视口中用css <code class="eh kr ks kt kh b">display: none</code>隐藏。</p><p id="deb7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果这是小的，这是没问题的。但是在我工作的一个项目中，我们有一个沉重的桌面菜单和一个沉重的移动菜单，两者都呈现在所有的视口中。<strong class="je hv">仅仅是</strong> <code class="eh kr ks kt kh b"><strong class="je hv">Menu</strong></code> <strong class="je hv">一个大小就应该在</strong> <code class="eh kr ks kt kh b"><strong class="je hv">20Kb</strong></code> <strong class="je hv">左右，我们很容易为每个用户在浏览器中加载一个不需要的<code class="eh kr ks kt kh b">20Kb</code>。如果您有更多的视口特定元素，这个大小将继续增加。</strong></p><p id="507a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kb" href="https://github.com/flexdinesh/react-socks" rel="noopener ugc nofollow" target="_blank"> React Socks </a>是<strong class="je hv">最小React库</strong>到<strong class="je hv">基于视口</strong>渲染组件。</p><p id="03ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">向媒体提问说再见。下面是你如何用一个超级酷的语法来渲染特定于视口的组件。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="75e6" class="kl km hu kh b fv kn ko l kp kq">const Example = () =&gt; {<br/>  return(<br/>    &lt;Breakpoint small down&gt;<br/>      &lt;MyAwesomeMobileMenu&gt;<br/>        This component will render only in mobile devices<br/>      &lt;/MyAwesomeMobileMenu&gt;<br/>    &lt;/Breakpoint&gt;<br/>  );<br/>};</span><span id="cd6d" class="kl km hu kh b fv ku ko l kp kq">const Example = () =&gt; {<br/>  return(<br/>    &lt;div&gt;<br/>      &lt;Breakpoint small down&gt;<br/>        &lt;div&gt;I will render only in mobile devices&lt;/div&gt;<br/>      &lt;/Breakpoint&gt;<br/><br/>      &lt;Breakpoint medium only&gt;<br/>        &lt;div&gt;I will render only in tablets (iPad, etc...)&lt;/div&gt;<br/>      &lt;/Breakpoint&gt;<br/><br/>      &lt;Breakpoint large up&gt;<br/>        &lt;div&gt;I will render in laptops, desktops and everything bigger&lt;/div&gt;<br/>      &lt;/Breakpoint&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="4ba9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不仅如此。<strong class="je hv">你可以指定自己的断点</strong>(想要多少有多少<strong class="je hv">哇！</strong>)并根据您的项目需求使用它们<strong class="je hv"/>。此外，在你的项目中，你只需要<code class="eh kr ks kt kh b">setDefaultBreakpoints</code>一次😎</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="96ac" class="kl km hu kh b fv kn ko l kp kq">import { setDefaultBreakpoints } from 'react-socks';<br/><br/>setDefaultBreakpoints([<br/>  { xs: 0 },<br/>  { s: 376 },<br/>  { m: 426 },<br/>  { l: 769 },<br/>  { xl: 1025 }<br/>]);</span></pre><p id="3032" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些是我最喜欢的断点</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="e6bc" class="kl km hu kh b fv kn ko l kp kq">setDefaultBreakpoints([<br/>  { cats: 0 },<br/>  { dinosaurs: 900 }<br/>]);<br/><br/>&lt;Breakpoint cats only&gt;<br/>    Only cats can render me 🐈<br/>&lt;/Breakpoint&gt;</span></pre><h2 id="40a6" class="kl km hu bd kv kw kx ky kz la lb lc ld jn le lf lg jr lh li lj jv lk ll lm ln dt translated">你应该使用<a class="ae kb" href="https://github.com/flexdinesh/react-socks" rel="noopener ugc nofollow" target="_blank">反应袜</a>的理由</h2><ul class=""><li id="066c" class="lo lp hu je b jf lq jj lr jn ls jr lt jv lu jz lv lw lx ly dt translated"><strong class="je hv">轻松渲染视口特定的</strong>组件</li><li id="5d5a" class="lo lp hu je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly dt translated">你可以定义你自己的<strong class="je hv">断点</strong>(例如xs，ipad，bigmonitors)并使用它们</li><li id="b74e" class="lo lp hu je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly dt translated">如果您延迟加载视口特定组件，您可以<strong class="je hv">提高您的应用程序性能</strong></li><li id="22b4" class="lo lp hu je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly dt translated">更简单、更甜蜜的<strong class="je hv">语法</strong>便于使用</li></ul><p id="8fd6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该库已经发布到<a class="ae kb" href="https://www.npmjs.com/package/react-socks" rel="noopener ugc nofollow" target="_blank"> npm </a>并且是alpha版本。我很乐意在发布第一个稳定版本之前得到您的反馈并改进它。</p><p id="cd6b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">编辑:首个稳定版本已于2018年12月9日发布，性能提升，支持SSR。</em>🎉</p><p id="1d13" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想知道<strong class="je hv">为什么叫React Socks </strong>🤷‍♂️</p><p id="0462" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kb" href="https://github.com/flexdinesh/react-socks" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> React Socks </strong> </a>舒适地包裹你的组件以防止在各种视口中不必要的渲染，就像你如何用袜子包裹你的脚以防止临阵退缩一样🎉</p><p id="3bc7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们穿上一些花哨的反应袜，把所有的部件包起来🔥</p><p id="3c9b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你太棒了！祝您愉快！⚡️</p></div><div class="ab cl me mf hc mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hn ho hp hq hr"><p id="2167" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">最初发布于</em><a class="ae kb" href="https://dev.to/flexdinesh/introducing-responsive-react-components--1a6a" rel="noopener ugc nofollow" target="_blank"><em class="ka">dev . to</em></a><em class="ka">。</em></p></div></div>    
</body>
</html>