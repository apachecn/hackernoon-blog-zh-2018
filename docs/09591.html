<html>
<head>
<title>Lazy loading (and preloading) components in React 16.6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 16.6中的延迟加载(和预加载)组件</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d?source=collection_archive---------0-----------------------#2018-11-26">https://medium.com/hackernoon/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d?source=collection_archive---------0-----------------------#2018-11-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9117" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">React 16.6增加了一个新特性，让代码拆分变得更加容易:<code class="eh jp jq jr js b">React.lazy()</code>。</p><p id="4457" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们通过一个小演示来看看如何以及为什么使用这个特性。</p><p id="9be8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们有一个显示股票列表的应用程序。当你点击一只股票时，它会显示一个图表:</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff jt"><img src="../Images/12823bb42bd7cb1293ade83880076855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HK_529G8O-O6_6fYEKc9VQ.gif"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek"><a class="ae kj" href="https://react-lazy.netlify.com/" rel="noopener ugc nofollow" target="_blank">Try it</a></figcaption></figure><p id="0f18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是它的全部功能。你可以在<a class="ae kj" href="https://github.com/pomber/react-lazy-preload-demo" rel="noopener ugc nofollow" target="_blank"> github repo </a>中阅读完整代码(也可以查看<a class="ae kj" href="https://github.com/pomber/react-lazy-preload-demo/pulls" rel="noopener ugc nofollow" target="_blank"> pull requests </a>以了解我们将要做的每个更改的差异和应用程序的运行版本)。</p><p id="6745" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于这篇文章，我们只关心<code class="eh jp jq jr js b">App.js</code>文件中的内容:</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="385a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们有一个<code class="eh jp jq jr js b">App</code>组件，它接收股票列表并显示一个<code class="eh jp jq jr js b">&lt;StockTable/&gt;</code>。当从表中选择一只股票时，<code class="eh jp jq jr js b">App</code>组件显示该股票的<code class="eh jp jq jr js b">&lt;StockChart/&gt;</code>。</p><p id="931c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有什么问题？嗯，我们希望我们的应用程序能像<em class="km">一样快</em>，尽可能快地显示<code class="eh jp jq jr js b">&lt;StockTable/&gt;</code>，但是我们让它等到浏览器下载(解压缩、解析、编译和运行)<code class="eh jp jq jr js b">&lt;StockChart/&gt;</code>的代码。</p><p id="f4cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看显示<code class="eh jp jq jr js b">&lt;StockTable/&gt;</code>需要多长时间:</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff kn"><img src="../Images/a0b29708c2792c548b5200cdbaa83e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*amihMyV6mCW5JQogRM6Buw.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Trace without lazy loading</figcaption></figure><p id="b883" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">显示可盘点表需要2470 ms(使用模拟的快速3G网络和4x减速CPU)。</p><p id="31ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们运送到浏览器的那些(压缩的)125KB是什么？</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff ko"><img src="../Images/f41d1b0e86881b609e3680ddfd3c52a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QOEav03nGAll-VT_73eE_A.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Webpack Budle Analyzer <a class="ae kj" href="https://react-lazy.netlify.com/report" rel="noopener ugc nofollow" target="_blank">Report</a></figcaption></figure><p id="6a72" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如所料，我们有react、react-dom和一些react依赖项。但是我们也有moment，lodash和victory，这些我们只在<code class="eh jp jq jr js b">&lt;StockChart/&gt;</code>需要，在<code class="eh jp jq jr js b">&lt;StockTable/&gt;</code>不需要。</p><p id="31ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以做些什么来避免<code class="eh jp jq jr js b">&lt;StockChart/&gt;</code>的依赖性，从而降低<code class="eh jp jq jr js b">&lt;StockTable/&gt;</code>的加载速度？我们延迟加载组件。</p><h2 id="4886" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jc la lb lc jg ld le lf jk lg lh li lj dt translated">延迟加载组件</h2><p id="8252" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">使用<a class="ae kj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports" rel="noopener ugc nofollow" target="_blank">动态导入</a>我们可以将捆绑的javascript分成两部分，一个主文件包含显示<code class="eh jp jq jr js b">&lt;StockTable/&gt;</code>所需的代码，另一个文件包含<code class="eh jp jq jr js b">&lt;StockChart/&gt;</code>所需的代码和依赖项。</p><p id="bcd4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这项技术非常有用，以至于React 16.6增加了一个API，使其更容易与React组件一起使用:<code class="eh jp jq jr js b">React.lazy()</code>。</p><p id="3996" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了在我们的<code class="eh jp jq jr js b">App.js</code>中使用<code class="eh jp jq jr js b">React.lazy()</code>,我们做了两处修改:</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff lp"><img src="../Images/345f3889d88b019cc66642da6dceee70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DH2ChGy7yiqCfho-gGuP-Q.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek"><a class="ae kj" href="https://github.com/pomber/react-lazy-preload-demo/pull/2/files" rel="noopener ugc nofollow" target="_blank">Diff</a></figcaption></figure><p id="7848" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们用一个对<code class="eh jp jq jr js b">React.lazy()</code>的调用替换静态导入，并传递给它一个返回动态导入的函数。现在浏览器不会下载<code class="eh jp jq jr js b">./StockChart.js</code>(及其依赖项)，直到我们第一次渲染它。</p><p id="89b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是当React想要渲染<code class="eh jp jq jr js b">&lt;StockChart/&gt;</code>而它还没有代码的时候会发生什么呢？所以我们才加了<code class="eh jp jq jr js b">&lt;React.Suspense/&gt;</code>。它将呈现<code class="eh jp jq jr js b">fallback</code>道具，而不是它的孩子，直到它的所有孩子的所有代码都被加载。</p><p id="66eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们的应用程序将捆绑在两个文件中:</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff lq"><img src="../Images/9f65ad8d9a576c66adcc9b43829a6aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s_U-JURSswCDhVDPZgxxNQ.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Webpack Budle Analyzer <a class="ae kj" href="https://deploy-preview-2--react-lazy.netlify.com/report.html" rel="noopener ugc nofollow" target="_blank">Report</a></figcaption></figure><p id="20d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">主js文件是36KB。另一个文件89KB，包含来自<code class="eh jp jq jr js b">./StockChart</code>的代码及其所有依赖项。</p><p id="9e66" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们再次看看浏览器显示这些变化的<code class="eh jp jq jr js b">&lt;StockTable/&gt;</code>需要多少时间:</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff lr"><img src="../Images/cbd2ed0e7a89d6d1fad5c7b59bf82528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GkV09FYO5ADOAmw3xvKaYg.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Trace with lazy loading</figcaption></figure><p id="72b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">浏览器下载主js文件需要760毫秒(而不是1250毫秒)，评估脚本需要61毫秒(而不是487毫秒)。<code class="eh jp jq jr js b">&lt;StockTable/&gt;</code>显示为1546毫秒(而不是2470毫秒)。</p><h2 id="65be" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jc la lb lc jg ld le lf jk lg lh li lj dt translated">预加载惰性组件</h2><p id="2855" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">我们加快了应用程序的加载速度。但是现在我们有了另一个问题:</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff ls"><img src="../Images/897844c2e74795946c9a314273ed2368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0Y-FcigqqboxXROFWWFO7A.gif"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Notice the “Loading…” before showing the chart (<a class="ae kj" href="https://deploy-preview-2--react-lazy.netlify.com/" rel="noopener ugc nofollow" target="_blank">try it</a>)</figcaption></figure><p id="734c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用户第一次点击一个项目时，会显示“正在加载…”回退。那是因为我们需要等到浏览器加载了<code class="eh jp jq jr js b">&lt;StockChart/&gt;</code>的代码。</p><p id="8dd9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们想摆脱“加载…”的回退，我们必须在用户点击股票之前加载代码。</p><p id="577d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">预加载代码的一个简单方法是在调用<code class="eh jp jq jr js b">React.lazy()</code>之前启动动态导入:</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="kk kl l"/></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek"><a class="ae kj" href="https://github.com/pomber/react-lazy-preload-demo/pull/8/commits/126c1bf6e2a23b3e3f7eb0ffb1b4db260516643f" rel="noopener ugc nofollow" target="_blank">Diff</a></figcaption></figure><p id="2acc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们调用动态导入时，组件将开始加载，不会阻塞<code class="eh jp jq jr js b">&lt;StockTable/&gt;</code>的渲染。</p><p id="133d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们来看看这个跟踪是如何从最初的急切加载应用程序改变过来的:</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff lt"><img src="../Images/a142ea1f7db5b34b84dc92d4872ac6d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O-tDkDg9bmDsnvX4vzhHkQ.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Eager Loading vs Lazy Loading</figcaption></figure><p id="312c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，如果用户在表格显示后不到1秒钟内点击股票，他们将只能看到“正在加载…”回退。<a class="ae kj" href="https://deploy-preview-8--react-lazy.netlify.com/" rel="noopener ugc nofollow" target="_blank">试试看</a>。</p><blockquote class="lu lv lw"><p id="c30d" class="ir is km it b iu iv iw ix iy iz ja jb lx jd je jf ly jh ji jj lz jl jm jn jo hn dt translated">您还可以增强<code class="eh jp jq jr js b">lazy</code>功能，以便在需要时更容易预加载组件:</p></blockquote><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="kk kl l"/></div></figure><h2 id="2811" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jc la lb lc jg ld le lf jk lg lh li lj dt translated">预渲染组件</h2><p id="f9c8" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">对于我们的小演示应用程序，这就是我们所需要的。对于较大的应用程序，惰性组件在呈现之前可能有其他惰性代码或数据要加载。所以用户仍然需要等待。</p><p id="44eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一种预加载组件的方法是在我们需要它之前实际呈现它。我们想渲染它，但不想显示它，所以我们将其隐藏:</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="kk kl l"/></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek"><a class="ae kj" href="https://github.com/pomber/react-lazy-preload-demo/pull/4/commits/065adf856c334b9e614d6e5d20afbc3042a099a4" rel="noopener ugc nofollow" target="_blank">Diff</a></figcaption></figure><p id="5b40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">React将在第一次呈现应用程序时开始加载<code class="eh jp jq jr js b">&lt;StockChart/&gt;</code>，但这一次它将实际尝试呈现<code class="eh jp jq jr js b">&lt;StockChart/&gt;</code>，因此如果任何其他依赖项(代码或数据)需要加载，它将被加载。</p><p id="a750" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将惰性组件包装在一个<code class="eh jp jq jr js b">hidden</code> <code class="eh jp jq jr js b">div</code>中，这样它在加载后不会显示任何内容。我们用一个<code class="eh jp jq jr js b">null</code>回退将那个<code class="eh jp jq jr js b">div</code>包装在另一个<code class="eh jp jq jr js b">&lt;React.Suspense/&gt;</code>中，这样它在被加载时不会显示任何东西。</p><blockquote class="lu lv lw"><p id="f2c9" class="ir is km it b iu iv iw ix iy iz ja jb lx jd je jf ly jh ji jj lz jl jm jn jo hn dt translated">注意:<code class="eh jp jq jr js b"><em class="hu">hidden</em></code>是<a class="ae kj" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/hidden" rel="noopener ugc nofollow" target="_blank"> HTML属性</a>，用于表示元素还不相关。浏览器不会呈现具有此属性的元素。React对该属性不做任何特殊处理(但在未来的版本中，它可能会降低隐藏元素的优先级)。</p></blockquote><h2 id="9094" class="kp kq hu bd kr ks kt ku kv kw kx ky kz jc la lb lc jg ld le lf jk lg lh li lj dt translated">少了什么？</h2><p id="7983" class="pw-post-body-paragraph ir is hu it b iu lk iw ix iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo hn dt translated">这最后一种方法在许多情况下是有用的，但是它有一些问题。</p><p id="5534" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，用于隐藏渲染惰性组件的<code class="eh jp jq jr js b">hidden</code>属性并不可靠。例如，lazy组件可以使用一个不会被隐藏的<a class="ae kj" href="https://reactjs.org/docs/portals.html" rel="noopener ugc nofollow" target="_blank">门户</a>(有一个不需要额外div的黑客<a class="ae kj" href="https://github.com/pomber/react-lazy-preload-demo/pull/5/commits/dd968db4a2d41b1a607bc4aabfbf6c726ed9a94a" rel="noopener ugc nofollow" target="_blank">也可以使用门户，但是它是一个黑客，它会崩溃)。</a></p><p id="6ea8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二，即使组件是隐藏的，我们仍然向DOM添加未使用的节点，这可能会成为性能问题。</p><p id="f283" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个更好的方法是告诉react呈现惰性组件，但在加载后不将其提交给DOM。但是，据我所知，在React的当前版本中是不可能的。</p><p id="f759" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以做的另一个改进是在预加载图表组件时重用我们正在呈现的元素，这样当我们想要实际显示图表时，React就不需要再次创建它们。如果我们知道用户将点击什么股票，我们甚至可以在用户点击它之前用正确的数据呈现它。</p><p id="38c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">仅此而已。感谢阅读。</p><p id="dd35" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更多类似的东西<strong class="it hv">在twitter上关注</strong><a class="ae kj" href="https://twitter.com/pomber" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">@ pomber</strong></a><strong class="it hv"/>。</p></div></div>    
</body>
</html>