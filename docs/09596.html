<html>
<head>
<title>Big O for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">给初学者的大O</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/big-o-for-beginners-622a64760e2?source=collection_archive---------5-----------------------#2018-11-26">https://medium.com/hackernoon/big-o-for-beginners-622a64760e2?source=collection_archive---------5-----------------------#2018-11-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/27345573db22db7671d4b1e3631602e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZL1S--Ep2FhZAgLS"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/@aprvm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">apoorv mittal</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4f4b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">大O符号允许我们测量代码的时间和空间复杂度。</p><p id="01c1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">想想for循环的例子。你可以在一个包含5个条目的数组上运行它，它会运行得很快，但是如果你在一个包含10，000个条目的数组上运行它，那么执行时间会慢得多。参见示例:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="86ec" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">大O符号允许我们计算出一个算法运行需要多长时间。这让我们了解一段代码将如何伸缩。它衡量算法效率。</p><p id="8927" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> O(1) </strong></p><p id="c8a2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这就是所谓的恒定时间。每次执行的时间是一致的。想象一下，如果你是加油站服务员。给一辆车加满油只需要25秒，然后这个特殊的任务就被认为完成了。不管你那天加满了一辆车还是一百辆车，你都在一个持续的时间内加满了车。</p><p id="7653" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以按照我们上面的例子，我们不关心O(1)，O(2)，等等。我们将其向下舍入到O(1)，也就是说，我们的操作在可伸缩性方面是一条直线。它将花费同样多的时间。这是可预测的，也是非常可扩展的。参见示例:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="3d68" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> O(n) </strong></p><p id="9b3e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们的循环示例是O(n ),因为它为输入中的每个值运行。操作根据输入以线性方式增加。(n)表示输入的数量。该算法在线性时间内运行。</p><p id="0a93" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> O(n ) </strong></p><p id="ad2e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">假设我们想要记录来自一组项目的一系列配对。我们可以这样做:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="1b24" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个好的经验法则是，如果你看到嵌套循环，那么你使用乘法来计算符号。所以在我们上面的例子中，我们做的是O(n *n)变成O(n)(n的平方的O)。这就是所谓的二次时间，也就是说，每当元素数量增加时，我们就以二次方的方式增加运算。</p><p id="6cc9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">实际上，当引入更多元素时，随着运算次数的显著增加，您希望避免运行O(n)的代码。</p><p id="c47d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">算计大O </strong></p><p id="236c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要计算Big O，您可以遍历每一行代码，确定它是O(1)，O(n)等，然后在最后返回您的计算结果。例如，它可以是O(4 + 5n)，其中4表示O(1)的四个实例，5n表示O(n)的五个实例。</p><p id="bf27" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然而，有一种更简单的方法来计算这一点，那就是遵循以下四条规则:</p><ol class=""><li id="53df" class="kl km hu jj b jk jl jo jp js kn jw ko ka kp ke kq kr ks kt dt translated">假设最坏的情况</li><li id="07cb" class="kl km hu jj b jk ku jo kv js kw jw kx ka ky ke kq kr ks kt dt translated">移除常数</li><li id="535b" class="kl km hu jj b jk ku jo kv js kw jw kx ka ky ke kq kr ks kt dt translated">对输入使用不同的术语</li><li id="64be" class="kl km hu jj b jk ku jo kv js kw jw kx ka ky ke kq kr ks kt dt translated">放弃任何非支配者</li></ol><p id="6a6d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">依次分析这些问题:</p><ol class=""><li id="db29" class="kl km hu jj b jk jl jo jp js kn jw ko ka kp ke kq kr ks kt dt translated"><strong class="jj hv">假设最坏的情况</strong></li></ol><p id="206b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在计算大O的时候，你总是想着最坏的情况。例如，如果你要遍历一个数组并寻找一个项，它可能是第一个项，也可能是最后一个项。因为我们不确定，所以在这种情况下我们必须假设O(n)。</p><p id="0c9c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">2.<strong class="jj hv">移除常量</strong></p><p id="c848" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这有点棘手，但请耐心等待。考虑以下代码:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="49c4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们有一个函数可以做几件事。有些是O(1)如第3行，而有些是O(n)如第9行。</p><p id="fbfe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以将大O符号表示为O(1 + n/2 +100 ),但这实在太具体了。我们可以删除O(1)操作，因为根据经验，与O(n)操作相比，它们可能不重要。如果我们在输入数组中提供一百万个条目，那么来自O(1)的额外100个操作不是我们主要关心的。</p><p id="50bb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么我们就有O(n/2)——随着n变得越来越大，除以2会产生递减效应。所以最终这个函数的大O符号变成了O(n)。</p><p id="b786" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">3.<strong class="jj hv">不同的输入术语</strong></p><p id="9e72" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们对同一个数组循环两次，那么我们的大O在技术上是O(2n)，但是让我们去掉常数，这样我们就剩下O(n)了。但是现在我们需要考虑投入的不同术语。那是什么意思？</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="1f34" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们看上面的代码，我们可以看到我们现在有两个输入。一个可能只有一项，另一个可能包含一百万项。所以我们的函数不再是O(n)，而是O(a + b)。我们在符号中使用的<em class="kz"> n </em>是任意的，所以我们需要在符号中反映两个输入。</p><p id="1960" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这种情况下，我们的循环不是嵌套的。如果是，那么我们的代码将是O(n ),这将是重构的潜在目标。通常情况下，如果有嵌套循环，那么你是在乘而不是加变量。</p><p id="7748" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">4.<strong class="jj hv">删除非主导条款</strong></p><p id="3ba0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">看一下这段代码:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="8240" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以我们在顶部有一个O(n)的循环，然后是一个O(n)的嵌套循环。所以我们的总数是O(n + n)。但是正如我们在规则#2中看到的，我们想要删除常量。那么这两个术语哪个对我们更重要呢？</p><p id="f7c4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这种情况下，我们去掉O(n ),保留O(n ),因为这更重要。这是一个占主导地位的术语，因为它对性能的影响要大得多。</p><p id="f98c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">结论</strong></p><p id="ad3c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么这有什么意义呢？</p><p id="ad7c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们知道我们将只处理小的输入，那么大的O真的不太重要。但是当你写代码的时候，你应该考虑它的可伸缩性。</p><p id="4c55" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过关注Big O，你可以看到未来，你更有可能编写出可有效扩展的代码。您可以开始考虑代码的成本，并在如何编写代码方面做出明智的选择。</p><p id="9dc3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">资源</strong></p><p id="ed8f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="http://bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">http://bigocheatsheet.com/</a></p><div class="la lb fm fo lc ld"><a href="https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-o-notation" rel="noopener  ugc nofollow" target="_blank"><div class="le ab ej"><div class="lf ab lg cl cj lh"><h2 class="bd hv fv z el li eo ep lj er et ht dt translated">大O符号</h2><div class="lk l"><h3 class="bd b fv z el li eo ep lj er et ek translated">免费阅读和学习以下文章:Big-O符号</h3></div><div class="ll l"><p class="bd b gc z el li eo ep lj er et ek translated">www.khanacademy.org</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr ja ld"/></div></div></a></div></div></div>    
</body>
</html>