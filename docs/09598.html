<html>
<head>
<title>State management with React Context, TypeScript, and GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React上下文、类型脚本和GraphQL进行状态管理</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/state-management-with-react-context-typescript-and-graphql-fb6264314a15?source=collection_archive---------7-----------------------#2018-11-26">https://medium.com/hackernoon/state-management-with-react-context-typescript-and-graphql-fb6264314a15?source=collection_archive---------7-----------------------#2018-11-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b0c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">厌倦了在你的状态下调试类型错误？想要React应用的最新文档吗？请继续阅读！</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/1e9e5abad91a6a2f6cdd08dc2c228ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NfwIkP-5SfAzIrhfG_hqzg.jpeg"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Side effects of type errors: Lost dev time and increased irritability</figcaption></figure><p id="6b68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我第一次遇到<a class="ae kf" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> TypeScript </strong> </a>的时候，我感到了相当程度的绝望:为什么我不得不写更多的样板代码？当与React一起使用时，为什么我必须确定每个单独的<a class="ae kf" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> React </strong> </a>属性的类型，以及异步调用的请求和响应对象？交集和并集到底是什么类型？</p><p id="3561" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，在花时间使用TypeScript之后，我很快就爱上了它。它使我避免了在愚蠢的类型错误上浪费时间，提供了动态的自我文档，并且使我的同事更容易理解对代码的期望。</p><p id="310e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着我探索React应用程序中不同的状态管理方法，我对TypeScript的兴趣越来越大。我对React的新<a class="ae kf" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Context API </strong> </a>感到特别兴奋，我相信它会非常强大，尤其是在与<a class="ae kf" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> GraphQL </strong> </a>和TypeScript结合使用时。</p><p id="32ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">10月份，我的兴奋之情在波士顿TypeScript meetup(我现在也是该会议的共同组织者)的一次演讲中得到了体现，在那次演讲中，我讲述了我在使用TypeScript的React应用程序中进行状态管理的方法。</p><h1 id="f13c" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">但是Redux呢？</h1><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff le"><img src="../Images/c6f137d3d1e996e50c7d7ad04b2b3929.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*uII4elorSUwsIA5m1j-o2w.png"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek"><a class="ae kf" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank">https://redux.js.org/</a></figcaption></figure><p id="3945" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是在我们进入所有这些之前:我们需要简单地谈论一下<a class="ae kf" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Redux </strong> </a>。它已经得到了很好的确立，可以说是React的默认状态管理模式。那我们为什么不直接用它呢？</p><ul class=""><li id="3f7d" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated">根据应用程序的需求，Redux可能过于复杂/笨拙</li><li id="a50c" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">你可能不想使用<em class="lt">整个</em> Redux生态系统，包括动作创建者、还原者等。</li><li id="1956" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">你最终会得到大量的样板代码</li></ul><h1 id="a55d" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">什么是上下文API，我为什么要关心？</h1><p id="14ee" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">今年，我开始在Redux上的一些应用程序中使用上下文API，我发现它实现起来既优雅又快速。上下文API是“React中旧的上下文概念的升级版本，它允许[s]组件在父子关系之外共享数据”，<a class="ae kf" href="https://hackernoon.com/@rakshitsoral" rel="noopener ugc nofollow" target="_blank"> Rakshit Soral </a>在"<a class="ae kf" href="https://hackernoon.com/everything-you-need-to-know-about-reacts-context-api-e5c8c32ef202" rel="noopener ugc nofollow" target="_blank">中恰当地写下了你需要知道的关于React的上下文API的一切。</a></p><p id="1b11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我自己的短定义？</p><p id="447d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上下文API是一种共享状态和避免正确钻探方法(从React 16.3开始)。归根结底，这是一种在应用程序中共享信息的干净、漂亮的方式，而不用通过不关心它的组件发送信息。</p><p id="0616" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的上下文API图可能过于简化了，尽管你会发现除此之外真的没有什么了。您使用了一个<code class="eh lz ma mb mc b">Provider</code>，它是树中所有组件的根信息源，您还使用了一个<code class="eh lz ma mb mc b">Consumer</code>，它的职责包括从<code class="eh lz ma mb mc b">Provider</code>中获取数据或功能，并将其直接提供给需要该信息的组件。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff md"><img src="../Images/03f6f0c65f7f2bf2498c19739acb251e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/0*7HWKq3CKsQkzimqy"/></div></figure><p id="2058" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，您得到了<code class="eh lz ma mb mc b">React.createContext</code>，它初始化并向上下文传递一个初始值。在这个来自<a class="ae kf" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API文档</a>的例子中，<code class="eh lz ma mb mc b">React.createContext</code>返回一个带有提供者和消费者的对象。</p><p id="4090" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lz ma mb mc b">const {Provider, Consumer} = React.createContext(defaultValue);</code></p><p id="6389" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面代码中的<code class="eh lz ma mb mc b">Provider</code>——也来自<a class="ae kf" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">文档</a>——接受一个表示信息、数据、函数等的值属性。，通过上下文共享。</p><p id="7a6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lz ma mb mc b">&lt;MyContext.Provider value={/* some value */}&gt;</code></p><p id="8d2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下例中的<code class="eh lz ma mb mc b">Consumer</code>——同样来自<a class="ae kf" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">文档</a>——包装了一个函数，该函数从提供者处获取一个值，并以组件的形式返回<code class="eh lz ma mb mc b">JSX</code>，这些组件是<code class="eh lz ma mb mc b">Provider</code>信息的私有部分。</p><pre class="jq jr js jt fq me mc mf mg aw mh dt"><span id="d4d8" class="mi kh hu mc b fv mj mk l ml mm">&lt;MyContext.Consumer&gt;<br/>   {value =&gt; /* render something based on the context value */}<br/>&lt;/MyContext.Consumer&gt;</span></pre><h1 id="0b77" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">GraphQL是什么，我为什么要关心它？</h1><p id="f07d" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">GraphQL和React一样，是由<a class="ae kf" href="https://github.com/facebook/graphql" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">脸书</strong> </a>创造的。与<a class="ae kf" href="https://www.howtographql.com/basics/1-graphql-is-the-better-rest/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> REST </strong> </a>不同，GraphQL仅使用<em class="lt">一个</em>单一端点，允许您一次通过多个查询获取数据。它允许您仅请求您想要的数据，就在您想要的时候。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/fafcc5f6a438e6dd6350538dcc748f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/0*Hs_20s-7qNGxrpSD"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek"><a class="ae kf" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"><strong class="bd mo">https://graphql.org/</strong></a></figcaption></figure><p id="329b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如您在上面看到的，GraphQL还有一个内置的类型系统，随着API的增长和发展，它有助于提供动态的API自文档。更好的是，您可以为您的查询生成静态类型，作为<a class="ae kf" href="https://github.com/apollographql/apollo-tooling" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">Apollo</strong></a><strong class="it hv"/>工具系统的一部分。</p><h1 id="54be" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">向您的应用程序添加GraphQL</h1><p id="de29" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated"><code class="eh lz ma mb mc b">$ npm install --save apollo-boost react-apollo graphql</code></p><p id="b0b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kf" href="https://www.apollographql.com/docs/react/essentials/get-started.html" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">阿波罗助推</strong> </a>给你一堆开箱即用的包。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mp"><img src="../Images/5a613a6660eb215b520684c707f894d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4gmcD5X767mR7IzfRqLxtA.jpeg"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Getting a boost with Apollo</figcaption></figure><ul class=""><li id="563d" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated"><a class="ae kf" href="https://www.apollographql.com/docs/react/essentials/get-started.html#packages" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">Apollo-client</strong></a>是一个缓存的GraphQL客户端，可以和React(以及Angular和其他框架)一起使用</li><li id="32d3" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><a class="ae kf" href="https://www.apollographql.com/docs/react/essentials/get-started.html#packages" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">Apollo-cache-in memory</strong></a>是一款标准的内存缓存，建议与<strong class="it hv"> apollo-client </strong>配合使用</li><li id="077b" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><a class="ae kf" href="https://www.apollographql.com/docs/react/essentials/get-started.html#packages" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">Apollo-link-http</strong></a>只是通过HTTP连接从GraphQL端点获取GraphQL结果</li><li id="d8c3" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><a class="ae kf" href="https://github.com/apollographql/graphql-tag" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> graphql-tag </strong> </a>导出了<code class="eh lz ma mb mc b">gql </code>函数，它允许你为我们的查询和变异编写容易解析的字符串</li></ul><p id="ce31" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lz ma mb mc b">react-apollo</code>包含将<code class="eh lz ma mb mc b">apollo-client</code>与React一起使用的绑定，<code class="eh lz ma mb mc b">graphql</code>只是脸书对GraphQL的参考实现。</p><h1 id="e48d" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">配置阿波罗客户端</h1><p id="fb50" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated">这里有一个来自<a class="ae kf" href="https://www.apollographql.com/docs/react/api/react-apollo.html" rel="noopener ugc nofollow" target="_blank"> React Apollo docs </a>的例子:</p><pre class="jq jr js jt fq me mc mf mg aw mh dt"><span id="8b5a" class="mi kh hu mc b fv mj mk l ml mm">import<!-- --> <!-- -->{ ApolloClient } from 'apollo-client';<br/>import<!-- --> <!-- -->{ HttpLink } from 'apollo-link-http';<br/>import<!-- --> <!-- -->{ InMemoryCache } from 'apollo-cache-inmemory';</span><span id="43d5" class="mi kh hu mc b fv mq mk l ml mm">const client = new<!-- --> <!-- -->ApolloClient({<br/>   // By default, this client will send queries to the `/graphql` endpoint on the same host<br/>   // Pass the configuration option { uri: YOUR_GRAPHQL_API_URL } to the `HttpLink` to connect to a different host<br/>   link: new<!-- --> <!-- -->HttpLink(),<br/>   cache: new<!-- --> <!-- -->InMemoryCache(),<br/>});</span></pre><p id="f799" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，您导入了<code class="eh lz ma mb mc b">ApolloClient</code>、<code class="eh lz ma mb mc b">HttpLink</code>和<code class="eh lz ma mb mc b">InMemoryCache</code>。如果您更喜欢使用GraphQL端点而不是默认端点，默认端点与客户机驻留在同一个主机上，<code class="eh lz ma mb mc b">HttpLink</code>接受一个配置对象。</p><p id="180d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着，例如，如果您正在使用一个驻留在不同主机上的微服务，您将为您的GraphQL端点传入一个自定义配置对象。</p><p id="b13e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，您将根组件包装在从<code class="eh lz ma mb mc b">react-apollo</code>导入的<code class="eh lz ma mb mc b">ApolloProvider</code>中。这使得应用程序中的每个组件都可以通过Apollo访问GraphQL。下面的例子也来自<a class="ae kf" href="https://www.apollographql.com/docs/react/api/react-apollo.html" rel="noopener ugc nofollow" target="_blank"> React Apollo文档</a>:</p><pre class="jq jr js jt fq me mc mf mg aw mh dt"><span id="f613" class="mi kh hu mc b fv mj mk l ml mm">import<!-- --> <!-- -->{ ApolloProvider } from 'react-apollo';</span><span id="4081" class="mi kh hu mc b fv mq mk l ml mm">ReactDOM.render(<br/>   &lt;ApolloProvider client={client}&gt;<br/>      &lt;MyRootComponent /&gt;<br/>   &lt;/ApolloProvider&gt;,<br/>   document.getElementById('root'),<br/>);</span></pre><h1 id="6dd1" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">用Apollo生成类型</h1><p id="6a94" class="pw-post-body-paragraph ir is hu it b iu lu iw ix iy lv ja jb jc lw je jf jg lx ji jj jk ly jm jn jo hn dt translated"><code class="eh lz ma mb mc b">$ npm i --save apollo-codegen</code></p><p id="a3b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我更喜欢使用的<code class="eh lz ma mb mc b">package.json</code>脚本如下:</p><pre class="jq jr js jt fq me mc mf mg aw mh dt"><span id="59b2" class="mi kh hu mc b fv mj mk l ml mm">"introspect": "apollo-codegen introspect-schema GRAPHQL_ENDPOINT --output PATH_TO_SCHEMA_FILE",<br/>// this fetches the schema and saves it in our project<br/>"generate": "apollo-codegen generate GLOB_PATH_TO_QUERY_FILES --schema PATH_TO_SCHEMA_FILE --target typescript --output PATH_TO_GENERATED_TYPES_FILE --add-typename --tag-name gql",<br/>// this generates type interfaces from our schema<br/>"typegen": "npm run introspect &amp;&amp; npm run generate"</span></pre><p id="dba4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我的<code class="eh lz ma mb mc b">introspect</code>脚本中，我用我的端点调用<code class="eh lz ma mb mc b">apollo codegen introspect-schema</code>，并请求GraphQL将我的模式文件输出到一个指定的文件。</p><p id="92e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的<code class="eh lz ma mb mc b">generate</code>脚本查看我自动生成的模式文件和我的查询和变异，并为我的查询和变异生成类型。</p><p id="1aaa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我的<code class="eh lz ma mb mc b">typegen</code>脚本结合了前面提到的两个脚本。</p><p id="8776" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我运行<code class="eh lz ma mb mc b">npm run typegen,</code>并且我很适合我的GraphQL类型！</p><p id="3d02" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请再次注意:这是我的首选方法。当然，每个人都应该自由地配置他们的<code class="eh lz ma mb mc b">package.json</code>脚本，只要他们觉得是最好的！</p><h1 id="0931" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">演示时间</h1><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mr"><img src="../Images/503bb0bba41223b4a942f9872a1eb277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8jux3x0cviLDLvItuyLMaA.jpeg"/></div></div></figure><p id="f0f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">前几天我喝了太多咖啡，决定重建和重塑亚马逊。</p><p id="8f19" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">谢天谢地，我决定从小处着手。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/3d9a7bbe149f547747fb1ac114a32168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/0*ZLYVi3HgW-wxEb15"/></div></figure><p id="991e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的搭档刚搬到费城，那里的人们对各种事情都有自己的行话。比如这个:</p><pre class="jq jr js jt fq me mc mf mg aw mh dt"><span id="c30e" class="mi kh hu mc b fv mj mk l ml mm">Jawn: noun, chiefly in eastern Pennsylvania, used to refer to a thing, place, person, or event that one need not or cannot give a specific name to.</span></pre><p id="3c43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的Jawn Store MVP应该最终显示一个产品列表及其价格，并让我能够将东西添加到我的购物车中。我也应该能够从我的购物车中删除项目，并立即看到更新的总数。</p><p id="1236" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我在本文的剩余部分解释如何用GraphQL和TypeScript设置React上下文时，您也可以在这里找到完整的源代码<a class="ae kf" href="https://github.com/lilybarrett/jawn-with-graphql-and-react-context" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="bbaa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于我的原型，我使用的是<a class="ae kf" href="https://github.com/marak/Faker.js/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Faker.js </strong> </a>，这是一个生成假数据的极好的库。Faker.js托管了一个<a class="ae kf" rel="noopener" href="/@notrab/fakerql-is-ultimate-graphql-endpoint-for-fake-data-bd83f4cd6ad1"> <strong class="it hv"> FakerQL </strong> </a>端点，允许我从一个GraphQL端点获取我的假数据。它为我提供了以下类型的查询:</p><ul class=""><li id="2e79" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated">邮政</li><li id="be85" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">产品</li><li id="2a85" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">用户</li><li id="ec8e" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">待办事项</li></ul><p id="64e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">出于我的目的，因为我在经营一家商店，所以我将通过FakerQL为要销售的产品获取数据。</p><p id="b289" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的应用还使用了以下技术:</p><ul class=""><li id="bf6c" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated">使用<a class="ae kf" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Parcel.js </strong> </a>键入脚本，这是一个开箱即用的支持ts的捆绑器</li><li id="edb9" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">React的上下文API</li></ul><h1 id="0501" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">设置我的GraphQL客户端</h1><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff ms"><img src="../Images/2333ffe11c4a788810e5bb58ca9e9297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GrJrrpBu5HBSsAjEKUZ7ZQ.jpeg"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Getting my store ready for the grand opening!</figcaption></figure><p id="eba1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的应用程序已经安装了所有必要的Apollo依赖项，这些脚本包含在我的<code class="eh lz ma mb mc b">package.json</code>中:</p><pre class="jq jr js jt fq me mc mf mg aw mh dt"><span id="1b9d" class="mi kh hu mc b fv mj mk l ml mm">"scripts": {<br/>   "test": "npm run test",<br/>   "dev": "parcel ./index.html",<br/>   "introspect": "apollo-codegen introspect-schema <a class="ae kf" href="https://fakerql.com/graphql" rel="noopener ugc nofollow" target="_blank">https://fakerql.com/graphql</a> --output ./data/models/index.json",<br/>   "generate": "apollo-codegen generate ./data/**/*.ts --schema ./data/models/index.json --target typescript --output ./data/models/index.ts --add-typename --tag-name gql",<br/>   "typegen": "npm run introspect &amp;&amp; npm run generate",<br/>   "build": "tsc"<br/>}</span></pre><p id="0739" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您会注意到使用了FakerQL端点和一个到<code class="eh lz ma mb mc b">data</code>文件夹的路径，我在这里自动生成模式模型并设置我的查询类型。</p><p id="9a96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里是我的<code class="eh lz ma mb mc b">data</code>文件夹的实际结构:</p><pre class="jq jr js jt fq me mc mf mg aw mh dt"><span id="2066" class="mi kh hu mc b fv mj mk l ml mm">- data<br/>   - formatters<br/>   - models<br/>   - queries</span></pre><p id="7125" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的<code class="eh lz ma mb mc b">formatters</code>是计算不同国家价格的函数(已经实现)。当我运行我的<code class="eh lz ma mb mc b">introspect</code>脚本时，Apollo会将模式输出到我的<code class="eh lz ma mb mc b">models</code>文件夹中的<code class="eh lz ma mb mc b">index.json</code>文件中。文件夹<code class="eh lz ma mb mc b">models</code>中的所有文件都将自动生成。</p><p id="f9b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我运行我的<code class="eh lz ma mb mc b">generate</code>脚本时，Apollo将结合端点模式查看我的查询，并将类型输出到我的<code class="eh lz ma mb mc b">models</code>文件夹中的<code class="eh lz ma mb mc b">index.ts</code>文件中。</p><p id="c722" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我需要创建一个<code class="eh lz ma mb mc b">ApolloClient</code>的实例，这样我就可以使用它的功能。</p><pre class="jq jr js jt fq me mc mf mg aw mh dt"><span id="9de9" class="mi kh hu mc b fv mj mk l ml mm">// ./index.tsx<br/>import<!-- --> <!-- -->React from "react";<br/>import<!-- --> <!-- -->{ ApolloProvider } from "react-apollo";<br/>import<!-- --> <!-- -->{ ApolloClient } from "apollo-client";<br/>import<!-- --> <!-- -->{ HttpLink } from "apollo-link-http";<br/>import<!-- --> <!-- -->{ InMemoryCache } from "apollo-cache-inmemory";</span><span id="cdb6" class="mi kh hu mc b fv mq mk l ml mm">const client = new<!-- --> <!-- -->ApolloClient({<br/>   link: new<!-- --> <!-- -->HttpLink({<br/>      uri: "<a class="ae kf" href="https://fakerql.com/graphql" rel="noopener ugc nofollow" target="_blank">https://fakerql.com/graphql</a>",<br/>      // Remember, we only need ONE endpoint!<br/>   }),<br/>   cache: new<!-- --> <!-- -->InMemoryCache(),<br/>});</span><span id="3166" class="mi kh hu mc b fv mq mk l ml mm">class<!-- --> <!-- -->App extends<!-- --> <!-- -->React.Component {<br/>   public render () {<br/>      // App contents<br/>   }<br/>}</span></pre><p id="104c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就像我们之前看到的例子一样，我们使用了<code class="eh lz ma mb mc b">ApolloClient</code>、<code class="eh lz ma mb mc b">HttpLink</code>和<code class="eh lz ma mb mc b">InMemoryCache</code>。我将传入一个带有FakerQL端点的URI配置对象。</p><p id="a302" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还确保根组件被包装在<code class="eh lz ma mb mc b">ApolloProvider</code>中，因此树中的所有组件都可以利用GraphQL。</p><p id="1ae4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们进入正题:我需要一个查询来通过FakerQL获取所有产品。我更喜欢在我的数据文件夹中为每个查询准备一个文件。</p><pre class="jq jr js jt fq me mc mf mg aw mh dt"><span id="f229" class="mi kh hu mc b fv mj mk l ml mm">// data/queries/JAWN_QUERY.ts</span><span id="8efc" class="mi kh hu mc b fv mq mk l ml mm">import<!-- --> <!-- -->gql from "graphql-tag";</span><span id="8be5" class="mi kh hu mc b fv mq mk l ml mm">export<!-- --> <!-- -->default<!-- --> <!-- -->gql`<br/>   query FindJawnProducts {<br/>   // The FakerQL docs tell me I can query "allProducts" and get a  <br/>   list of products back<br/>   // I'm also specifying the fields I want returned for each<br/>   Product: id, name, price<br/>      allProducts {<br/>         id<br/>         name<br/>         price<br/>      }<br/>   }<br/>`;</span></pre><p id="9d48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里，我使用<code class="eh lz ma mb mc b">gql</code>将我的查询放到一个易读的字符串中。当我查看FakerQL文档时，他们告诉我可以查询<code class="eh lz ma mb mc b">allProducts</code>,并指定以上字段——以及其他字段——为每个产品返回。</p><p id="e823" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我运行<code class="eh lz ma mb mc b">npm run typegen</code>时，下面是生成的类型:</p><pre class="jq jr js jt fq me mc mf mg aw mh dt"><span id="97a1" class="mi kh hu mc b fv mj mk l ml mm">export<!-- --> <!-- -->interface<!-- --> <!-- -->FindJawnProducts_allProducts {<br/>   __typename: "Product";<br/>   id: string;<br/>   name: string;<br/>   price: string;<br/>}</span><span id="5293" class="mi kh hu mc b fv mq mk l ml mm">export<!-- --> <!-- -->interface<!-- --> <!-- -->FindJawnProducts {<br/>   allProducts: (FindJawnProducts_allProducts | null)[] | null;<br/>}</span></pre><p id="4f39" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lz ma mb mc b">FindJawnProducts_allProducts</code>代表单个项目或商品的类型，<code class="eh lz ma mb mc b">FindJawnProducts</code>是我们商店中产品阵列或列表的类型。这些类型对于设置我们的上下文和输入利用这些数据的组件非常有用。</p><p id="624b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我使用来自GraphQL的数据得到我们的组件之前，我停下来问自己:除了从FakerQL获取的产品细节之外，我还想要什么信息？</p><p id="3ef9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实证明，我想支持两个不同的市场:美国和英国</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mt"><img src="../Images/2e04ca33f576d32e08b647ff1a787484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*de7OAeyyZbHAB7MxeFRQxg.jpeg"/></div></div></figure><p id="ab0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了提供产品价格的正确计算，我需要我的组件了解我的市场。在这种情况下，我将把市场作为一个道具传递到根组件中。</p><pre class="jq jr js jt fq me mc mf mg aw mh dt"><span id="24a4" class="mi kh hu mc b fv mj mk l ml mm">class<!-- --> <!-- -->App extends<!-- --> <!-- -->React.Component {<br/>   public render () {<br/>      const { market } = this.props;<br/>      return<!-- --> <!-- -->(<br/>         &lt;ApolloProvider client={client}&gt;<br/>            &lt;Container fluid&gt;<br/>               &lt;Row&gt;<br/>                  &lt;Col xs={12} sm={6}&gt;<br/>                     &lt;JawnList market={market}/&gt;<br/>                  &lt;/Col&gt;<br/>                  &lt;Col xs={12} sm={6}&gt;<br/>                     &lt;Cart market={market}/&gt;<br/>                  &lt;/Col&gt;<br/>               &lt;/Row&gt;<br/>            &lt;/Container&gt;<br/>         &lt;/ApolloProvider&gt;<br/>      );<br/>   }<br/>}</span><span id="e48c" class="mi kh hu mc b fv mq mk l ml mm">const HotApp = hot(module)(App);<br/>render(&lt;HotApp market="US"<!-- --> <!-- -->/&gt;, document.getElementById("root"));</span></pre><p id="443c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是我不想仅仅为了提供关于我的市场的认知而从根组件向下钻取道具。</p><p id="a784" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还有两个组件——<code class="eh lz ma mb mc b">JawnList</code>和<code class="eh lz ma mb mc b">Cart</code>——它们可能需要知道我从API中获取的产品，但是我也不想把这些数据作为道具传递下去。</p><p id="6b84" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的理由？随着应用程序规模的增加，适当的钻探会变得非常混乱。我的MVP可以成长为一个更大的应用程序，我不想最终通过不关心它们的组件传递细节。</p><h1 id="90d8" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">进入上下文API！</h1><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mu"><img src="../Images/678c5dacd636e5b42c3f3acb054a7a0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pZvrDwABa9PD-u3MxcU36w.jpeg"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Context API magic!</figcaption></figure><p id="be42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我创建了一个名为<code class="eh lz ma mb mc b">JawnContext.tsx</code>的文件，在这里我为应用程序定义并创建了我的上下文:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/5114f6d7f6d3b5d9b1eae1eabc0f9562.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/0*zgXONdAHNjxEqxVG"/></div></figure><p id="d509" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是阿波罗生成的类型开始派上用场的地方。<code class="eh lz ma mb mc b">Cart</code>将是一系列FakerQL产品。<code class="eh lz ma mb mc b">addToCart</code>将接受一个FakerQL产品作为参数，并将其添加到<code class="eh lz ma mb mc b">Cart</code>。<code class="eh lz ma mb mc b">removeFromCart</code>会做听起来完全一样的事情。最后，<code class="eh lz ma mb mc b">market</code>可以被类型化为<code class="eh lz ma mb mc b">"US"</code>或<code class="eh lz ma mb mc b">"UK"</code>。</p><p id="4705" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，<code class="eh lz ma mb mc b">React.createContext</code>发挥它的魔力！(<code class="eh lz ma mb mc b">null</code>，顺便说一下，是我对上下文的默认值)。</p><p id="e650" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，让我们将我的上下文连接到我的根组件。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mw"><img src="../Images/a617481d7364e9f93b362881f6d2f05d.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/0*zv_cMSHT6pY4kbCL"/></div></figure><p id="41e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您会注意到<code class="eh lz ma mb mc b">App</code>被类型化为<code class="eh lz ma mb mc b">JawnState</code>——上下文类型——因为组件的道具之一是<code class="eh lz ma mb mc b">market</code>，我现在想从上下文中派生出来。</p><p id="e9cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还会注意到我用<code class="eh lz ma mb mc b">JawnContext.Provider</code>和它的值对象包装了组件，它包含了每个上下文属性的值——<code class="eh lz ma mb mc b">addToCart</code>和<code class="eh lz ma mb mc b">removeFromCart</code>的实现，传递到根的<code class="eh lz ma mb mc b">market</code>,以及购物车的当前状态。</p><p id="1145" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">转到消费者:这是个人偏好——有些人喜欢创建新的函数来包装每个消费组件——但是我想在这里建立一个可重用的<code class="eh lz ma mb mc b">WithJawnContext</code>提供者，这样我就可以在需要的时候用GraphQL提供者和消费组件轻松地组合它。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mn"><img src="../Images/09579a2f712a2e192901a8d937abb716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/0*CwnJdwcQBR0IfxBL"/></div></div></figure><p id="2046" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里，我的<code class="eh lz ma mb mc b">Props</code>扩展了<code class="eh lz ma mb mc b">JawnState</code>，这是上下文的类型，并且该函数接受一个React组件作为子组件。然后它返回一个孩子，由<code class="eh lz ma mb mc b">JawnContext.Consumer</code>包装，在其中传播给定的属性和上下文状态。</p><p id="5fc4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了让<code class="eh lz ma mb mc b">JawnList</code>能够以一种类型安全的方式成功地使用我的上下文，我需要将<code class="eh lz ma mb mc b">JawnListType</code>定义为一个子元素，它结合了来自<code class="eh lz ma mb mc b">JawnState</code>上下文和GraphQL自动生成的数据类型<code class="eh lz ma mb mc b">FindJawnProducts</code>的属性。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/9a52702af3dd6d16af48c5558d2df186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/0*sG-ij1egKnrQOqfF"/></div></figure><p id="bda1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这使我能够访问来自GraphQL端点的数据，以及来自我的上下文的<code class="eh lz ma mb mc b">market</code>和<code class="eh lz ma mb mc b">addToCart</code>。</p><p id="82a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面代码的底部，您会看到我已经创建了一个函数来对产品数据进行必要的GraphQL查询。我正在用<code class="eh lz ma mb mc b">withJawnContext</code>提供者和我的组件进行组合。React Apollo给了我<code class="eh lz ma mb mc b">ChildDataProps</code>，由<code class="eh lz ma mb mc b">ApolloProvider</code>包装的组件的通用类型。</p><p id="5a2d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类似地，我需要允许Cart使用上下文。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff my"><img src="../Images/8c0ab5210c0b3ad693878b258fe013a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/0*-ElveYKOPafJslP4"/></div></figure><p id="d638" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，我用<code class="eh lz ma mb mc b">Cart</code>——类型化为<code class="eh lz ma mb mc b">JawnState</code>——组成了<code class="eh lz ma mb mc b">withJawnContext</code>提供者，这使我可以从上下文中访问<code class="eh lz ma mb mc b">market</code>、<code class="eh lz ma mb mc b">cart</code>和<code class="eh lz ma mb mc b">removeFromCart</code>。</p><p id="d310" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也就这样了！我的应用程序允许用户从购物车中添加和删除商品，并查看更新的总价，我可以避免在应用程序中钻取道具。我赢了！</p><h1 id="1841" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">外卖食品</h1><ul class=""><li id="0eb7" class="lf lg hu it b iu lu iy lv jc mz jg na jk nb jo lk ll lm ln dt translated">Apollo帮助我们查询单个端点，并为我们的模式、查询和变异生成GraphQL类型</li><li id="a2d5" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">上下文API与TypeScript一起工作，提供了一种类型安全的、轻量级的方式来共享状态和数据，而无需深入研究属性</li></ul><p id="7fd0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇文章的一个版本最初发表于<a class="ae kf" href="https://lilydbarrett.com/" rel="noopener ugc nofollow" target="_blank">lilydbarrett.com</a>。你可以在这里找到Jawn商店<a class="ae kf" href="https://github.com/lilybarrett/jawn-with-graphql-and-react-context" rel="noopener ugc nofollow" target="_blank">的完整源代码。</a></p><p id="0df4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">其他有用资源:</strong></p><ul class=""><li id="1625" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated"><a class="ae kf" href="https://graphql.org/learn/" rel="noopener ugc nofollow" target="_blank">graph QL简介</a></li><li id="b907" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><a class="ae kf" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank">阿波罗客户端文档</a></li><li id="081c" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><a class="ae kf" href="https://hackernoon.com/everything-you-need-to-know-about-reacts-context-api-e5c8c32ef202" rel="noopener ugc nofollow" target="_blank">“关于React的上下文API你需要知道的一切”</a> ( <a class="ae kf" href="https://hackernoon.com/@rakshitsoral" rel="noopener ugc nofollow" target="_blank"> Rakshit Soral </a>)</li><li id="5665" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><a class="ae kf" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">反应上下文文档</a></li><li id="d475" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><a class="ae kf" href="https://www.typescriptlang.org/docs/home.html" rel="noopener ugc nofollow" target="_blank">打字稿文件</a></li></ul></div></div>    
</body>
</html>