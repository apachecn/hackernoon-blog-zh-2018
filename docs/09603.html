<html>
<head>
<title>My way of working with internal nuget packages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我使用内部nuget包的方式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/my-way-of-working-with-internal-nuget-packages-a30d3f71d47d?source=collection_archive---------12-----------------------#2018-11-26">https://medium.com/hackernoon/my-way-of-working-with-internal-nuget-packages-a30d3f71d47d?source=collection_archive---------12-----------------------#2018-11-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/180fd3be6996b18b665d001b9070f96d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A4sh2W_Gt5OWFg3HHzwXPw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Picture borrowed from <a class="ae jg" href="https://cdn.pixabay.com/photo/2013/07/13/10/22/box-157074_1280.png" rel="noopener ugc nofollow" target="_blank">https://cdn.pixabay.com/photo/2013/07/13/10/22/box-157074_1280.png</a></figcaption></figure><p id="4ede" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我工作的公司足够大，可以跨越多个开发团队。为了能够共享一种共同的工作方式，并防止轮子被反复发明，我们依赖于共享的<a class="ae jg" href="https://docs.microsoft.com/en-us/nuget/what-is-nuget" rel="noopener ugc nofollow" target="_blank"> nuget </a>包。</p><p id="d846" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我是许多软件包的作者，也是这些软件包的主要贡献者，这需要我花一些时间来维护它们。为了能够做到这一点，我需要一种能让我高效完成这项工作的方法。</p><p id="6e6d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这篇文章中，我将一步一步地分享我的方法。</p><h2 id="a5ee" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">版本控制</h2><p id="e400" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">为了对包进行版本控制，使用了<a class="ae jg" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> git </a>。Git是一个<em class="lf">事实上的标准</em>，不需要进一步描述:)</p><h2 id="12b3" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">命名</h2><p id="9149" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">决定一个适合你的好的命名约定。我们使用公司前缀，用点分隔，范围缩小。比如:CompanyA。AspNetCore.Mvc将是我们自己的包，为ASP.NET核心Mvc定制类。</p><h2 id="2485" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">项目结构</h2><p id="3938" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">为了保持一致，应该使用项目结构。我的观点是基于大卫·福勒的这个要点。它并没有被严格遵循，而是受到了启发。例如，测试项目没有被分离到它自己的测试文件夹中，而是包含在src文件夹中。这个设置只做一次，当我引入额外的包时，我只是从另一个项目中复制结构。这个结构可以很容易地提取到一个<a class="ae jg" href="https://docs.microsoft.com/en-us/dotnet/core/tools/custom-templates" rel="noopener ugc nofollow" target="_blank">点网模板</a>中。</p><p id="c439" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> Nuspec文件</strong></p><p id="5fe4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过添加您的nuspec文件，遵循<a class="ae jg" href="https://docs.microsoft.com/en-us/nuget/reference/nuspec" rel="noopener ugc nofollow" target="_blank">这个</a>引用。</p><p id="8481" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">测试</strong></p><p id="d42b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">确保用单元测试覆盖您的包。这将给你信心，使你的代码像你期望的那样工作，也将帮助其他贡献者。我正在使用<a class="ae jg" href="https://xunit.github.io/" rel="noopener ugc nofollow" target="_blank"> xUnit </a>和一些项目中的<a class="ae jg" href="https://github.com/AutoFixture/AutoFixture" rel="noopener ugc nofollow" target="_blank"> AutoFixture </a>来最大化可维护性和减少安排阶段的代码。</p><p id="66d3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">文献</strong></p><p id="216a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">向项目中添加一个README.md，解释如何使用该包。更多关于README.md下面关于<em class="lf">制作包</em>的部分。我正在考虑调查<a class="ae jg" href="https://readthedocs.org/" rel="noopener ugc nofollow" target="_blank">阅读文档</a>作为补充。</p><h2 id="41b7" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">如何引入变化？</h2><p id="f5b0" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">使用的工作流是<a class="ae jg" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank"> Git Flow </a>，这意味着我们不直接将变更推送到主分支，而是推送到我们针对开发分支集成的特性分支。我不打算在这里详细介绍Git流。</p><p id="70ed" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当一个特性完成时，一个拉取请求被打开，利益相关者被邀请。希望这个特性能被合并回去开发，并为下一个即将到来的版本做好准备。git标签应该反映将要发布的版本。我在<em class="lf">制作软件包一节中解释了我这样做的过程。</em></p><p id="08ed" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">突破性变化还是没有？</strong></p><p id="8a29" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么，什么是突破性的改变呢？</p><blockquote class="lg lh li"><p id="fdba" class="jh ji lf jj b jk jl jm jn jo jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd ke hn dt translated">一个<a class="ae jg" href="https://en.wiktionary.org/wiki/software" rel="noopener ugc nofollow" target="_blank">软件</a>系统的一个部分的变化可能导致其他组件<a class="ae jg" href="https://en.wiktionary.org/wiki/fail" rel="noopener ugc nofollow" target="_blank">失效</a>；最常出现在多个应用程序使用的共享代码库中— <a class="ae jg" href="https://en.wiktionary.org/wiki/breaking_change" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="1508" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果更改向使用者公开的现有方法的定义，或者从对象中移除属性，这是一个重大更改。请确保您有一个针对您的包的消费测试客户端，以便您可以验证您所做的更改是否正确。</p><p id="fa41" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当需要更新一个已经存在的包时，你需要考虑你的消费者。你需要问问自己，你引入的是否是一个突破性的改变。如果不是，那也没关系。该更改应该只改变次要版本和/或补丁版本。</p><p id="dd66" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你要引入一个突破性的改变，在删除它之前，你需要保持对不推荐的特性的支持至少一个版本。我倾向于这样做</p><ol class=""><li id="7c13" class="lm ln hu jj b jk jl jo jp js lo jw lp ka lq ke lr ls lt lu dt translated">添加新功能</li><li id="9693" class="lm ln hu jj b jk lv jo lw js lx jw ly ka lz ke lr ls lt lu dt translated">通过添加一个<a class="ae jg" href="https://docs.microsoft.com/en-us/dotnet/api/system.obsoleteattribute.message?view=netcore-2.1" rel="noopener ugc nofollow" target="_blank"> ObsoleteAttribute </a>弃用旧特性，并描述消费者应该如何迁移</li><li id="910b" class="lm ln hu jj b jk lv jo lw js lx jw ly ka lz ke lr ls lt lu dt translated">删除次要版本并发布新版本</li></ol><p id="a9fe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在下一个主要版本中，删除过时的功能。通过这种方式，给消费者一些时间来迁移他们的现有代码以使用新版本。</p><h2 id="b105" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">制作包装</h2><p id="8bf0" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">在发布新的包之前，我要确保</p><ol class=""><li id="3663" class="lm ln hu jj b jk jl jo jp js lo jw lp ka lq ke lr ls lt lu dt translated">nuspec文件中的依赖项已经更新，并且支持的目标框架已经就位</li><li id="a03d" class="lm ln hu jj b jk lv jo lw js lx jw ly ka lz ke lr ls lt lu dt translated">README.md更新了新的功能和示例</li><li id="cd71" class="lm ln hu jj b jk lv jo lw js lx jw ly ka lz ke lr ls lt lu dt translated">版本控制正确</li></ol><p id="356a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">nu spec中的依赖关系</strong></p><p id="38ce" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">nuspec文件清单中有一个部分可以让您指定包所拥有的<a class="ae jg" href="https://docs.microsoft.com/en-us/nuget/reference/nuspec#dependencies" rel="noopener ugc nofollow" target="_blank">依赖项</a>。即使包只支持一个目标框架，它们也包含在一个<a class="ae jg" href="https://docs.microsoft.com/en-us/nuget/reference/nuspec#dependency-groups" rel="noopener ugc nofollow" target="_blank">依赖组</a>中。这使得将来添加额外的目标框架变得容易。</p><p id="9563" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">更新README.md </strong></p><p id="92d3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了确保我更新了README.md以便于理解，我在编辑时使用了<a class="ae jg" href="https://markdownlivepreview.com/" rel="noopener ugc nofollow" target="_blank"> Markdown Live Preview </a>。这给了我一个可视化的编辑器来显示文件。然后，我将内容复制到我的README.md并提交它。</p><p id="5056" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">对包进行版本控制</strong></p><p id="8f67" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我用的是<a class="ae jg" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本</a>。要对包进行版本控制，编号必须在*中保持一致。csproj，。nuspec和git存储库中的。为此，我使用了定制的PowerShell脚本。</p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="27c9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是通过从src文件夹运行它来执行的。</p><p id="31f2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh mg mh mi mj b">.\bump-assembly-version.ps1 -Version 0.0.1</code></p><figure class="ma mb mc md fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="a6a7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是通过从src文件夹运行它来执行的。</p><p id="a89f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh mg mh mi mj b">.\bump-nuspec-version-ps1 -Version 0.0.1</code></p><p id="0a93" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，我提交这些更改</p><p id="6af4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh mg mh mi mj b">git commit -am "Incremented project version"</code></p><p id="e9c6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在推送任何东西之前，我确保我的存储库被标记了相同的版本，这样我们就有了一个对应于发布版本的标签</p><p id="7f45" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh mg mh mi mj b">git tag -a 0.0.1 -m "Release 0.0.1"</code></p><p id="2757" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="lf">(上述所有内容都可以轻松构建到一个脚本文件中。我仍然单独做，但将来可能会合并:)</em></p><p id="a0f7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后按下标签</p><p id="7642" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh mg mh mi mj b">git push origin 0.0.1</code></p><p id="b49a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">代码呢</p><p id="2726" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh mg mh mi mj b">git push</code></p><h2 id="d43b" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">发布包</h2><p id="5df7" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">有不同的方法可以做到这一点。要么在本地使用nuget CLI将包推送到您的提要，要么让您的CI服务来完成这项工作。</p><p id="9fa2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我让Azure DevOps和Azure Pipelines来做这件事。构建过程由标准组成。NET生成/运行测试任务。如果你对它的外观感兴趣，你可以在这里找到例子。</p><p id="3ab6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，nuget包是基于nuspec文件制作的。然后这个包被推送到我们内部的nuget feed。为了无缝地工作，Azure DevOps中添加了到我们的nuget提要的服务连接。使用的包管理器是<a class="ae jg" href="https://inedo.com/proget" rel="noopener ugc nofollow" target="_blank"> ProGet </a>。</p><p id="5a20" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当这个包发布的时候，我通常会通知Slack上的所有开发者新的包已经发布，并从那里开始任何进一步的讨论。</p></div><div class="ab cl mk ml hc mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hn ho hp hq hr"><p id="ceef" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是一个适合我的过程。如果你对此有任何意见或其他方法，我想听听。什么样的特性应该被提取到nuget包中实际上取决于你的公司以及你如何在团队之间共享代码。我更喜欢有一个一致的做事方式，我注意到如果我们可以重用其他人已经构建好的东西，我们可以在项目中节省很多时间。</p><p id="1913" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你喜欢这个帖子，你知道该怎么做！👏</p></div></div>    
</body>
</html>