<html>
<head>
<title>How I replaced Redux with Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何用Redux替换Redux</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-i-replaced-redux-with-redux-20bb184827c8?source=collection_archive---------6-----------------------#2018-11-28">https://medium.com/hackernoon/how-i-replaced-redux-with-redux-20bb184827c8?source=collection_archive---------6-----------------------#2018-11-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/f4b845ea6e6f2510e0c8f35df4794918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8YqtfypVLwHalayvbh5YnQ.jpeg"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Artwork by RJ Barnes</figcaption></figure><div class=""/><div class=""><h2 id="29ff" class="pw-subtitle-paragraph jg ii ij bd b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ek translated">以及如何构建简单、可预测的具有流量标准功能的减压器</h2></div><h1 id="b2c7" class="jy jz ij bd ka kb kc kd ke kf kg kh ki jp kj jq kk js kl jt km jv kn jw ko kp dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="764e" class="pw-post-body-paragraph kq kr ij ks b kt ku jk kv kw kx jn ky kz la lb lc ld le lf lg lh li lj lk ll hn dt translated">我写了<code class="eh lm ln lo lp b"><a class="ae lq" href="https://www.npmjs.com/package/flux-standard-functions" rel="noopener ugc nofollow" target="_blank">flux-standard-functions</a></code>，这是一个<a class="ae lq" href="https://bundlephobia.com/result?p=flux-standard-functions" rel="noopener ugc nofollow" target="_blank">小(2.1kb) </a>包，用于为Redux构建简单的、可预测的减速器。它有助于让令人敬畏的事情变得简单，比如用清晰、有效的原子突变替换reducer样板文件。它适用于现有的和新建的项目。⭐ <a class="ae lq" href="https://github.com/skonves/flux-standard-functions" rel="noopener ugc nofollow" target="_blank">给它一颗星！</a> ⭐</p><h1 id="80f3" class="jy jz ij bd ka kb kc kd ke kf kg kh ki jp kj jq kk js kl jt km jv kn jw ko kp dt translated">Redux很难</h1><p id="5717" class="pw-post-body-paragraph kq kr ij ks b kt ku jk kv kw kx jn ky kz la lb lc ld le lf lg lh li lj lk ll hn dt translated">Redux是大家又爱又恨的库。几乎没有一天我不看到一些文章声称“库X”正在杀死Redux。Redux为什么很“硬”，为什么开发者这么一心想“干掉”它？</p><figure class="ls lt lu lv fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lr"><img src="../Images/ed5f9a23dee850156283f8a3267d5c4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C2cONOWgFin9WvxHNkXvww.png"/></div></div></figure><p id="63aa" class="pw-post-body-paragraph kq kr ij ks b kt lw jk kv kw lx jn ky kz ly lb lc ld lz lf lg lh ma lj lk ll hn dt translated">从根本上说，Redux的存在是为了解决“人类思维很难思考的两个概念:突变和异步”之间的紧张关系。这是通过与另一个潜在的困难概念:间接性的权衡来实现的。如果处理得当，这样的权衡会产生非常好的结果。然而，如果你认为Redux是一个银弹，你会有一段不好的时间。</p><blockquote class="mb"><p id="7c17" class="mc md ij bd me mf mg mh mi mj mk ll ek translated">“重复是一种交易”——丹·阿布拉莫夫</p></blockquote><p id="1758" class="pw-post-body-paragraph kq kr ij ks b kt ml jk kv kw mm jn ky kz mn lb lc ld mo lf lg lh mp lj lk ll hn dt translated">但是除了间接的复杂性，Redux还有另一个困难:它的简单性。Redux的一个最好的特性是它缺少这些特性。在写这篇文章的时候，这个库在缩小和压缩后只有2.6kb。它的小尺寸是由于它缺乏特征和观点。这种简单性使得Redux非常灵活。</p><p id="5c17" class="pw-post-body-paragraph kq kr ij ks b kt lw jk kv kw lx jn ky kz ly lb lc ld lz lf lg lh ma lj lk ll hn dt translated">但是最终的灵活性往往会成为生产力的障碍。Andrew Clark引入了一个“通量动作对象的人性化标准”，他称之为“<a class="ae lq" href="https://github.com/redux-utilities/flux-standard-action" rel="noopener ugc nofollow" target="_blank">通量标准动作</a>”(或FSA)，以控制动作的灵活性。他观察到“如果我们能够对它们的形状做出某些假设，那么处理流动行为就会容易得多。”FSAs引入的观点有助于开发者推理动作的形状，然而，仍然缺乏构建reducers的类似标准。</p><p id="dde0" class="pw-post-body-paragraph kq kr ij ks b kt lw jk kv kw lx jn ky kz ly lb lc ld lz lf lg lh ma lj lk ll hn dt translated">Redux reducers的大部分样板来自于无处不在的对象定制传播，以创建新的状态。通量标准函数(FSF)是一组特定的函数，可以组合成减速器。通过去除Redux的一些终极灵活性，FSF允许开发人员构建和理解简单的、可预测的reducers。</p><p id="205c" class="pw-post-body-paragraph kq kr ij ks b kt lw jk kv kw lx jn ky kz ly lb lc ld lz lf lg lh ma lj lk ll hn dt translated">当面临像Redux这样的挑战时，开发人员有几个选择:改善体验或“杀死它”并使用其他东西。总的来说，我发现Redux权衡对于大型项目来说是值得的。因此，在通过大量Redux reducers寻找通用模式之后，我认为我找到了一个简单、全面、高效且向后兼容的解决方案。</p><h1 id="35e2" class="jy jz ij bd ka kb kc kd ke kf kg kh ki jp kj jq kk js kl jt km jv kn jw ko kp dt translated">给我看看代码！</h1><p id="3e5f" class="pw-post-body-paragraph kq kr ij ks b kt ku jk kv kw kx jn ky kz la lb lc ld le lf lg lh li lj lk ll hn dt translated">下面是一个基于Redux文档中提供的<a class="ae lq" href="https://redux.js.org/introduction/examples" rel="noopener ugc nofollow" target="_blank">示例</a>的“Todo缩减器”示例:</p><figure class="ls lt lu lv fq hw"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="0c0d" class="pw-post-body-paragraph kq kr ij ks b kt lw jk kv kw lx jn ky kz ly lb lc ld lz lf lg lh ma lj lk ll hn dt translated">以下是用通量标准函数实现的相同示例:</p><figure class="ls lt lu lv fq hw"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="4e05" class="pw-post-body-paragraph kq kr ij ks b kt lw jk kv kw lx jn ky kz ly lb lc ld lz lf lg lh ma lj lk ll hn dt translated">首先，让我们来看看最明显的区别。首先，Todo ( <code class="eh lm ln lo lp b">todoDef</code>)的结构是在reducer之外定义的。这样做有助于防止重复，因为我们添加了更多的Todo操作类型。接下来，由此产生的还原函数<em class="ms">真的很小！</em></p><p id="9182" class="pw-post-body-paragraph kq kr ij ks b kt lw jk kv kw lx jn ky kz ly lb lc ld lz lf lg lh ma lj lk ll hn dt translated">第二，我们实际上免费得到了一些在最初的例子中没有的东西。如果<code class="eh lm ln lo lp b">id</code>未定义，那么原来的缩减器将创建一个无效的新状态。在“FSF”的例子中，如果Todo <code class="eh lm ln lo lp b">id</code>未定义，<code class="eh lm ln lo lp b">set</code>函数确定Todo无效，并通过引用返回原始状态。这种验证不仅确保应用程序状态保持有效，还增加了性能优化，即如果没有任何变化，就不返回新的状态对象。</p><p id="ae54" class="pw-post-body-paragraph kq kr ij ks b kt lw jk kv kw lx jn ky kz ly lb lc ld lz lf lg lh ma lj lk ll hn dt translated">为了进行更多的比较(包括验证)，最初手写的reducer看起来更像这样:</p><figure class="ls lt lu lv fq hw"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="b3da" class="pw-post-body-paragraph kq kr ij ks b kt lw jk kv kw lx jn ky kz ly lb lc ld lz lf lg lh ma lj lk ll hn dt translated">上面的例子开始展示了一个非常简单的操作是如何随着时间的推移而膨胀的。我们所做的只是添加验证，突然我们在多个位置定义了相同的Todo属性。随着这一缩减函数随着时间的推移而发展，并且随着新的动作类型的添加，将变得难以确保待办事项的定义和验证在整个待办事项缩减器中保持一致。</p><p id="ca91" class="pw-post-body-paragraph kq kr ij ks b kt lw jk kv kw lx jn ky kz ly lb lc ld lz lf lg lh ma lj lk ll hn dt translated">这只是简化一个相当简单的操作(向state添加一个新项)的一个例子。让我们来看一下这三个函数，以理解如何使用它们来构建您能想到的几乎所有的缩减器。</p><figure class="ls lt lu lv fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mt"><img src="../Images/b4119ba04ad694343dcfb9fc7fca6610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SISNYELNKHnqG8jUkSUGiQ.jpeg"/></div></div></figure><h1 id="fcd0" class="jy jz ij bd ka kb kc kd ke kf kg kh ki jp kj jq kk js kl jt km jv kn jw ko kp dt translated">三大功能</h1><p id="52ea" class="pw-post-body-paragraph kq kr ij ks b kt ku jk kv kw kx jn ky kz la lb lc ld le lf lg lh li lj lk ll hn dt translated">标准函数使用三个参数的组合:<code class="eh lm ln lo lp b">target</code>、<code class="eh lm ln lo lp b">payload</code>和<code class="eh lm ln lo lp b">definition</code>。<code class="eh lm ln lo lp b">target</code>是正在被“变异”的数据。(注意:如果<code class="eh lm ln lo lp b">target</code>改变了，那么就创建了一个浅层克隆。(<code class="eh lm ln lo lp b">payload</code>)是添加、更新、替换或删除的新数据。<code class="eh lm ln lo lp b">definition</code>是描述<code class="eh lm ln lo lp b">target</code>对象结构的对象，用于验证、索引和优化。</p><figure class="ls lt lu lv fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mu"><img src="../Images/6038e21b58da1e0d43c784e03c47fe4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bf6HOfA8H6FbeCvoyvQr5g.jpeg"/></div></div></figure><h2 id="2d5c" class="mv jz ij bd ka mw mx my ke mz na nb ki kz nc nd kk ld ne nf km lh ng nh ko ni dt translated">一组</h2><p id="981f" class="pw-post-body-paragraph kq kr ij ks b kt ku jk kv kw kx jn ky kz la lb lc ld le lf lg lh li lj lk ll hn dt translated">Set提供了添加或覆盖数据的能力。这类似于“创建”CRUD操作。如果正在设置的值已经存在，则它将被覆盖。如果设置的值不存在，则添加该值。任何设置了不包含在<code class="eh lm ln lo lp b">definition</code>中的值或被定义为不可变的值的操作都将被忽略。</p><p id="5664" class="pw-post-body-paragraph kq kr ij ks b kt lw jk kv kw lx jn ky kz ly lb lc ld lz lf lg lh ma lj lk ll hn dt translated">使用<code class="eh lm ln lo lp b"><a class="ae lq" href="https://github.com/skonves/flux-standard-functions/blob/master/src/functions/set.md" rel="noopener ugc nofollow" target="_blank">set</a></code>进行单值操作，使用<code class="eh lm ln lo lp b"><a class="ae lq" href="https://github.com/skonves/flux-standard-functions/blob/master/src/functions/set-each.md" rel="noopener ugc nofollow" target="_blank">setEach</a></code>进行批量操作。</p><figure class="ls lt lu lv fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mu"><img src="../Images/16c8d82d989696e51b067f2a4d7d9f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XhUtjIa9-9dzfww2WxWnxA.jpeg"/></div></div></figure><h2 id="c384" class="mv jz ij bd ka mw mx my ke mz na nb ki kz nc nd kk ld ne nf km lh ng nh ko ni dt translated">修补</h2><p id="04a2" class="pw-post-body-paragraph kq kr ij ks b kt ku jk kv kw kx jn ky kz la lb lc ld le lf lg lh li lj lk ll hn dt translated">修补程序提供了更新(或“更新”)数据的能力。这类似于“更新”CRUD操作。如果要修补的值已经存在，那么它将被替换。对于复杂属性，将使用<code class="eh lm ln lo lp b">payload</code>中的属性进行部分更新。如果该属性尚不存在，并且根据<code class="eh lm ln lo lp b">definition</code>有效，则将添加该属性。</p><p id="8486" class="pw-post-body-paragraph kq kr ij ks b kt lw jk kv kw lx jn ky kz ly lb lc ld lz lf lg lh ma lj lk ll hn dt translated">使用<code class="eh lm ln lo lp b"><a class="ae lq" href="https://github.com/skonves/flux-standard-functions/blob/master/src/functions/patch.md" rel="noopener ugc nofollow" target="_blank">patch</a></code>进行单个补丁操作，使用<code class="eh lm ln lo lp b"><a class="ae lq" href="https://github.com/skonves/flux-standard-functions/blob/master/src/functions/patch-each.md" rel="noopener ugc nofollow" target="_blank">patchEach</a></code>进行批量操作。</p><figure class="ls lt lu lv fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nj"><img src="../Images/7651d80cc80eb777fd2c688459ce0c4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*67QT8L6GB-8KF2RyhpKlMw.jpeg"/></div></div></figure><h2 id="359f" class="mv jz ij bd ka mw mx my ke mz na nb ki kz nc nd kk ld ne nf km lh ng nh ko ni dt translated">未设置</h2><p id="b269" class="pw-post-body-paragraph kq kr ij ks b kt ku jk kv kw kx jn ky kz la lb lc ld le lf lg lh li lj lk ll hn dt translated">Unset提供了删除数据的能力。这类似于“删除”CRUD操作。如果存在未设置的值，则将其删除。如果未设置的值不存在，或者被<code class="eh lm ln lo lp b">definition</code>指定为必需的或不可变的，那么什么都不会发生。</p><p id="4cf9" class="pw-post-body-paragraph kq kr ij ks b kt lw jk kv kw lx jn ky kz ly lb lc ld lz lf lg lh ma lj lk ll hn dt translated">使用<code class="eh lm ln lo lp b">unset</code>删除单个值，使用<code class="eh lm ln lo lp b">unsetEach</code>进行批量未设置操作。</p><h1 id="3e87" class="jy jz ij bd ka kb kc kd ke kf kg kh ki jp kj jq kk js kl jt km jv kn jw ko kp dt translated">定义和规则</h1><p id="478d" class="pw-post-body-paragraph kq kr ij ks b kt ku jk kv kw kx jn ky kz la lb lc ld le lf lg lh li lj lk ll hn dt translated">标准函数使用<code class="eh lm ln lo lp b">definition</code>参数来验证更改。<code class="eh lm ln lo lp b"><a class="ae lq" href="https://github.com/skonves/flux-standard-functions/blob/master/src/define.md" rel="noopener ugc nofollow" target="_blank">define()</a></code>函数用于创建应用程序状态中对象类型的定义。</p><p id="02bf" class="pw-post-body-paragraph kq kr ij ks b kt lw jk kv kw lx jn ky kz ly lb lc ld lz lf lg lh ma lj lk ll hn dt translated">以下是定义“用户”类型的示例:</p><figure class="ls lt lu lv fq hw"><div class="bz el l di"><div class="mq mr l"/></div></figure><p id="a17d" class="pw-post-body-paragraph kq kr ij ks b kt lw jk kv kw lx jn ky kz ly lb lc ld lz lf lg lh ma lj lk ll hn dt translated">以下规则可用于创建类型定义:</p><ul class=""><li id="441a" class="nk nl ij ks b kt lw kw lx kz nm ld nn lh no ll np nq nr ns dt translated"><code class="eh lm ln lo lp b">key()</code>:属性是“索引”或表的“键”</li><li id="52f7" class="nk nl ij ks b kt nt kw nu kz nv ld nw lh nx ll np nq nr ns dt translated"><code class="eh lm ln lo lp b">immutable()</code>:该属性一旦设置就不能更改</li><li id="44d4" class="nk nl ij ks b kt nt kw nu kz nv ld nw lh nx ll np nq nr ns dt translated"><code class="eh lm ln lo lp b">required()</code>:房产必须存在</li><li id="e2dc" class="nk nl ij ks b kt nt kw nu kz nv ld nw lh nx ll np nq nr ns dt translated"><code class="eh lm ln lo lp b">optional()</code>:房产可能存在或<code class="eh lm ln lo lp b">undefined</code></li><li id="7103" class="nk nl ij ks b kt nt kw nu kz nv ld nw lh nx ll np nq nr ns dt translated"><code class="eh lm ln lo lp b">indexOf(def)</code>:所提供定义的“索引”中的属性</li><li id="074b" class="nk nl ij ks b kt nt kw nu kz nv ld nw lh nx ll np nq nr ns dt translated"><code class="eh lm ln lo lp b">objectOf(def)</code>:属性是一个复杂的对象</li><li id="b334" class="nk nl ij ks b kt nt kw nu kz nv ld nw lh nx ll np nq nr ns dt translated"><code class="eh lm ln lo lp b">arrayOf()</code>:该属性是一个原始数组</li></ul><p id="8750" class="pw-post-body-paragraph kq kr ij ks b kt lw jk kv kw lx jn ky kz ly lb lc ld lz lf lg lh ma lj lk ll hn dt translated">注意，Typescript也允许开发人员定义类型；但是，Typescript类型只是一种编译时构造。一旦代码被编译成普通的Javascript，类型定义本身就消失了。这意味着它们不能在运行时用于验证。正因为如此，<code class="eh lm ln lo lp b">define()</code>函数被设计成独立于Typescript或者与Typescript协同工作。如果您使用的是Typescript，那么您可以进行丰富的类型和属性检查。如果您没有使用Typescript，那么您仍然可以从标准函数提供的运行时验证中受益。</p><h1 id="4f4c" class="jy jz ij bd ka kb kc kd ke kf kg kh ki jp kj jq kk js kl jt km jv kn jw ko kp dt translated">先前技术</h1><p id="3410" class="pw-post-body-paragraph kq kr ij ks b kt ku jk kv kw kx jn ky kz la lb lc ld le lf lg lh li lj lk ll hn dt translated">和大多数新库一样，Flux标准函数站在巨人的肩膀上。几个项目影响了这个项目的开发(或者至少尝试解决一个类似的问题)。在这里不提他们是我的失职。</p><h2 id="d5e0" class="mv jz ij bd ka mw mx my ke mz na nb ki kz nc nd kk ld ne nf km lh ng nh ko ni dt translated"><a class="ae lq" href="https://github.com/redux-utilities/flux-standard-action#readme" rel="noopener ugc nofollow" target="_blank">通量标准动作</a></h2><p id="9bf3" class="pw-post-body-paragraph kq kr ij ks b kt ku jk kv kw kx jn ky kz la lb lc ld le lf lg lh li lj lk ll hn dt translated">“通量动作对象的人性化标准。如果我们能够对它们的形状做出某些假设，那么处理通量动作就会容易得多。”标准函数基于一个相似的原理，即如果我们可以对它们的组成进行假设，减速器就很容易构建。</p><h2 id="e584" class="mv jz ij bd ka mw mx my ke mz na nb ki kz nc nd kk ld ne nf km lh ng nh ko ni dt translated"><a class="ae lq" href="https://redux.js.org/recipes/structuringreducers/normalizingstateshape" rel="noopener ugc nofollow" target="_blank"> Redux数据归一化</a></h2><p id="0530" class="pw-post-body-paragraph kq kr ij ks b kt ku jk kv kw kx jn ky kz la lb lc ld le lf lg lh li lj lk ll hn dt translated">Redux文档中讨论的<a class="ae lq" href="https://redux.js.org/recipes/structuringreducers/normalizingstateshape" rel="noopener ugc nofollow" target="_blank">数据标准化原则对该项目产生了重大影响。像文档推荐的那样，Flux标准函数在“平坦”或规范化状态下工作良好。在这个项目中,“表”的概念不严格地解释为“索引”。我也建议保持州政府不变。YMMV。</a></p><h2 id="8984" class="mv jz ij bd ka mw mx my ke mz na nb ki kz nc nd kk ld ne nf km lh ng nh ko ni dt translated"><a class="ae lq" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank">下划线/连字符</a></h2><p id="ecac" class="pw-post-body-paragraph kq kr ij ks b kt ku jk kv kw kx jn ky kz la lb lc ld le lf lg lh li lj lk ll hn dt translated"><code class="eh lm ln lo lp b">_.set</code>和<code class="eh lm ln lo lp b">_.merge</code>功能大致映射到<code class="eh lm ln lo lp b">set</code>和<code class="eh lm ln lo lp b">patch</code>标准功能。在网上可以找到很多使用下划线或连字符来构建减号的例子。这个项目提供了一个类似lodash的功能的小子集，为使用Redux进行了优化。</p><h2 id="0903" class="mv jz ij bd ka mw mx my ke mz na nb ki kz nc nd kk ld ne nf km lh ng nh ko ni dt translated"><a class="ae lq" href="https://www.npmjs.com/package/normalizr" rel="noopener ugc nofollow" target="_blank">正常化</a></h2><p id="9c01" class="pw-post-body-paragraph kq kr ij ks b kt ku jk kv kw kx jn ky kz la lb lc ld le lf lg lh li lj lk ll hn dt translated">Normalizr是一个很小但很强大的实用程序，用于获取带有模式定义的JSON，并返回包含id的嵌套实体，这些id收集在字典中。</p><h2 id="caac" class="mv jz ij bd ka mw mx my ke mz na nb ki kz nc nd kk ld ne nf km lh ng nh ko ni dt translated"><a class="ae lq" href="https://www.npmjs.com/package/immer" rel="noopener ugc nofollow" target="_blank">沉浸</a></h2><p id="0009" class="pw-post-body-paragraph kq kr ij ks b kt ku jk kv kw kx jn ky kz la lb lc ld le lf lg lh li lj lk ll hn dt translated">Immer是在开发Flux标准函数期间流行的热门新库，绝对值得一看。它是“一个微小的包，允许你以更方便的方式处理不可变状态。它基于<a class="ae lq" href="https://en.wikipedia.org/wiki/Copy-on-write" rel="noopener ugc nofollow" target="_blank"> <em class="ms">写时复制</em> </a>机制。”</p><h2 id="3d03" class="mv jz ij bd ka mw mx my ke mz na nb ki kz nc nd kk ld ne nf km lh ng nh ko ni dt translated">角度1</h2><p id="9c04" class="pw-post-body-paragraph kq kr ij ks b kt ku jk kv kw kx jn ky kz la lb lc ld le lf lg lh li lj lk ll hn dt translated">更多信息请参见本次<a class="ae lq" href="https://www.youtube.com/watch?v=dQw4w9WgXcQ" rel="noopener ugc nofollow" target="_blank">会议讲座</a>。</p><h1 id="f232" class="jy jz ij bd ka kb kc kd ke kf kg kh ki jp kj jq kk js kl jt km jv kn jw ko kp dt translated">喜欢你看到的吗？</h1><p id="264f" class="pw-post-body-paragraph kq kr ij ks b kt ku jk kv kw kx jn ky kz la lb lc ld le lf lg lh li lj lk ll hn dt translated">希望你觉得这个项目很有趣！如果是这样，以下是你可以提供帮助的方式:</p><ol class=""><li id="5a1c" class="nk nl ij ks b kt lw kw lx kz nm ld nn lh no ll ny nq nr ns dt translated">怪异的行为？令人困惑的文件？Github问题超级有帮助！😃</li><li id="f978" class="nk nl ij ks b kt nt kw nu kz nv ld nw lh nx ll ny nq nr ns dt translated">给它一颗星:<a class="ae lq" href="https://github.com/skonves/flux-standard-functions" rel="noopener ugc nofollow" target="_blank">https://github.com/skonves/flux-standard-functions</a>⭐</li><li id="1087" class="nk nl ij ks b kt nt kw nu kz nv ld nw lh nx ll ny nq nr ns dt translated">给这个帖子几个👏</li></ol></div></div>    
</body>
</html>