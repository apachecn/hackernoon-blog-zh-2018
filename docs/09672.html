<html>
<head>
<title>Cons of Serverless Architectures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器架构的缺点</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/cons-of-serverless-architectures-7b8b570c19da?source=collection_archive---------1-----------------------#2018-11-29">https://medium.com/hackernoon/cons-of-serverless-architectures-7b8b570c19da?source=collection_archive---------1-----------------------#2018-11-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="c745" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">批判性地审视无服务器架构的一些潜在缺点，这些缺点在大肆宣传中经常被忽视。</h2></div><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff jk"><img src="../Images/e1baad524c2bf36fe7be6e95d6d81751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*of10JYNtsI0bQQyEoWlxgA.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Not really but you get the point</figcaption></figure><p id="e876" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">围绕“<a class="ae kw" href="https://hackernoon.com/tagged/serverless" rel="noopener ugc nofollow" target="_blank">无服务器</a>”这个业界最受欢迎的词汇之一的兴奋和狂热还在继续增长。许多文章、书籍和会议都围绕无服务器展开了大肆宣传，主要谈论无服务器带来的好处和创新用例。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff kx"><img src="../Images/75c8de87e780fad115c29822acf76da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XHdxCYUIwHvBb-3Oe4JvSg.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Source: Google Trends for Serverless 2016-2018</figcaption></figure><p id="65f6" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">但是无服务器的缺点呢？当前有哪些限制需要复杂的解决方案，有时甚至超过了好处？在所有的兴奋和进入门槛降低的情况下，许多人很快就采取了冒险行动，而没有理解潜在的缺点，这些缺点需要仔细考虑才能获得全部潜力。</p><p id="25dc" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我构建无服务器解决方案已经超过3年，这是我试图捕捉无服务器<a class="ae kw" href="https://hackernoon.com/tagged/architectures" rel="noopener ugc nofollow" target="_blank">架构</a>的一些最常见的缺点:</p><h1 id="dd39" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated"><strong class="ak"> 1。好贵啊！</strong></h1><p id="3c99" class="pw-post-body-paragraph ka kb hu kc b kd lq iv kf kg lr iy ki kj ls kl km kn lt kp kq kr lu kt ku kv hn dt translated">这可能违背了你所听到的关于无服务器的一切，所以在干草叉出来之前，让我来证实一下这种轻率的断言。根据工作负载，无服务器<em class="lv">可能</em>很快变得昂贵。这里有一个例子:</p><p id="9c3b" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">让我们假设您正在运行一个简单的无服务器应用程序，它具有1个Lambda函数和1个API网关，需要24x7支持每秒100个API请求。这给了我们:</p><ul class=""><li id="af32" class="lw lx hu kc b kd ke kg kh kj ly kn lz kr ma kv mb mc md me dt translated">API网关:<strong class="kc hv">$ 917/月</strong><br/>[$ 3.50/百万API调用* 2.62亿API请求/月= $917]</li><li id="3e55" class="lw lx hu kc b kd mf kg mg kj mh kn mi kr mj kv mb mc md me dt translated">Lambda: <strong class="kc hv"> $1，300/月<br/></strong>[$ 0.00001667 GB-秒*(2.62亿次请求*每次执行0.3秒* 1 GB内存- 400K空闲层秒)= $1，308]</li><li id="77b8" class="lw lx hu kc b kd mf kg mg kj mh kn mi kr mj kv mb mc md me dt translated"><strong class="kc hv">总计:2，217美元/月</strong></li></ul><h2 id="c094" class="mk kz hu bd la ml mm mn le mo mp mq li kj mr ms lk kn mt mu lm kr mv mw lo mx dt translated">2217美元太多了！</h2><p id="7ec3" class="pw-post-body-paragraph ka kb hu kc b kd lq iv kf kg lr iy ki kj ls kl km kn lt kp kq kr lu kt ku kv hn dt translated">考虑一下通过运行基于云的应用服务器，您可以获得什么:</p><ul class=""><li id="9d4d" class="lw lx hu kc b kd ke kg kh kj ly kn lz kr ma kv mb mc md me dt translated">3台高可用性EC2服务器:<strong class="kc hv"> $416 </strong> <br/>【通用超大型m5.xlarge: 16.0 GiB RAM，4个vCPUs @ $ 0.19每小时x每月730小时x 3个负载平衡实例以实现高可用性】</li><li id="7b41" class="lw lx hu kc b kd mf kg mg kj mh kn mi kr mj kv mb mc md me dt translated">应用负载平衡器:<strong class="kc hv"> $39 </strong></li><li id="c4bd" class="lw lx hu kc b kd mf kg mg kj mh kn mi kr mj kv mb mc md me dt translated">总计:455美元/月</li><li id="3e43" class="lw lx hu kc b kd mf kg mg kj mh kn mi kr mj kv mb mc md me dt translated">或者308美元/月，如果您得到的是预订的实例类型</li></ul><h2 id="dbe8" class="mk kz hu bd la ml mm mn le mo mp mq li kj mr ms lk kn mt mu lm kr mv mw lo mx dt translated">这比无服务器便宜80%!</h2><p id="0803" class="pw-post-body-paragraph ka kb hu kc b kd lq iv kf kg lr iy ki kj ls kl km kn lt kp kq kr lu kt ku kv hn dt translated">现在，无服务器架构可以在运营和维护底层基础设施方面抽象出大量昂贵的开销，这是吸引力的一大部分。但是一旦你在云上，有几个PaaS产品(例如AWS的<a class="ae kw" href="https://aws.amazon.com/elasticbeanstalk/" rel="noopener ugc nofollow" target="_blank"> AWS Elastic Beanstalk </a>等等)可以为你管理大量的基础设施开销，包括安全补丁、健康检查、自动伸缩、监控等等。这有助于缩小无服务器与基于服务器的托管产品之间的差距。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff my"><img src="../Images/e93a3a9f0b53bf55c2a7cdba4263a5e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vm33miIXXQk--bDNvt0cNw.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Cost Comparison: Serverless vs Server based application. This example compares AWS Lambda with a highly available AWS Elastic Beanstalk application</figcaption></figure><h1 id="a6e8" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated">2.仅在一个云环境中工作的独角兽解决方案，也称为供应商锁定</h1><h2 id="3631" class="mk kz hu bd la ml mm mn le mo mp mq li kj mr ms lk kn mt mu lm kr mv mw lo mx dt translated">集成降低了便携性</h2><p id="395d" class="pw-post-body-paragraph ka kb hu kc b kd lq iv kf kg lr iy ki kj ls kl km kn lt kp kq kr lu kt ku kv hn dt translated">无服务器产品正以前所未有的速度发展，单一用途的服务可以作为构建块自然地粘合在一起，以创建一个整体解决方案。例如，AWS Lambda可以与用于数据流触发器的AWS Kinesis、用于通知的AWS SNS以及用于微服务编排的AWS Step函数集成，以创建端到端的无服务器解决方案。尽管基本的FaaS功能可以跨云使用，但是一旦与其他本机服务集成，您就失去了可移植性。</p><h2 id="73a0" class="mk kz hu bd la ml mm mn le mo mp mq li kj mr ms lk kn mt mu lm kr mv mw lo mx dt translated">特定云提供商独有的专有服务</h2><p id="c8c4" class="pw-post-body-paragraph ka kb hu kc b kd lq iv kf kg lr iy ki kj ls kl km kn lt kp kq kr lu kt ku kv hn dt translated">许多无服务器产品都是专有的，具有无法移植的独特功能。例如，AWS DynamoDB和Azure CosmosDB都是无服务器的NoSQL数据库。但是它们的索引结构、嵌套和限制是如此的不同，以至于你几乎被供应商锁定了。</p><h2 id="e8d8" class="mk kz hu bd la ml mm mn le mo mp mq li kj mr ms lk kn mt mu lm kr mv mw lo mx dt translated">FaaS缺乏跨云提供商运行时的一致性和灵活性</h2><p id="5d01" class="pw-post-body-paragraph ka kb hu kc b kd lq iv kf kg lr iy ki kj ls kl km kn lt kp kq kr lu kt ku kv hn dt translated">即使在跨云的FaaS产品中，平台选择仍然不一致。如果你是一家使用AWS Lambda的Java商店，你不能在不重写整个应用程序的情况下将你的FaaS迁移到Azure或Google，因为Java还没有做好生产准备。节点。JS是跨云的最常见的FaaS运行时，但是运行时的选择仍然有限，并且经常落后于最新版本。相比之下，基于服务器的应用程序允许语言、操作系统和运行时版本的灵活性。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff mz"><img src="../Images/2e6feacb33491eba94d5d262d523fe74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*weNvyHRVVcnYEA07AIFBww.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">AWS Lambda vs Azure Functions vs Google Functions — as of November, 2018</figcaption></figure><h1 id="7604" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated">3.产生多种变通办法的局限性</h1><p id="6cce" class="pw-post-body-paragraph ka kb hu kc b kd lq iv kf kg lr iy ki kj ls kl km kn lt kp kq kr lu kt ku kv hn dt translated">一旦您开始重构一个本地应用程序，使其作为无服务器运行，您可能会发现它的多重局限性。其中一些是好的，因为它们导致了更好的设计，但是它们仍然有局限性——特别是如果这意味着更多的重构。局限性可以单独成为一篇文章，所以为了简明扼要，我将列出一些最常见的局限性:</p><ul class=""><li id="3abc" class="lw lx hu kc b kd ke kg kh kj ly kn lz kr ma kv mb mc md me dt translated">对执行时间的硬性限制(从5到15分钟)</li><li id="8218" class="lw lx hu kc b kd mf kg mg kj mh kn mi kr mj kv mb mc md me dt translated">不支持有状态应用程序</li><li id="258f" class="lw lx hu kc b kd mf kg mg kj mh kn mi kr mj kv mb mc md me dt translated">没有本地存储</li><li id="6814" class="lw lx hu kc b kd mf kg mg kj mh kn mi kr mj kv mb mc md me dt translated">对调用有效负载大小的硬限制(例如，AWS Lambda为128 KB)</li><li id="b3fe" class="lw lx hu kc b kd mf kg mg kj mh kn mi kr mj kv mb mc md me dt translated">由于在扩展过程中实例化新容器，冷启动可能会导致延迟</li><li id="e900" class="lw lx hu kc b kd mf kg mg kj mh kn mi kr mj kv mb mc md me dt translated">缺少本地测试选项</li><li id="4621" class="lw lx hu kc b kd mf kg mg kj mh kn mi kr mj kv mb mc md me dt translated">部署、管理和开发的工具限制</li><li id="c21d" class="lw lx hu kc b kd mf kg mg kj mh kn mi kr mj kv mb mc md me dt translated">自动协调大规模无服务器应用程序的部署</li><li id="eff4" class="lw lx hu kc b kd mf kg mg kj mh kn mi kr mj kv mb mc md me dt translated">并发性和帐户范围的平台限制</li><li id="800d" class="lw lx hu kc b kd mf kg mg kj mh kn mi kr mj kv mb mc md me dt translated">安全性仅限于平台特定的不可移植的<strong class="kc hv"> </strong>安全特性，而不是操作系统级别的控制</li></ul><h1 id="ad58" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated">4.故障排除是痛苦的</h1><p id="d9b0" class="pw-post-body-paragraph ka kb hu kc b kd lq iv kf kg lr iy ki kj ls kl km kn lt kp kq kr lu kt ku kv hn dt translated">随着无服务器应用程序的增长，由于FaaS应用程序的设计工作方式，故障排除的复杂性急剧增加。</p><h2 id="b69f" class="mk kz hu bd la ml mm mn le mo mp mq li kj mr ms lk kn mt mu lm kr mv mw lo mx dt translated">分布式监控</h2><p id="65aa" class="pw-post-body-paragraph ka kb hu kc b kd lq iv kf kg lr iy ki kj ls kl km kn lt kp kq kr lu kt ku kv hn dt translated">无服务器允许将应用程序分解成更小的模块。但是这可能导致分布式监控的新问题。由于一堆无服务器组件链接在一起，端到端跟踪请求/响应的能力变得至关重要，但在使用传统监控工具时往往非常麻烦。</p><h2 id="368f" class="mk kz hu bd la ml mm mn le mo mp mq li kj mr ms lk kn mt mu lm kr mv mw lo mx dt translated">排除故障</h2><p id="9a6e" class="pw-post-body-paragraph ka kb hu kc b kd lq iv kf kg lr iy ki kj ls kl km kn lt kp kq kr lu kt ku kv hn dt translated">分布式应用程序意味着您需要更多地依赖日志跟踪来对问题的根本原因进行反向工程。允许自省和逐行单步执行的经典运行时调试器对于无服务器应用程序是不可能的。</p><h2 id="21d5" class="mk kz hu bd la ml mm mn le mo mp mq li kj mr ms lk kn mt mu lm kr mv mw lo mx dt translated">本地和远程测试</h2><p id="337a" class="pw-post-body-paragraph ka kb hu kc b kd lq iv kf kg lr iy ki kj ls kl km kn lt kp kq kr lu kt ku kv hn dt translated">本地测试需要在本地复制所有无服务器限制。这个领域有很大的发展，使得在本地测试变得相对容易。但是进展主要是在组件级别(例如，一个单独的功能)，而不是在无服务器应用程序级别。在一些情况下，并行无服务器堆栈需要在单独的帐户上启动，以确保测试不会超过帐户范围的平台限制。</p><h1 id="0627" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated">5.需要重大的思维转变</h1><p id="acf7" class="pw-post-body-paragraph ka kb hu kc b kd lq iv kf kg lr iy ki kj ls kl km kn lt kp kq kr lu kt ku kv hn dt translated">最滞后的一个领域可能是仍以虚拟机配置模式运行的ITOps的思维转变。我经历过一些组织，在这些组织中，创建单个AWS Lambda功能会启动过时的审批流程，包括不相关的基础架构信息和等待1-2周的审批。没有升级到在新的无服务器世界中工作的ITOps可能是一个严重的瓶颈。</p><p id="9fd5" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">使用过时的流程和资源，用无服务器架构启动一个新项目，从一开始就注定失败。有培训选项可用，但这需要投入时间、金钱和思想开放的参与者，他们可以忘却和学习新的方法。</p><h1 id="dad1" class="ky kz hu bd la lb lc ld le lf lg lh li ja lj jb lk jd ll je lm jg ln jh lo lp dt translated">摘要</h1><p id="67b7" class="pw-post-body-paragraph ka kb hu kc b kd lq iv kf kg lr iy ki kj ls kl km kn lt kp kq kr lu kt ku kv hn dt translated">了解无服务器架构的一些潜在缺点可以帮助您做出明智的决策。与所有新技术一样，在采用无服务器产品之前，请仔细评估您的应用需求和利弊。</p><h2 id="2f39" class="mk kz hu bd la ml mm mn le mo mp mq li kj mr ms lk kn mt mu lm kr mv mw lo mx dt translated"><strong class="ak">不要盲目跟风无服务器的炒作！</strong></h2><p id="8844" class="pw-post-body-paragraph ka kb hu kc b kd lq iv kf kg lr iy ki kj ls kl km kn lt kp kq kr lu kt ku kv hn dt translated">话虽如此，我坚信未来将会是无服务器的，有一个成熟的工具集和框架来解决上面提到的许多限制。随着更广泛的无服务器社区获得使用这些新技术的经验，它只会进一步改善无服务器生态系统。</p><p id="6910" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv"> <em class="lv">尾注<br/> </em> </strong></p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="na nb l"/></div></figure></div></div>    
</body>
</html>