<html>
<head>
<title>Laravel GraphQL Gotchas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Laravel GraphQL Gotchas</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/laravel-graphql-gotchas-1d32f69b997b?source=collection_archive---------23-----------------------#2018-11-29">https://medium.com/hackernoon/laravel-graphql-gotchas-1d32f69b997b?source=collection_archive---------23-----------------------#2018-11-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ea2e684e8d3e46d54aa8fb494cbb1139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8MI9uuaOVEGeq4w2L8U7Hg.png"/></div></div></figure><p id="cc88" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于我正在进行的一个新项目，我必须用Laravel编写一个GraphQL API。我引入了Lighthouse GraphQL服务器包，几周前,<a class="ae ka" href="https://laravel-news.com/lighthouse-graphql-server-for-laravel" rel="noopener ugc nofollow" target="_blank">Laravel News报道了这个包,</a>并开始跟踪文档。虽然大多数事情都像我预期的那样工作，但我花了相当多的时间调试一些没有并且没有在任何地方记录的问题，所以在我弄清楚它们之后，我认为这篇文章可以帮助面临相同情况的其他人。</p><h1 id="3bdf" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">密码长度检查</h1><p id="e70c" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">想象一下，你有一个创建用户的变种，来创建用户。它使用<code class="eh le lf lg lh b">@bcrypt</code>指令(由Lighthouse提供)让我们的生活变得更简单:代码如下:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="697c" class="lq kc hu lh b fv lr ls l lt lu">type Mutation {<br/>     createUser(<br/>         name: String @rules(apply: ["required"])<br/>         email: String @rules(apply: ["required", "email", "unique:users,email"])<br/>         password: String @rules(apply: ["required", "string", "min:6", "max:255"]) @bcrypt<br/>     ): User @create(model: "App\\User")<br/>}</span></pre><p id="6c13" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可能会认为包含两个字符的密码会引发错误，但它实际上是有效的。显然，客户端散列密码，然后执行验证。作为一种变通方法，您可以通过执行<code class="eh le lf lg lh b">php artisan lighthouse:mutation CreateUser</code>将迁移的逻辑移动到一个控制器，然后手动散列并创建一个用户。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="7e8e" class="lq kc hu lh b fv lr ls l lt lu"><strong class="lh hv">&lt;?php<br/></strong>namespace App\Http\GraphQL\Mutations;</span><span id="7ccc" class="lq kc hu lh b fv lv ls l lt lu">use App\User;<br/>use GraphQL\Type\Definition\ResolveInfo;<br/>use Nuwave\Lighthouse\Support\Contracts\GraphQLContext;</span><span id="fd1e" class="lq kc hu lh b fv lv ls l lt lu">class CreateUser {<br/>     public function resolve($rootValue, array $args, GraphQLContext $context = null, ResolveInfo $resolveInfo)<br/>     {<br/>         return User::create([<br/>             'username' =&gt; $args['username'],<br/>             'email'    =&gt; $args['email'],<br/>             'password' =&gt; bcrypt($args['password']),<br/>         ]);<br/>     }<br/> }</span></pre><h1 id="3bba" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">政策</h1><p id="d77c" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Lighthouse提供了一个<code class="eh le lf lg lh b">@can</code>指令来检查用户是否被授权执行指定的操作，但是它只对通用模型有效(这意味着您可以检查用户是否有创建模型的权限，但是您不能检查对单一模型的删除等权限)。解决这个问题的方法是，再次将您的变异/查询移动到一个控制中，并检查那里的权限。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="6178" class="lq kc hu lh b fv lr ls l lt lu"><strong class="lh hv">&lt;?php<br/></strong>namespace App\Http\GraphQL\Mutations;</span><span id="4b23" class="lq kc hu lh b fv lv ls l lt lu">use App\SecureResource;<br/>use GraphQL\Type\Definition\ResolveInfo;<br/>use Nuwave\Lighthouse\Support\Contracts\GraphQLContext;</span><span id="8534" class="lq kc hu lh b fv lv ls l lt lu">class DoSecureStuff {<br/>     public function resolve($rootValue, array $args, GraphQLContext $context = null, ResolveInfo $resolveInfo)<br/>     {<br/>         abort_unless(request()-&gt;user()-&gt;can('update', SecretResource::find($args['id']));<br/>         // do stuff<br/>     }<br/>}</span></pre><h1 id="b642" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">组织路由</h1><p id="65dd" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果你在一个相对较大的项目中使用这个库，你的<code class="eh le lf lg lh b">schema.graphql</code>可能是一个+200 LOC的烂摊子。如果你想稍微整理一下，你可以把它分成更小的文件，比如<code class="eh le lf lg lh b">user.graphql</code>或者<code class="eh le lf lg lh b">pages.graphql</code>，然后把它们包含在你的主模式中:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="3c0a" class="lq kc hu lh b fv lr ls l lt lu">#import user.graphql<br/>#import pages.graphql<br/>#import something-else.graphql</span></pre><p id="a324" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是要小心！只能有一个<code class="eh le lf lg lh b">Query</code>和一个<code class="eh le lf lg lh b">Mutation</code>类型。你必须扩展其他的:</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="a651" class="lq kc hu lh b fv lr ls l lt lu">extend type Query {<br/>    pages: [Page!]! @paginate(type: "paginator" model: "App\\Page")<br/>}</span><span id="c874" class="lq kc hu lh b fv lv ls l lt lu">extend type Mutation {<br/>    deletePage( id: ID! @rules(apply: ["required"]) ): User @delete(model: "App\\Page")<br/>}</span></pre><h1 id="6d1e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">调试GraphQL错误</h1><p id="ea65" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这个库非常难以调试，因为GraphQL处理程序捕捉所有错误以避免客户端失败，并返回<code class="eh le lf lg lh b">null</code>而不是结果。为了克服这个问题，您可以更新包的配置文件(<code class="eh le lf lg lh b">lighthouse.php</code>):</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="1ec1" class="lq kc hu lh b fv lr ls l lt lu">/*<br/>     |--------------------------------------------------------------------------<br/>     | Debug<br/>     |--------------------------------------------------------------------------<br/>     |<br/>     | Control the debug level as described in <a class="ae ka" href="http://webonyx.github.io/graphql-php/error-handling/" rel="noopener ugc nofollow" target="_blank">http://webonyx.github.io/graphql-php/error-handling/</a><br/>     | Debugging is only applied if the global Laravel debug config is set to true.<br/>     |<br/>     */<br/>-    'debug' =&gt; Debug::INCLUDE_DEBUG_MESSAGE | Debug::INCLUDE_TRACE,<br/>+    'debug' =&gt; Debug::INCLUDE_DEBUG_MESSAGE | Debug::RETHROW_INTERNAL_EXCEPTIONS</span></pre><h1 id="8f9c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="4e22" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">虽然它仍然需要一些工作，但是这个包使得用Laravel开发GraphQL APIs变得非常容易。而且，如果你在一个项目中使用这个库，我建议你花五分钟的时间给合作者写一封感谢信。他们一定会很感激的！</p></div><div class="ab cl lw lx hc ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hn ho hp hq hr"><p id="1017" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="md">原载于</em> <a class="ae ka" href="https://miguelpiedrafita.com/laravel-graphql-gotchas/" rel="noopener ugc nofollow" target="_blank"> <em class="md">我的博客</em> </a> <em class="md">。</em></p></div></div>    
</body>
</html>