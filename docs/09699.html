<html>
<head>
<title>Why I prefer NW.js over Electron? (2018 comparison)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我更喜欢NW.js而不是Electron？(2018年对比)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-i-prefer-nw-js-over-electron-2018-comparison-e60b7289752?source=collection_archive---------0-----------------------#2018-11-30">https://medium.com/hackernoon/why-i-prefer-nw-js-over-electron-2018-comparison-e60b7289752?source=collection_archive---------0-----------------------#2018-11-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/d23e32df55085323a24717fa99eac884.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*BI0IJM0IZUwBHIkKLA_9LA.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">NW.js vs Electron (forgive the horrible design!)</figcaption></figure><p id="7097" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我将给出一些客观的原因，为什么我更喜欢与<a class="ae ka" href="https://nwjs.io/" rel="noopener ugc nofollow" target="_blank"> NW.js </a>(以前的node-webkit)一起工作，而不是与另一个家伙:<a class="ae ka" href="https://electronjs.org/" rel="noopener ugc nofollow" target="_blank">电子</a>。</p><p id="440b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你还不知道的话，这两个项目都是建立在<a class="ae ka" href="https://www.chromium.org/Home" rel="noopener ugc nofollow" target="_blank"> Chromium </a>和<a class="ae ka" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>之上的，所以你可以在系统级(文件系统访问等)使用Node.js编写桌面应用程序，并在GUI层使用web技术。</p><p id="2357" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，电子有一些优点:</p><ol class=""><li id="0548" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated"><strong class="je hv">电子更受开发者欢迎:</strong>几乎在我看到的每一篇帖子或文章中，人们都偏爱电子。从其他指标也可以清楚地看出这一点，比如Github stars、npm下载量等。</li><li id="1c48" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><strong class="je hv">电子有更好的企业支持:</strong> Github /微软在电子后面，而NW.js由Intel赞助。两个最流行的ide(<a class="ae ka" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank">vs code</a>和<a class="ae ka" href="https://atom.io/" rel="noopener ugc nofollow" target="_blank"> Atom </a>)都是用电子构建的。另一方面，我所知道的唯一一个使用NW.js构建的大项目已经停产。我指的是英特尔XDK公司。然而，在与NW.js的创建者和维护者罗杰·王(Roger Wang)交谈后，他指出，还有其他一些“大型”应用程序——规模都很大，而且拥有庞大的活跃用户群——使用NW.js构建，他指出，“微信小程序的官方IDE在NW.js上运行。使用它开发的小程序超过100万个。迷你程序运行在微信即时通讯软件上，该软件每月有超过10亿活跃用户。查看更多关于<a class="ae ka" href="https://techcrunch.com/2018/11/07/wechat-mini-apps-200-million-users/" rel="noopener ugc nofollow" target="_blank"> TechCrunch </a>”的内容。</li><li id="db5c" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">电子提供开箱即用的<strong class="je hv">自动更新机制</strong>。</li><li id="d7de" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">最后，它的<strong class="je hv">构建过程稍微简单一点</strong>，因为你不需要构建整个Chromium。有关这方面的更多信息，<a class="ae ka" href="https://electronjs.org/docs/development/atom-shell-vs-node-webkit" rel="noopener ugc nofollow" target="_blank">查看此处</a>和<a class="ae ka" href="https://electronjs.org/docs/development/build-instructions-gn" rel="noopener ugc nofollow" target="_blank">此处</a>。(但是，大多数用户既不需要构建NW.js，也不需要构建electronic)。</li></ol><p id="e938" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是为什么有人会选择电子的一些原因。现在，让我解释一下为什么我会走相反的方向。在我看来，NW.js比电子更好！</p></div><div class="ab cl kp kq hc kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hn ho hp hq hr"><h2 id="171e" class="kw kx hu bd ky kz la lb lc ld le lf lg jn lh li lj jr lk ll lm jv ln lo lp lq dt translated">1.传统系统支持</h2><p id="abe0" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">NW.js (LTS版本0.14.x)支持Windows XP和旧版本的Mac OS。我知道即使是微软也已经放弃了对XP的支持，但是在很多领域，很多人仍然在使用它(它在一些国家拥有巨大的市场份额)。你不能只告诉你的客户升级！他们不会听的。</p></div><div class="ab cl kp kq hc kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hn ho hp hq hr"><h2 id="19eb" class="kw kx hu bd ky kz la lb lc ld le lf lg jn lh li lj jr lk ll lm jv ln lo lp lq dt translated">2.应用程序主条目可以是HTML页面或Node.js文件</h2><p id="343d" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">NW.js更面向浏览器。您可以将您的<code class="eh lw lx ly lz b">main</code>条目设置为HTML文件或Node.js文件，或者两者都是(使用package.json中的<code class="eh lw lx ly lz b">main</code>、<code class="eh lw lx ly lz b">node-main</code>和<code class="eh lw lx ly lz b">bg-script</code>字段)。在Electron中，您必须使用Node.js文件，并显式创建您的应用程序主窗口并打开它。</p><p id="9073" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">NW.js的方法要简单和直接得多。它给你很多选择。它允许你做你在电子中能做的事，但反之则不然。</p></div><div class="ab cl kp kq hc kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hn ho hp hq hr"><h2 id="0498" class="kw kx hu bd ky kz la lb lc ld le lf lg jn lh li lj jr lk ll lm jv ln lo lp lq dt translated">3.分离和混合环境</h2><p id="5633" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">关于JavaScript上下文，NW.js有一个简单而强大的机制。电子有两个独立的上下文(主进程和渲染进程)，它们是完全分离的。在NW.js中，您有两种选择:单独的上下文和混合的上下文。在我看来，这两种方式都比电子方式更简单直接。您可以构建整个应用程序，而无需复杂的IPC消息。</p><p id="8822" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里的问题是，NW.js文档在这一点上非常非常混乱。事实上，我写了另一篇博文草稿(希望很快会发表),试图阐明NW.js中的上下文，以及如何在上下文和窗口之间轻松共享变量和状态，两种模式都有:分离和混合。</p></div><div class="ab cl kp kq hc kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hn ho hp hq hr"><h2 id="1123" class="kw kx hu bd ky kz la lb lc ld le lf lg jn lh li lj jr lk ll lm jv ln lo lp lq dt translated">4.Chrome扩展和。* APIs支持</h2><p id="dfcd" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">NW.js支持chrome。*原料药。更好的是，你可以使用NW.js运行Chrome应用/扩展，Electron不能(并且<a class="ae ka" href="https://github.com/electron/electron/issues/13123#issuecomment-399662730" rel="noopener ugc nofollow" target="_blank">不会</a>)这样做。</p></div><div class="ab cl kp kq hc kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hn ho hp hq hr"><h2 id="94a7" class="kw kx hu bd ky kz la lb lc ld le lf lg jn lh li lj jr lk ll lm jv ln lo lp lq dt translated">5.现成的PDF(和Flash)插件</h2><p id="3086" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">NW.js支持开箱即用的PDF文件，使用Chrome PDF原生插件。它工作起来非常流畅，你甚至可以设置<code class="eh lw lx ly lz b">"main": "file.pdf"</code>，它就会工作。您可以在<code class="eh lw lx ly lz b">&lt;iframe&gt;</code>、<code class="eh lw lx ly lz b">&lt;webview&gt;</code>中显示PDF文件，或者只需将第<code class="eh lw lx ly lz b">location</code>页指向PDF文件。</p><p id="2bef" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">据推测，Electron在<a class="ae ka" href="https://github.com/electron/electron/releases/tag/v1.6.4" rel="noopener ugc nofollow" target="_blank">版本1.6.4 </a>中添加了这个特性。但是很bug(检查:<a class="ae ka" href="https://stackoverflow.com/questions/52844135/view-pdf-in-electron-browserwindow" rel="noopener ugc nofollow" target="_blank"> 01 </a>，<a class="ae ka" href="https://stackoverflow.com/questions/43220321/electron-pdf-viewer" rel="noopener ugc nofollow" target="_blank"> 02 </a>)。我尝试过很多方法(使用Electron v3.0.8)在Electron内部显示一个PDF文件(<code class="eh lw lx ly lz b">&lt;iframe src='./file.pdf'&gt;</code>、<code class="eh lw lx ly lz b">&lt;webview src='./file.pdf' plugins&gt;</code>等很多)，但是Electron一直试图下载文件，没有按预期显示。经过一个小时的寻找解决方案，我放弃了。</p></div><div class="ab cl kp kq hc kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hn ho hp hq hr"><h2 id="9951" class="kw kx hu bd ky kz la lb lc ld le lf lg jn lh li lj jr lk ll lm jv ln lo lp lq dt translated">6.源代码保护</h2><p id="3dde" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">NW.js有一个源码保护工具。这允许您将JavaScript编译成V8字节码(以前它用于产生机器码)。另一方面，电子公司的人拒绝完全实现这个特性。</p><p id="2719" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，我做了一个极简工具，<a class="ae ka" href="https://github.com/OsamaAbbas/bytenode" rel="noopener ugc nofollow" target="_blank"> bytenode </a>，它允许Node.js开发人员(甚至在<a class="ae ka" href="https://github.com/OsamaAbbas/bytenode/tree/master/examples/electron-hello-world" rel="noopener ugc nofollow" target="_blank"> Electron </a>中)将他们的代码编译成V8字节码。</p><p id="5103" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Bytenode只编译Node.js代码，而将在浏览器中运行的JavaScript代码(通过<code class="eh lw lx ly lz b">&lt;script&gt;</code>标签)无法使用它进行编译。所以，NW.js在这里做得更好，因为他们的工具<code class="eh lw lx ly lz b">nwjc</code>编译浏览器端的JavaScript。使用这两个工具(<code class="eh lw lx ly lz b">bytenode</code>和<code class="eh lw lx ly lz b">nwjc</code>)你可以编译你的整个应用程序，甚至是第三方库(比如jQuery)。</p></div><div class="ab cl kp kq hc kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hn ho hp hq hr"><h2 id="bd1b" class="kw kx hu bd ky kz la lb lc ld le lf lg jn lh li lj jr lk ll lm jv ln lo lp lq dt translated">7.NW.js使用最新的Chromium版本</h2><p id="9664" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">NW.js团队正在努力跟上Chromium版本。所以在Chromium新版本出来的第二天，他们将发布NW.js的新版本(最新版本的Node.js与Chromium具有相同的V8版本)。</p><p id="dfdd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然您可能不总是需要最新的Chromium版本，但是许多人确实需要。显然是NW.js的优势。</p><p id="8b59" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一方面，Electron team更愿意等待几周甚至几个月，然后再转向更新的chromium版本。</p></div><div class="ab cl kp kq hc kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hn ho hp hq hr"><h2 id="5d40" class="kw kx hu bd ky kz la lb lc ld le lf lg jn lh li lj jr lk ll lm jv ln lo lp lq dt translated">8.NW.js有‐‐url标志并支持Chromium命令行开关</h2><p id="3643" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">你可以用<code class="eh lw lx ly lz b">--url</code>标志:<br/> <code class="eh lw lx ly lz b">/path/to/nw --url="https://www.google.com/ncr"</code>启动NW.js来打开URI，所以这是启动你的应用的第三种方式(除了使用HTML页面和JavaScript文件)。</p><p id="57c8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">NW.js还支持所有Chromium命令行开关。更多信息，请查看<a class="ae ka" href="http://docs.nwjs.io/en/latest/References/Command%20Line%20Options" rel="noopener ugc nofollow" target="_blank"> NW.js文档</a>。这些开关可用于调整和优化性能。</p><p id="f569" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一方面，电子没有对应的<code class="eh lw lx ly lz b">--url</code>。你必须用一个JavaScript文件启动你的应用程序，创建你的应用程序窗口，然后手动导航到URI。它也不支持所有的铬开关，<a class="ae ka" href="https://github.com/electron/electron/blob/master/docs/api/chrome-command-line-switches.md" rel="noopener ugc nofollow" target="_blank">只支持其中的一部分</a>。</p></div><div class="ab cl kp kq hc kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hn ho hp hq hr"><h2 id="54b7" class="kw kx hu bd ky kz la lb lc ld le lf lg jn lh li lj jr lk ll lm jv ln lo lp lq dt translated">9.NW.js可以在没有开发工具的情况下发布</h2><p id="c07f" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">在electronic中，总是有DevTools嵌入在电子二进制文件中。可以这么简单打开:<br/> <code class="eh lw lx ly lz b">mainWindow.webContents.openDevTools();</code>。</p><p id="f63e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在NW.js中，您将在生产中使用“普通”构建，它不包含DevTools(只有SDK构建包含)。如果有人试图以编程方式打开dev tools:<br/><code class="eh lw lx ly lz b">nw.Window.get().showDevTools();</code>，他会发现一个空白的白色屏幕。</p><p id="3251" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">是的，理论上他可以使用SDK构建来运行您的应用程序，但是您可以在您的代码中防止这种情况(通过检查<code class="eh lw lx ly lz b">process.version[’nw-flavor’]</code>是否等于<code class="eh lw lx ly lz b">normal</code>，结合源代码保护，检查上面的№ 6)。你不能在电子版中这样做(如果我错了，请纠正我)。</p></div><div class="ab cl kp kq hc kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hn ho hp hq hr"><h2 id="d8f1" class="kw kx hu bd ky kz la lb lc ld le lf lg jn lh li lj jr lk ll lm jv ln lo lp lq dt translated">10.打印PDF文件</h2><p id="c205" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">如果您的应用程序需要轻松打印PDF文件，您应该使用NW.js。无论您是打印网页(使用<code class="eh lw lx ly lz b">nw.Window.get().print()</code>功能)，还是想要打印PDF文件(使用原生打印按钮，如Chromium所做的那样)，打印都会如预期一样工作。</p><p id="5ba1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一方面，电子用户正在努力获得预期的打印功能。关于这个问题Github有很多开放的问题(比如# <a class="ae ka" href="https://github.com/electron/electron/issues/9029" rel="noopener ugc nofollow" target="_blank"> 9029 </a>)。也参见这个<a class="ae ka" href="https://stackoverflow.com/questions/49650784/printing-a-pdf-file-with-electron-js" rel="noopener ugc nofollow" target="_blank"> StackOverflow问题</a>，它有一些疯狂的变通方法，告诉你使用PDF.js(哎哟！)将其内容呈现在画布上，然后打印出来！其他变通办法建议使用SumatraPDF(哎哟又来了！).再说一遍，如果我错了，请纠正我，我对电子有一点经验。</p></div><div class="ab cl kp kq hc kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hn ho hp hq hr"><h2 id="3b9e" class="kw kx hu bd ky kz la lb lc ld le lf lg jn lh li lj jr lk ll lm jv ln lo lp lq dt translated">11.更好的桌面应用安全模型</h2><p id="6004" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">Chrome中的安全模型(以及一般的网络浏览器)有一点限制性，这是由于你与你访问的网站的关系的性质。浏览器不允许网站访问你的文件系统，网站运行在沙盒环境中，他们受制于同源策略…等等。虽然这在web浏览器和网站的上下文中是有意义的，但是桌面应用程序需要更多。</p><p id="6a08" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">NW.js提供了另一个安全模型，它允许你“绕过所有的安全限制，比如沙箱、同源策略等等。例如，根据<a class="ae ka" href="http://docs.nwjs.io/en/latest/For%20Users/Advanced/Security%20in%20NW.js/" rel="noopener ugc nofollow" target="_blank"> NW.js文档</a>，您可以对任何远程站点进行跨源XHR，或者访问节点框架中<code class="eh lw lx ly lz b">src</code>指向远程站点的<code class="eh lw lx ly lz b">&lt;iframe&gt;</code>元素。罗杰·王(Roger Wang)表示:“在这种模式下，我们可以做的事情越来越多，在(你的)文章中向开发者征求建议可能会很好。欢迎像<a class="ae ka" href="https://github.com/nwjs/nw.js/issues/6696" rel="noopener ugc nofollow" target="_blank">这种</a>的问题报道”。</p><p id="3f7f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">相比之下，electronic禁用了嵌套的<code class="eh lw lx ly lz b">&lt;webview&gt;</code>标签(<a class="ae ka" href="https://github.com/electron/electron/issues/1130#issuecomment-74200896" rel="noopener ugc nofollow" target="_blank"> 01 </a>，<a class="ae ka" href="https://github.com/electron/electron/issues/5036#issuecomment-206826729" rel="noopener ugc nofollow" target="_blank"> 02 </a>)等特性，因为“这是一个维护负担”并且“不容易把事情做好”。(顺便说一下，你可以随心所欲的在NW.js中嵌套<code class="eh lw lx ly lz b">webview</code>标签，但是对于<a class="ae ka" href="http://docs.nwjs.io/en/latest/References/webview%20Tag/#loading-local-files-in-webview" rel="noopener ugc nofollow" target="_blank">本地HTML文件</a>，你必须在<code class="eh lw lx ly lz b">package.json</code>中添加一个权限)。</p></div><div class="ab cl kp kq hc kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hn ho hp hq hr"><p id="24c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我有点偏向NW.js，希望这种偏向没有影响我文章的准确性。任何意见或更正都非常欢迎。</p></div></div>    
</body>
</html>