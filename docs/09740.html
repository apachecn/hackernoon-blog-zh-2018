<html>
<head>
<title>Understanding State Management in JavaScript by Building a Library Similar to Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过构建一个类似Redux的库来理解JavaScript中的状态管理</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-redux-like-state-manager-for-react-cd75cc2853b3?source=collection_archive---------2-----------------------#2018-12-03">https://medium.com/hackernoon/building-a-redux-like-state-manager-for-react-cd75cc2853b3?source=collection_archive---------2-----------------------#2018-12-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="a303" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">对于任何想跳过这篇文章并看到最终结果的人来说，我已经把我写在这里的东西用钩子做了一个库:<a class="ae jt" href="https://github.com/Jahans3/use-simple-state" rel="noopener ugc nofollow" target="_blank"> use-simple-state </a>。它没有依赖性(除了反应为对等依赖性之外),只有3kb，非常轻量级。</p></blockquote><p id="658c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">近年来，web应用程序的范围急剧扩大，随着应用程序需求的增长，复杂性也在增加。为了使这种增加的复杂性更容易处理，某些技术和模式越来越多地被用来使开发人员的生活更容易，并帮助我们构建更健壮的应用程序。</p><p id="f082" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">复杂性增加的一个主要领域是管理我们的应用程序的状态，因此为了解决这个问题，开发人员正在使用提供抽象的库来更新和访问他们的应用程序的状态。最著名的例子是<a class="ae jt" href="https://redux.js.org/introduction" rel="noopener ugc nofollow" target="_blank"> Redux </a>，它是<a class="ae jt" href="https://facebook.github.io/flux/docs/in-depth-overview.html#content" rel="noopener ugc nofollow" target="_blank">通量模式</a>的一种实现。</p><p id="7861" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">一旦开发人员学会了如何使用像Redux这样的库，他们可能仍然想知道“引擎盖下”的一切究竟是如何工作的，因为这一开始并不明显，即使更新全局可用对象的更一般的概念很容易理解。</p><p id="6280" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在本文中，我们将完全从零开始为React应用程序构建自己的状态管理解决方案。我们将从一个只需几行代码就能实现的基本解决方案开始，然后逐步开发更高级的功能，直到我们有了类似Redux的东西。</p><h1 id="1919" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">基本思想</h1><p id="2b4a" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">任何状态管理工具只需要几样东西:对整个应用程序可用的全局状态值，以及读取和更新它的能力。就这样，说真的。</p><p id="775c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">为了向您展示状态管理器有多简单，这里有一个基本的JavaScript实现:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">That’s it, seriously</figcaption></figure><p id="96dc" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">上面的例子是最基本的，但它仍然符合所有的情况:</p><ul class=""><li id="f5e7" class="ll lm hu ix b iy iz jc jd ju ln jv lo jw lp js lq lr ls lt dt translated">代表我们应用程序状态的全局可用值:<code class="eh lu lv lw lx b">state</code></li><li id="6c79" class="ll lm hu ix b iy ly jc lz ju ma jv mb jw mc js lq lr ls lt dt translated">读取我们状态的能力:<code class="eh lu lv lw lx b">getState</code></li><li id="7a55" class="ll lm hu ix b iy ly jc lz ju ma jv mb jw mc js lq lr ls lt dt translated">能够更新我们的状态:<code class="eh lu lv lw lx b">setState</code></li></ul><p id="05ed" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">对于大多数现实世界的应用程序来说，上面的例子太简单了，所以接下来我们将开始实现一个在React应用程序中使用的可行的解决方案。我们将从重构前面的例子开始，让它在React中工作，并从那里开始构建。</p><h1 id="444e" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">React中的状态管理</h1><p id="575e" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">为了制作我们之前解决方案的基于React的版本，我们需要利用两个React特性。第一个特征是普通的旧类组件，也称为<a class="ae jt" href="https://reactjs.org/docs/state-and-lifecycle.html#adding-local-state-to-a-class" rel="noopener ugc nofollow" target="_blank">有状态组件</a>。</p><p id="683a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">第二个特性是<a class="ae jt" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a>，它用于使数据对整个React应用程序可用。一个上下文有两部分:一个<em class="iw">提供者</em>和一个<em class="iw">消费者</em>。顾名思义，提供者向应用程序提供<em class="iw">上下文</em>(数据)。而当我们想要访问上下文时使用消费者。</p><p id="cac6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">理解上下文的一个好方法是:如果<em class="iw">道具</em>用于<strong class="ix hv">显式地</strong>通过你的组件传递数据，那么<em class="iw">上下文</em>用于<strong class="ix hv">隐式地</strong>传递数据。</p><h1 id="b06c" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">构建我们的状态管理器</h1><p id="3dbb" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">现在我们知道了我们想要使用的工具，只是把它们放在一起的问题。我们要做的就是创建一个上下文来保存我们的全局状态，然后将该上下文的<em class="iw">提供者</em>包装在一个<em class="iw">有状态组件</em>中，并使用它来管理状态。</p><p id="1b8a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">首先，让我们使用<code class="eh lu lv lw lx b">React.createContext</code>来创建我们的上下文，这给了我们<code class="eh lu lv lw lx b">Provider</code>和<code class="eh lu lv lw lx b">Consumer</code>:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Baby steps</figcaption></figure><p id="61d7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">接下来，我们需要将我们的<code class="eh lu lv lw lx b">Provider</code>包装在一个<em class="iw">有状态组件</em>中，以便利用它来管理我们应用程序的状态。我们还想导出具有更具体名称的<em class="iw">消费者</em>:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">So far so good</figcaption></figure><p id="1f63" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在上面的代码示例中，我们的<code class="eh lu lv lw lx b">StateProvider</code>只是一个组件，它接受一个<code class="eh lu lv lw lx b">state</code>道具作为初始状态，并使该道具中包含的任何内容对组件树中它下面的任何组件都可用。如果没有提供<code class="eh lu lv lw lx b">state</code>，则使用空对象。</p><p id="8bac" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">使用我们的<code class="eh lu lv lw lx b">StateProvider</code>就像将它包装在应用程序的根组件上一样简单:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Simples</figcaption></figure><p id="1bef" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在我们已经完成了，我们可以使用消费者从<code class="eh lu lv lw lx b">MyApp</code>内部的任何地方访问我们的状态。在这种情况下，我们也已经初始化了我们的状态，使之成为一个只有一个属性的对象:<code class="eh lu lv lw lx b">count</code>，所以无论何时我们访问我们的状态，我们都会发现。</p><p id="9b79" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">消费者使用<a class="ae jt" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">渲染道具</a>来传递上下文数据，这可以在下面看到，其中一个函数是<code class="eh lu lv lw lx b">StateConsumer</code>的子函数。传递给该函数的<code class="eh lu lv lw lx b">state</code>参数表示我们的应用程序的当前状态，因此根据我们的<code class="eh lu lv lw lx b">initialState</code> , <code class="eh lu lv lw lx b">state.count</code>将等于<code class="eh lu lv lw lx b">0</code>。</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Accessing our app’s state</figcaption></figure><p id="d622" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">关于我们的<code class="eh lu lv lw lx b">StateConsumer</code>需要注意的一点是，它自动订阅上下文中的变化，所以当我们的状态改变时，组件将重新呈现以显示更新。这只是消费者的默认行为，我们没有做任何事情来启用它。</p><h1 id="c0e1" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">更新状态</h1><p id="30f2" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">到目前为止，我们已经构建了一些东西，允许我们读取我们的状态，并在它改变时自动更新。现在我们需要一种方法来更新我们的应用程序的状态，为此我们只需在我们的<code class="eh lu lv lw lx b">StateProvider</code>中更新状态。</p><p id="8649" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">您可能已经注意到，我们将一个名为<code class="eh lu lv lw lx b">state</code>的道具传递给了我们的<code class="eh lu lv lw lx b">StateProvider</code>，然后这个道具又被传递给了<em class="iw">组件的</em> <code class="eh lu lv lw lx b">state</code>属性。这是我们将使用React内置的<code class="eh lu lv lw lx b">this.setState</code>方法更新的内容:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="c535" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">继续保持简单的主题，我们刚刚将<code class="eh lu lv lw lx b">this.setState</code>传递到我们的上下文。这意味着我们必须稍微改变上下文的值；我们现在不是只传递<code class="eh lu lv lw lx b">this.state</code>而是传递一个具有两个属性的对象:<code class="eh lu lv lw lx b">state</code>和<code class="eh lu lv lw lx b">setState</code>。</p><p id="7768" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">每当我们使用我们的<code class="eh lu lv lw lx b">StateConsumer</code>时，我们将使用一个<a class="ae jt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">析构赋值</a>来获取<code class="eh lu lv lw lx b">state</code>和<code class="eh lu lv lw lx b">setState</code>，所以现在我们可以读取和写入我们的状态对象:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="c5f3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">需要注意的是，由于我们只是简单地将React的内置<code class="eh lu lv lw lx b">this.setState</code>方法作为我们的<code class="eh lu lv lw lx b">setState</code>函数，额外的属性将与现有状态合并。这意味着如果我们除了<code class="eh lu lv lw lx b">count</code>之外还有第二个属性，那么它将被自动保留。</p><p id="672e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在我们已经建立了一些<em class="iw">可以</em>在现实世界中工作的东西(尽管不是很有效)。它有一个简单的API，React开发人员应该很熟悉，另外它利用了内置工具，所以我们也没有添加任何新的依赖项。如果状态管理库以前感觉有点“神奇”，希望我们已经能够揭示一个库的内部可能是什么样子。</p><h1 id="7b33" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">附加物</h1><p id="77b6" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">那些已经熟悉Redux的人可能已经注意到我们的解决方案在几个方面有所欠缺:</p><ul class=""><li id="92d4" class="ll lm hu ix b iy iz jc jd ju ln jv lo jw lp js lq lr ls lt dt translated">它没有处理副作用的内置方式，你可以通过<a class="ae jt" href="https://redux.js.org/advanced/middleware" rel="noopener ugc nofollow" target="_blank"> Redux中间件</a>获得功能。</li><li id="3213" class="ll lm hu ix b iy ly jc lz ju ma jv mb jw mc js lq lr ls lt dt translated">当与我们的<code class="eh lu lv lw lx b">setState</code>函数内联编写时，复杂的状态更新会很混乱，我们依赖React的默认<code class="eh lu lv lw lx b">this.setState</code>行为来处理我们的状态更新逻辑，也没有重用状态更新的内置方式，这是从<a class="ae jt" href="https://redux.js.org/basics/reducers" rel="noopener ugc nofollow" target="_blank">Redux reducer</a>获得的。</li><li id="1c76" class="ll lm hu ix b iy ly jc lz ju ma jv mb jw mc js lq lr ls lt dt translated">我们也无法处理<a class="ae jt" href="https://redux.js.org/advanced/asyncactions" rel="noopener ugc nofollow" target="_blank">异步动作</a>，这通常是由像<a class="ae jt" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> Redux Thunk </a>和<a class="ae jt" href="https://github.com/redux-saga/redux-saga" rel="noopener ugc nofollow" target="_blank"> Redux Saga </a>这样的库提供的。</li><li id="1040" class="ll lm hu ix b iy ly jc lz ju ma jv mb jw mc js lq lr ls lt dt translated">重要的是，我们没有办法让我们的消费者订阅状态的<em class="iw">部分</em>，这意味着当我们状态的任何部分更新时，每个消费者都将重新呈现。</li></ul><p id="dbb5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">为了克服这一点，我们将通过实现我们自己的动作、reducers和中间件来模拟Redux。我们还将添加对异步操作的内置支持。之后，我们将为我们的消费者实现一种方法，只监听我们状态子集的变化。最后，我们还将看看如何重构我们的代码，因此我们正在使用全新的<a class="ae jt" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> Hooks API </a>。</p><h1 id="8d2f" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">Redux简介</h1><blockquote class="ir is it"><p id="d869" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">免责声明:下面的内容只是为了给你足够的理解来继续这篇文章，我强烈推荐阅读Redux 的官方介绍以获得更全面的解释。</p><p id="e2ac" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">如果您已经对Redux有了很好的了解，可以跳过这一点。</p></blockquote><p id="8ca2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">下面是一个Redux应用程序中数据流的<em class="iw"> </em>简化图:</p><figure class="la lb lc ld fq le fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff md"><img src="../Images/4a42c5209365f82d8f47ea400c8b9dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*15Mk9zBAz55PL6ryhH-sUg.png"/></div></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Redux data flow</figcaption></figure><p id="af91" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">正如你所看到的，有一个<em class="iw">单向</em>数据流——我们<em class="iw">分派</em>一个动作，我们的reducers从这个动作中获得一个更新的状态，没有数据在我们应用程序的不同部分之间来回传输。</p><p id="08f1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">更详细地说:</p><p id="4666" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">首先，我们分派一个动作，该动作描述了对我们状态的一个改变，例如将一个数字加1。与我们之前的方法相比，这种方法更有命令性，我们本质上是直接操纵<code class="eh lu lv lw lx b">count</code>状态:<code class="eh lu lv lw lx b">setState({ count: count + 1 })</code>。</p><p id="6669" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">然后动作通过我们的<em class="iw">中间件。</em> Redux中间件是可选功能，可以执行动作的副作用，例如，如果调度了一个<code class="eh lu lv lw lx b">SIGN_OUT</code>动作，您可以在将动作传递给reducer之前，使用中间件功能从本地存储中删除所有用户数据。如果你熟悉<a class="ae jt" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>中的中间件，这是一个非常相似的概念。</p><p id="7283" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">最后，我们的动作到达采取动作的reducers，以及任何附带的数据，并使用该数据加上现有状态来派生新的状态。假设我们<em class="iw">发送</em>一个名为<code class="eh lu lv lw lx b">ADD</code>的动作，并且我们还发送一个伴随值(名为<em class="iw">有效载荷</em>)，这是我们希望添加到状态中的数量。我们的reducer将检查一个<code class="eh lu lv lw lx b">ADD</code>动作，当它发现一个动作时，它将获取<em class="iw">有效负载</em>以及我们状态中的当前值，并将两者相加以产生我们的更新状态。</p><p id="7966" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">减速器的功能特征如下:</p><pre class="la lb lc ld fq mk lx ml mm aw mn dt"><span id="120b" class="mo jy hu lx b fv mp mq l mr ms">(state, action) =&gt; nextState</span></pre><p id="9793" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">一个缩减器应该只是一个<code class="eh lu lv lw lx b">state</code>和<code class="eh lu lv lw lx b">action.</code>的函数。API简单而强大。需要注意的一个关键点是，归约器应该总是<a class="ae jt" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank">纯函数</a>，这样它们就总是确定的。</p><h1 id="9f3c" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">行动+派遣</h1><p id="2e39" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">现在，我们已经简要介绍了Redux应用程序的一些关键部分，我们需要修改我们的应用程序来模拟相同的行为。首先:我们需要一些动作和一种调度它们的方法。</p><p id="c7a7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">对于我们的动作，我们将使用动作创建器，这些只是创建动作的函数。动作创建者使得测试、重用和传递有效负载到我们的动作变得更加容易。我们还将创建一些动作类型，这些只是字符串常量，因为它们将在我们的reducers中重用，我们将它们存储在变量中:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">So far, so good</figcaption></figure><p id="f4db" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在，我们将实现一个占位符<code class="eh lu lv lw lx b">dispatch</code>函数。我们的占位符将只是一个空函数，我们将用它来替换我们上下文中的<code class="eh lu lv lw lx b">setState</code>函数。我们一会儿将回到这一点，因为我们还没有任何reducers来分派我们的动作。</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><h1 id="bc1c" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">还原剂</h1><p id="c940" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">现在我们有了动作，我们只需要一些reducers来发送它们。回想一下reducer函数签名，它只是一个纯粹的动作和状态函数:</p><pre class="la lb lc ld fq mk lx ml mm aw mn dt"><span id="8177" class="mo jy hu lx b fv mp mq l mr ms">(state, action) =&gt; nextState</span></pre><p id="acd4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">知道了这一点，我们需要做的就是将组件的状态和分派的动作传递给我们的reducers。对于reducers，我们只需要一组符合上述特征的函数。我们使用一个数组，这样我们可以使用<code class="eh lu lv lw lx b">Array.reduce</code>简单地迭代它，直到我们到达我们的新状态:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="7ca0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">正如你所看到的，我们所做的就是使用我们的reducers来计算我们的新状态，然后就像之前一样，我们简单地调用<code class="eh lu lv lw lx b">this.setState</code>来更新<code class="eh lu lv lw lx b">StateProvider</code>的组件状态。</p><p id="82b0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在我们只需要一个真正的减速器:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="3e06" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们的reducer只是检查传入的<code class="eh lu lv lw lx b">action.type</code>，如果发现匹配，它将相应地更新状态，否则我们只是遍历<code class="eh lu lv lw lx b">switch</code>语句，默认情况下从我们的函数返回一个<code class="eh lu lv lw lx b">undefined</code>值。Redux的reducers和我们自己的redox之间的一个重要区别是，当我们不想更新状态时，通常是因为我们没有找到匹配的动作类型，我们返回一个<a class="ae jt" href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy" rel="noopener ugc nofollow" target="_blank"> falsy </a>值，而使用Redux，您将返回未更改的状态。</p><p id="80be" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">并把我们的减速器递给我们的<code class="eh lu lv lw lx b">StateProvider</code>:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Our reducers need to be passed in an array, even if there’s only a single reducer</figcaption></figure><p id="45a6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在我们终于可以分派一些动作，并根据我们发送的动作来观察我们的状态更新:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Reducers done!</figcaption></figure><h1 id="788b" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">中间件</h1><p id="6d21" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">现在我们已经有了一些类似Redux的东西，我们只需要一种方法来处理副作用。为了实现这一点，我们将允许我们的用户传递中间件函数，每当调度一个动作时都会调用这些函数。</p><p id="cb97" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们还希望我们的中间件函数能够帮助我们摆脱状态更新，所以如果<code class="eh lu lv lw lx b">null</code>从一个返回，我们不会将动作传递给我们的reducer。Redux对此的处理略有不同——在Redux中间件中，您需要手动将动作传递给下一个中间件，如果没有使用Redux的<code class="eh lu lv lw lx b">next</code>函数传递，动作将不会到达reducer，状态也不会更新。</p><p id="0802" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在让我们写一个简单的中间件。我们希望它寻找一个<code class="eh lu lv lw lx b">ADD_N</code>动作，如果找到，它应该打印出<code class="eh lu lv lw lx b">payload</code>和现有的<code class="eh lu lv lw lx b">count</code>状态的总和，但是阻止实际的状态更新。</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="4a2a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">就像我们的reducers一样，我们将把任何中间件传递给数组中的<code class="eh lu lv lw lx b">StateProvider</code>:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="3ce0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">最后，我们需要调用我们所有的中间件，并使用结果来确定我们是否想要中止更新。因为我们刚刚传递了一个数组，并且我们正在寻找一个单一的值，我们将使用<code class="eh lu lv lw lx b">Array.reduce</code>来获得我们的结果。就像我们的reducers一样，我们将在调用每个函数时遍历数组，然后将结果传递给一个名为<code class="eh lu lv lw lx b">continueUpdate</code>的变量。</p><p id="18ee" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">由于中间件被认为是一个高级特性<a class="ae jt" href="https://redux.js.org/advanced" rel="noopener ugc nofollow" target="_blank">我们不希望它是强制性的，所以如果在我们的<code class="eh lu lv lw lx b">StateProvider</code>中没有找到<code class="eh lu lv lw lx b">middleware</code>属性，我们将默认设置<code class="eh lu lv lw lx b">continueUpdate</code>等于<code class="eh lu lv lw lx b">undefined</code>。我们还将添加一个<code class="eh lu lv lw lx b">middleware</code>数组作为默认道具，这样如果没有传递任何东西<code class="eh lu lv lw lx b">middleware.reduce</code>就不会抛出错误。</a></p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="0e20" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">正如您在第13行看到的，我们检查中间件函数返回了什么。如果遇到<code class="eh lu lv lw lx b">null</code>值，我们将跳过其余的中间件函数，并且<code class="eh lu lv lw lx b">continueUpdate</code>的值将是<code class="eh lu lv lw lx b">null</code>，这意味着我们将中止更新。</p><h1 id="b707" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">异步操作</h1><p id="1d6b" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">因为我们希望我们的状态管理器在现实世界中有用，所以我们将添加对异步操作的支持，这意味着我们可以轻松地处理像网络请求这样的常见任务。由于API简单、直观且功能强大，我们将在这里借鉴一下Redux Thunk。</p><p id="565e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们要做的就是检查是否有一个未调用的函数被传递给dispatch，如果我们找到一个，我们将在传递<code class="eh lu lv lw lx b">dispatch</code>和<code class="eh lu lv lw lx b">state</code>的同时调用它，这给了用户编写异步操作所需的一切。以此身份验证操作为例:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="84d5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在上面的例子中，我们有一个名为<code class="eh lu lv lw lx b">logIn</code>的动作创建器，但是它没有返回一个对象，而是返回一个接受<code class="eh lu lv lw lx b">dispatch</code>的函数。这允许用户在异步API调用之前和之后调度同步操作。根据API调用的结果，将会分派不同的操作，在这种情况下，如果出现问题，我们将发送一个错误操作。</p><p id="a987" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">实现这一点就像在我们的<code class="eh lu lv lw lx b">StateProvider</code>中的<code class="eh lu lv lw lx b">_dispatch</code>方法中检查<code class="eh lu lv lw lx b">function</code>类型的<code class="eh lu lv lw lx b">action</code>一样简单:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="02f2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这里要注意两件事:当我们调用<code class="eh lu lv lw lx b">action</code>作为函数时，我们传递<code class="eh lu lv lw lx b">this.state</code>以便用户可以访问异步动作中的现有状态，我们还返回函数调用的结果，允许开发人员从他们的异步动作中获得返回值，这打开了更多的可能性，例如从<code class="eh lu lv lw lx b">dispatch</code>链接承诺。</p><h1 id="6c35" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">避免不必要的重新渲染</h1><p id="f958" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">经常被忽略的是Redux(或者更准确地说，<a class="ae jt" href="https://github.com/reduxjs/react-redux" rel="noopener ugc nofollow" target="_blank">React-Redux</a>—Redux的React绑定)的一个基本特性，即它能够在必要时重新呈现组件。为了实现这一点，它使用了<code class="eh lu lv lw lx b">connect</code> <a class="ae jt" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>，该组件采用了一个映射函数——<code class="eh lu lv lw lx b">mapStateToProps</code>——并且只有当<code class="eh lu lv lw lx b">mapStateToProps</code>(从现在开始仅仅是<code class="eh lu lv lw lx b">mapState</code>)的输出改变时，才会触发它所附加的组件的重新渲染。如果不是这种情况，那么每次状态更新时，使用<code class="eh lu lv lw lx b">connect</code>订阅存储更改的每个组件都将被重新呈现<em class="iw">。</em></p><p id="e0cc" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">想想我们需要做什么，我们需要一种方法来存储以前的<code class="eh lu lv lw lx b">mapState</code>输出，这样我们就可以将它与任何新的结果进行比较，以决定我们是否要继续并重新呈现我们的组件。为此，我们将使用一个叫做<a class="ae jt" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">记忆化</a>的过程。像我们行业中的许多事情一样，这对于一个相当简单的过程来说是一个大词，尤其是对我们来说，因为我们可以利用<code class="eh lu lv lw lx b">React.Component</code>将我们状态的子集存储在<code class="eh lu lv lw lx b">this.state</code>中，并且只有当我们检测到<code class="eh lu lv lw lx b">mapState</code>的输出发生变化时才更新它。</p><p id="499d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">接下来，我们需要一种方法来跳过不必要的组件更新。React通过使用生命周期方法<code class="eh lu lv lw lx b">shouldComponentUpdate</code>为我们提供了一个简单的方法。它将任何传入的属性和状态作为参数，这允许我们将值与现有的属性和状态进行比较，如果我们返回<code class="eh lu lv lw lx b">true</code>，更新将继续，但如果我们返回<code class="eh lu lv lw lx b">false</code>，React将跳过渲染。</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="6d9f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">以上是我们下一步要做的概述。它拥有所有的主要部分:它从我们的上下文中接收更新，它实现了<code class="eh lu lv lw lx b">getDerivedStateFromProps</code>和<code class="eh lu lv lw lx b">shouldComponentUpdate</code>，它还将一个渲染道具作为子对象——就像默认消费者一样。我们还通过使用传递的<code class="eh lu lv lw lx b">mapState</code>函数初始化消费者的初始状态。</p><p id="bf73" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">就像现在一样，<code class="eh lu lv lw lx b">shouldComponentUpdate</code>只会在收到第一次状态更新时渲染一次。之后，它将记录传入和现有状态，并返回<code class="eh lu lv lw lx b">false</code>，阻止任何更新。</p><p id="f92e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">上面的解决方案也调用了<code class="eh lu lv lw lx b">shouldComponentUpdate</code>中的<code class="eh lu lv lw lx b">this.setState</code>，正如我们所知<code class="eh lu lv lw lx b">this.setState</code>总是触发重新渲染。因为我们也从<code class="eh lu lv lw lx b">shouldComponentUpdate</code>返回<code class="eh lu lv lw lx b">true</code>，这将导致额外的重新渲染，所以为了避免这种情况，我们将使用生命周期<code class="eh lu lv lw lx b">getDerivedStateFromProps</code>来导出我们的状态，然后我们将使用<code class="eh lu lv lw lx b">shouldComponentUpdate</code>来确定我们是否想要基于我们导出的状态继续渲染过程。</p><p id="cb5e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">如果我们检查我们的控制台，我们可以看到全局状态更新，而我们的组件阻止对它的<code class="eh lu lv lw lx b">this.state</code>对象的任何更新，因此跳过渲染:</p><figure class="la lb lc ld fq le fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/625a7d9d263afc26551de097128684c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*NcExDZZznriXLX9KqjMn3w.png"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Three attempts to update state, but thisState only changes once</figcaption></figure><p id="cffd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">所以现在我们知道了如何防止不必要的更新，我们需要一种方法来智能地确定我们的消费者何时应该呈现。如果我们想的话，我们可以在一个传入的状态对象上<a class="ae jt" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)" rel="noopener ugc nofollow" target="_blank">递归</a>并检查每一个属性，看看它是否被改变了，但是虽然这是一个很好的练习来提高我们的理解，但它可能对性能不利。我们无法知道任何传入的状态对象有多深或多复杂，如果退出条件永远不满足，递归函数将愉快地无限期运行，所以我们将限制比较的范围。</p><p id="6b20" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">就像Redux一样，我们将实现一个<em class="iw">浅层</em>比较函数。这里的“浅”指的是属性的深度，在这个深度我们将查看我们的对象是否相等，这意味着我们将只检查1级深度。因此，我们将检查新状态顶层的每个属性是否等于现有状态上的同名属性，如果同名属性不存在或者它们具有不同的值，我们将继续渲染，否则我们假设我们的状态相同，并中止渲染。</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Our shallow comparison function</figcaption></figure><p id="7372" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">首先，我们从一个简单的检查开始，检查两种状态是否都是对象，如果不是，那么我们跳过渲染。在这个初始检查之后，我们将当前状态转换为一个键/值对的数组，并通过将数组简化为一个布尔型来对照传入的状态对象检查每个属性的值。</p><p id="dd43" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这是最难的部分。现在我们想使用我们的<code class="eh lu lv lw lx b">shallowCompare</code>函数，本质上只是一个调用它并检查结果的例子。如果它返回<code class="eh lu lv lw lx b">true</code>，我们将返回<code class="eh lu lv lw lx b">true</code>以允许重新渲染，否则我们简单地返回<code class="eh lu lv lw lx b">false</code>以跳过更新(并且我们的派生状态被丢弃)。我们还想应用我们的<code class="eh lu lv lw lx b">mapDispatch</code>函数，如果它存在的话。</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Surprisingly simple</figcaption></figure><p id="0f9a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">最后，我们需要向消费者传递一个<code class="eh lu lv lw lx b">mapState</code>函数，该函数仅映射我们的部分状态，因此我们将把它作为道具传递给更新后的<code class="eh lu lv lw lx b">StateConsumer</code>:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="6d9c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在我们只订阅了<code class="eh lu lv lw lx b">greeting</code>中的变化，所以如果我们更新<code class="eh lu lv lw lx b">count</code>，我们的组件将忽略全局状态中的变化，并避免重新呈现。</p><h1 id="4c88" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">快速回顾</h1><p id="1ecd" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">如果您已经做到了这一步，您将会看到如何实现一个类似Redux的状态管理库，包括Redux和actions。我们还讨论了更高级的主题，比如异步操作、中间件，以及如何使它只接收我们想要的状态更新，以避免每次全局状态更新时重新呈现我们的消费者。</p><p id="89c2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">虽然Redux比我们的解决方案有更多的功能，但希望这有助于澄清一些核心概念，并表明虽然Redux通常被认为是一个更高级的主题，但它的实现相对简单。</p><p id="1a25" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">为了更透彻地理解Redux的内部，我强烈推荐阅读Github 上的<a class="ae jt" href="https://github.com/reduxjs/redux/tree/master/src" rel="noopener ugc nofollow" target="_blank">源代码。</a></p><p id="d23b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">到目前为止，我们的解决方案已经具备了在现实项目中使用的所有必要工具和属性。我们可以在React项目中开始使用它，我们不需要Redux，除非我们想访问一些真正高级的特性。</p><h1 id="dc56" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">钩住</h1><p id="69f6" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">如果你还没有听说，钩子很快成为React中的下一个大事件。下面是来自官方介绍的简要说明:</p><blockquote class="ir is it"><p id="c2f1" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">钩子是一个新的特性提议，它让你不用写类就可以使用状态和其他React特性。</p></blockquote><p id="f34b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">钩子给了我们所有高阶组件的能力，并且用一个更干净、更直观的API来渲染道具。</p><p id="919c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">让我们用一个简单的例子来看看它们是如何工作的，这个例子展示了基本的钩子<code class="eh lu lv lw lx b">useState</code>:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="1f19" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在上面的例子中，我们通过将<code class="eh lu lv lw lx b">0</code>传递给<code class="eh lu lv lw lx b">useState</code>来初始化一个新的状态，后者返回我们的状态:<code class="eh lu lv lw lx b">count</code>，以及一个更新函数:<code class="eh lu lv lw lx b">setCount</code>。如果你以前没有见过这个，你可能会想为什么<code class="eh lu lv lw lx b">useState</code>不会在每次渲染时都被重新初始化为<code class="eh lu lv lw lx b">0</code>——这是因为React在内部处理这个问题，所以我们不需要担心这个问题。</p><p id="aa84" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">因此，让我们暂时忘记中间件和异步操作，使用<code class="eh lu lv lw lx b">useReducer</code>钩子重新实现我们的提供者，它的工作方式和<code class="eh lu lv lw lx b">useState</code>一样，只是操作被分派到派生新状态的reducer，就像我们正在构建的一样。</p><p id="9985" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">知道了这一点，我们简单地将我们的reducer逻辑从旧的<code class="eh lu lv lw lx b">StateProvider</code>复制到新的功能性<code class="eh lu lv lw lx b">StateProvider</code>:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="3274" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这就是它可以有多简单，但是尽管我们想让事情变得简单，我们仍然没有完全利用钩子的力量。我们也可以使用钩子将我们的<code class="eh lu lv lw lx b">StateConsumer</code>换成我们自己的定制钩子，我们将通过包装<code class="eh lu lv lw lx b">useContext</code>钩子来实现:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Easy peasy</figcaption></figure><p id="bea6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">然而，之前我们在创建上下文时析构了<code class="eh lu lv lw lx b">Provider</code>和<code class="eh lu lv lw lx b">Consumer</code>，这次我们将它存储在一个变量中，并将其传递给<code class="eh lu lv lw lx b">useContext</code>，以便我们在没有<code class="eh lu lv lw lx b">Consumer</code>的情况下访问上下文。我们还将我们的定制钩子命名为<code class="eh lu lv lw lx b">useStore</code>，因为<code class="eh lu lv lw lx b">useState</code>是一个默认钩子。</p><p id="ae8e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">接下来，我们简单地重构我们消费上下文的方式:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="8037" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">希望这些例子在某种程度上展示了钩子是多么直观、简单和强大。我们减少了所需的代码量，并为自己提供了一个漂亮、简单的API。</p><p id="4330" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们还想让我们的中间件和内置的异步操作支持再次工作。为了做到这一点，我们将把我们的<code class="eh lu lv lw lx b">useReducer</code>包装在一个定制的钩子中，一个专门在我们的<code class="eh lu lv lw lx b">StateProvider</code>中使用的钩子，然后简单地重用我们旧的有状态组件的先前逻辑。</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="d670" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">与我们的旧解决方案一样，我们希望中间件是可选的，所以我们再次添加一个空数组作为缺省值——尽管这一次我们使用一个缺省参数而不是缺省属性。类似于我们以前的调度功能，我们调用我们的中间件，如果<code class="eh lu lv lw lx b">continueUpdate !== null</code>我们继续状态更新。我们也没有改变处理异步动作的方式。</p><p id="d741" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">最后，我们将<code class="eh lu lv lw lx b">useStateProvider</code>的结果及其参数传递给我们的提供者，这个提供者已经大大缩小了:</p><figure class="la lb lc ld fq le"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="49f3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">就是这样！🎉</p><h2 id="4856" class="mo jy hu bd jz mu mv mw kd mx my mz kh ju na nb kl jv nc nd kp jw ne nf kt ng dt translated">然而…</h2><p id="a23f" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">你可能已经注意到的一件事是，我们的钩子实现没有办法跳过不必要的更新。这是因为钩子是如何在函数组件的主体中被调用的——在那个阶段，React没有办法脱离渲染过程(不是没有一些黑客)。不过没必要担心，<a class="ae jt" href="https://github.com/facebook/react/issues/14110" rel="noopener ugc nofollow" target="_blank">React团队已经意识到了这一点</a>，并计划为我们提供一种方法来中止来自功能组件的更新。</p><p id="3edc" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">一旦我们有了一个官方的方法来摆脱函数组件内部的渲染，我会回到这里来更新这篇博文。同时，我在hooks实现之外编写的库附带了一个消费者，因此我们可以访问这个功能。</p><h1 id="d81b" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">概括起来</h1><p id="d374" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf ju kx ji jj jv ky jm jn jw kz jq jr js hn dt translated">总而言之，我们已经研究了最基本的状态管理器，并在它的基础上逐步构建，直到我们最终得到了类似Redux的东西——包括动作、reducers、中间件和一种区分状态更新以提高性能的方法。我们还研究了如何使用全新的hooks API简化我们的代码。</p><p id="9549" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">希望您在这篇文章中找到了一些有用的东西，我能够阐明一些更高级的概念，同时表明我们使用的许多工具可能比它们第一次出现时更简单。</p><blockquote class="ir is it"><p id="3ada" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">正如在开始时简要提到的，我在本文后面写了一个库，<a class="ae jt" href="https://github.com/Jahans3/use-simple-state" rel="noopener ugc nofollow" target="_blank">使用简单状态</a>。你可以在我的<a class="ae jt" href="https://github.com/Jahans3" rel="noopener ugc nofollow" target="_blank"> Github页面</a>上看到它，在那里我为<a class="ae jt" href="https://github.com/Jahans3/use-simple-state/tree/master/src" rel="noopener ugc nofollow" target="_blank">的最终实现</a>使用了钩子，它包括几个额外的特性。</p></blockquote></div><div class="ab cl nh ni hc nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="hn ho hp hq hr"><h2 id="b1c2" class="mo jy hu bd jz mu mv mw kd mx my mz kh ju na nb kl jv nc nd kp jw ne nf kt ng dt translated">推特:<a class="ae jt" href="https://twitter.com/josh_jahans" rel="noopener ugc nofollow" target="_blank"> @josh_jahans </a></h2></div></div>    
</body>
</html>