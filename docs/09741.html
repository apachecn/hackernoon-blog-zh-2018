<html>
<head>
<title>Simple and Complete Module-based Laravel API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单完整的基于模块的Laravel API</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/simple-and-complete-module-based-laravel-app-5fee7a21bf28?source=collection_archive---------3-----------------------#2018-12-03">https://medium.com/hackernoon/simple-and-complete-module-based-laravel-app-5fee7a21bf28?source=collection_archive---------3-----------------------#2018-12-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="d21c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我非常喜欢编写基于模块的软件，但我不太喜欢依赖第三方包来解决琐碎的事情，因为它们总是会阻止你升级。两年来，我一直用Laravel编写基于模块的软件，我对结果非常满意。</p><p id="40c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">驱使我转向基于模块的软件的决定性因素是持续改进的可能性。想象一下，你建立了一个项目结构，6个月后你发现你犯了很多错误。在不影响6个月现有代码的情况下，仅仅改进架构通常是不容易的。在分析这个主题时，我注意到了两个要点:要么在整个项目中有一个标准并坚持下去，要么将它模块化并逐模块改进。</p><p id="327d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有些人宁愿不惜一切代价使用标准，即使这意味着被一个你不再喜欢的标准所束缚。我个人比较喜欢持续改进。如果我写的第20个模块和第一个完全不同，我不介意。如果我需要回到模块1进行错误修复或重构，我可以朝着最新模块使用的新标准改进它。</p><p id="aaf6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果像我一样，您想开发基于模块的Laravel应用程序，并避免在项目中添加不必要的第三方依赖，下面是我的做法。</p><h2 id="097c" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">单路线服务提供商</h2><p id="f769" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">Laravel路由器系统是应用程序的入口点。首先需要改变的是默认的<code class="eh kp kq kr ks b">RouteServiceProvider.php</code>，它应该模块化可用的路由。</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="f288" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以去掉该文件中的所有样板文件，只设置一个模块路由器。</p><h2 id="ab70" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">2-模块文件</h2><p id="523f" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">Laravel在<code class="eh kp kq kr ks b">routes</code>文件夹中附带了一些文件。我们可以删除它们，因为我们不再在RouteServiceProvider中映射它们。让我们创建一个单独的<code class="eh kp kq kr ks b">modules.php</code>路由器文件。</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><h2 id="8d96" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">3-书籍模块</h2><p id="28fd" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">在<code class="eh kp kq kr ks b">app</code>文件夹中，让我们创建<code class="eh kp kq kr ks b">Modules/Books/routes.php</code>。在其中，我们可以为Books模块定义应用程序路径。</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="5c29" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以选择基于控制器的路由，这在Laravel中是标准的。我个人喜欢<a class="ae la" href="https://jenssegers.com/85/goodbye-controllers-hello-request-handlers" rel="noopener ugc nofollow" target="_blank">再见控制器，你好请求处理器</a>的方法。下面是<code class="eh kp kq kr ks b">ListBooks</code>的实现。</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="63ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kp kq kr ks b">BookResource</code>是Laravel的变形层。如名称空间所示，我们可以在<code class="eh kp kq kr ks b">app/Modules/Books/Resources</code>文件夹中创建它。</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><h2 id="b494" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">4-作者模块</h2><p id="e24c" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">让我们通过routes文件启动Authors模块。</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="3c23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意命名空间，它表示我们现在正在将文件写入到<code class="eh kp kq kr ks b">app/Modules/Authors</code>文件夹中。请求处理程序也非常简单。</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="e70d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们编写资源类来将响应转换成JSON。</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="1cfe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意这里的资源是如何进入另一个模块来重用Book资源的。这通常是一件坏事，因为模块应该是完全自给自足的，并且只重用标准类，如雄辩的模型或为在任何模块上重用而设计的通用组件。这个问题的解决方案通常是将BookResource复制到Authors模块中，这样就可以在不破坏另一个模块的情况下对其进行修改，反之亦然。我决定让这种跨模块的用法保持原样，以表明尽管一个很好的经验法则是让模块彼此完全隔离，但是如果您认为用例足够简单并且不太可能带来任何问题，打破这个法则也是可以的。一定要写测试来覆盖你写的特性，以避免别人在不知不觉中破坏你的应用。</p><h2 id="2bd0" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">5-结论</h2><p id="fdb8" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">虽然这是一个非常简单的例子，但我希望它能给人这样的印象:根据自己的需要操纵Laravel标准结构是很容易的。为了构建一个基于模块的应用程序，你可以非常容易地改变文件的位置。我的大多数项目都附带了可被任何模块重用的泛型类的<code class="eh kp kq kr ks b">App/Components</code>；<code class="eh kp kq kr ks b">App/Eloquent</code>保存雄辩的模型和数据库关系，以及<code class="eh kp kq kr ks b">Modules</code>文件夹，我们可以在其中构建任何基于模块的特性。这是我最近开始开发的一个应用程序的文件夹结构:</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff lb"><img src="../Images/04b57594b9752a6f1db1e74fdf8db044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*7U-V2yeqKI1ouk4IYGqu8Q.png"/></div></figure><p id="3e2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望每个人都从中吸取的概念是，每个模块都有它自己的一组需求，并且可以有它自己的一组文件夹/实体/类。没有必要将所有的模块标准化到完全相同，因为有些模块比其他模块简单得多，需要的结构也少得多。这个例子表明<code class="eh kp kq kr ks b">AccountChurn</code>模块通过Http文件夹提供API，同时仍然通过控制台提供Artisan命令。<code class="eh kp kq kr ks b">AccountOverview</code>另一方面，只有Http和必需的存储库、值对象(包)和服务类(分页器)才能提供巨大的价值。</p></div></div>    
</body>
</html>