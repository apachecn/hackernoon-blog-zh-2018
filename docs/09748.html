<html>
<head>
<title>A crash course on Serverless with AWS — Building APIs with Lambda and Aurora Serverless</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS无服务器速成班——用Lambda和Aurora无服务器构建API</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-crash-course-on-serverless-with-aws-building-apis-with-lambda-and-aurora-serverless-49885c46e37a?source=collection_archive---------10-----------------------#2018-12-03">https://medium.com/hackernoon/a-crash-course-on-serverless-with-aws-building-apis-with-lambda-and-aurora-serverless-49885c46e37a?source=collection_archive---------10-----------------------#2018-12-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/8763e743f5ba04b008a882b4ce16713a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UQcKp8EUFyJy_nAmEwMLCA.jpeg"/></div></div></figure><p id="3ebb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">自从AWS做出了一个无服务器选项<a class="ae ka" href="https://aws.amazon.com/blogs/aws/aurora-serverless-ga/" rel="noopener ugc nofollow" target="_blank"> AWS RDS Aurora普遍可用</a>，我就一直坐在座位的边缘，急切地期待着所有各种各样的可能性。这将意味着在构建无服务器架构方面的突破。不再使用SQL管理连接池。不再担心可用连接的上限。这使得使用无服务器进行数据库密集型操作变得可行。</p><p id="cd52" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不久前我写了一篇文章解释<a class="ae ka" href="https://hackernoon.com/building-a-serverless-rest-api-with-node-js-and-mongodb-2e0ed0638f47" rel="noopener ugc nofollow" target="_blank">如何用MongoDB </a>构建一个无服务器API。但是，我看到了一个模式。即使数据库实例可以承担负载，系统中较高的吞吐量也会导致连接减少，因为可用连接的数量有限。</p><h1 id="cda5" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="5f53" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我用MongoDB重构了这个例子，以使用SQL。关于您使用哪个数据库提供商是不可知的，但是我将在这里展示的例子是使用<a class="ae ka" href="https://aws.amazon.com/rds/aurora/serverless/" rel="noopener ugc nofollow" target="_blank"> AWS Aurora无服务器</a>。点击查看代码，或者如果你想继续学习如何自己设置一切，请继续阅读。</p><h1 id="c7a4" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">我们要做什么？</h1><p id="2257" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">本文将向您展示如何将MySQL数据库作为服务连接到无服务器API。我们将使用AWS RDS创建一个数据库集群，并配置Aurora无服务器。这个设置最棒的地方在于，你可以根据你使用服务的多少来付费。甚至数据库！这是理想的无服务器场景。</p><h1 id="9d77" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">如果你是新手呢？</h1><p id="5a1f" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们来分解一下基本的。我们将使用AWS Lambda作为计算服务。AWS Lambda函数基本上是一个容器。一旦Lambda被调用，容器就开始旋转并运行代码。这是我们想要初始化数据库连接的时候，第一次调用函数，第一次初始化容器。对lambda函数的每个后续请求都将使用现有的数据库连接。一旦我把它分解，听起来很简单。让我们跳进来。</p><h1 id="1887" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">配置项目</h1><p id="e956" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我假设你已经对<a class="ae ka" href="https://serverless.com/framework/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>有了基本的了解。我也希望你有一个AWS帐户设置。如果你没有，<a class="ae ka" href="https://hackernoon.com/a-crash-course-on-serverless-with-node-js-632b37d58b44" rel="noopener ugc nofollow" target="_blank">请看看这个</a>。</p><h2 id="e248" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">1.创建服务</h2><p id="5c66" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">一如既往，我们需要一个新的服务来保存我们所有的代码。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="79a9" class="le kc hu lx b fv mb mc l md me">$ sls create -t aws-nodejs -p web-api &amp;&amp; cd web-api</span></pre><p id="ef68" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">运行这个命令，您将得到一个很好的样板文件来开始开发您的函数。它将设置基本功能和事件触发器。你也可以看到我们马上进入了<code class="eh mf mg mh lx b">web-api</code>目录。我们跳转到这个目录来设置所需的依赖项。</p><h2 id="09b7" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">2.安装模块</h2><p id="721d" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">总之，我们只需要三个依赖项。MySQL ORM调用Sequelize来处理连接和映射关系，调用<code class="eh mf mg mh lx b">serverless-offline</code>进行本地开发。</p><p id="f7de" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">确保您在<strong class="je hv"> web-api </strong>目录中。首先安装<code class="eh mf mg mh lx b">serverless-offline</code>，然后安装<code class="eh mf mg mh lx b">mysql2</code>和<code class="eh mf mg mh lx b">sequelize</code>。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="e414" class="le kc hu lx b fv mb mc l md me">$ npm init -y <br/>$ npm i --save-dev serverless-offline <br/>$ npm i --save mysql2 sequelize</span></pre><p id="a867" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就这样，让我们暂时离开终端，跳到AWS来创建一个数据库集群。</p><h2 id="ca73" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">3.在AWS RDS上创建数据库</h2><p id="ce7d" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我一直讨厌通过web控制台设置资源，但这是必要的。跟我来，跳到你的AWS账户，选择<a class="ae ka" href="https://aws.amazon.com/rds/" rel="noopener ugc nofollow" target="_blank"> RDS </a>。你会看到一个和这个类似的页面。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/0b2a5543c723e2ea14acc12b19e4cec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_4SgmeI2wmLPXlay.png"/></div></div></figure><p id="6f54" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">单击橙色的Create Database按钮，然后继续操作。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/13d3f80675bd67fd50a1776d99f12257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*raOsPr5NjP3MFn23.png"/></div></div></figure><p id="ed9a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，您将选择想要使用的引擎。选择亚马逊极光，点击下一步。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/9800eb219c43d69e6fa130ea91eadcee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BeL5Pgjbu-tp0Lol.png"/></div></div></figure><p id="630f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">指定引擎后，将Aurora配置为<strong class="je hv">无服务器</strong>，为集群添加一个名称，并配置主用户名和密码。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/a83c899d409ead63a377aa0287e77728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ms1AAfAb3sNVNGB7.png"/></div></div></figure><p id="296f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">只需再配置一组高级设置，您就应该设置好了。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/e03baccbe4f2d5180a07c8c470dcb30a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H6b8pwQyGPy6Byxo.png"/></div></div></figure><p id="4664" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，您将设置容量和网络。因为Aurora Serverless位于VPC内，所以您必须配置访问权限。在这里，您选择默认的VPC。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/b463f5ef081af6e1713e8252dabd5c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XoDy4trZ4COw-_UV.png"/></div></div></figure><p id="6974" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了额外的配置，你就可以随心所欲地设置你的备份了。一旦你对这一切感到满意，按下橙色的<strong class="je hv">创建数据库</strong>按钮。</p><p id="01ce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，它将开始调配群集。您将被重定向并看到如下所示的输出。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/f3eede75dec921888e7750f58e22ca9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZvBDGURZUzdFW9Ou.png"/></div></div></figure><p id="e93a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，我们感兴趣的是细节部分。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/979339807c3531eb996866a1ba96d0c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b8L-z6Sig49L26La.png"/></div></div></figure><p id="beaf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，您可以访问安全组和子网。您需要将它们添加到<a class="ae ka" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>函数中，以便它们能够与数据库通信。下一节将详细介绍这一点。</p><p id="0276" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="mj">注</em> </strong> <em class="mj">:如果你想访问AWS Aurora无服务器集群请跟随</em> <a class="ae ka" href="https://www.jeremydaly.com/aurora-serverless-the-good-the-bad-and-the-scalable/" rel="noopener ugc nofollow" target="_blank"> <em class="mj">本教程</em> </a> <em class="mj">学习如何使用CLI，或者</em> <a class="ae ka" href="https://aws.amazon.com/getting-started/tutorials/configure-connect-serverless-mysql-database-aurora/" rel="noopener ugc nofollow" target="_blank"> <em class="mj">本官方教程通过AWS </em> </a> <em class="mj">连接</em><a class="ae ka" href="https://aws.amazon.com/cloud9/" rel="noopener ugc nofollow" target="_blank"><em class="mj">cloud 9</em></a><em class="mj">。您需要连接到集群并手动创建一个数据库，因为Sequelize不能为您创建它们。</em></p><p id="0834" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Statsbot的工程师向我展示了AWS RDS在处理大量数据时有多棒。传言称他们正在创建一个完全无服务器的开源分析框架，名为Cube.js。我渴望自己开始使用它。希望Aurora Serverless能有所帮助。</p><h1 id="bc1d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">编写代码</h1><p id="4012" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在AWS上配置数据库资源总是很困难，尤其是新的无服务器数据库产品。幸运的是，配置部分已经结束了。现在我们需要在<strong class="je hv"> serverless.yml </strong>文件中为我们的无服务器资源编写配置，并将实际的CRUD方法添加到<strong class="je hv"> handler.js </strong>。</p><h2 id="1330" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">4.配置YAML</h2><p id="8f1e" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">无服务器框架对建立初始项目结构有很大帮助。当你开始工作时，它可以提供你需要的几乎所有东西。跳回到创建无服务器项目的目录，并在您喜欢的代码编辑器中打开它。</p><p id="f59b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">先打开<strong class="je hv"> serverless.yml </strong>文件，喘口气。在这里，您将看到一堆带有示例配置的注释。我喜欢干净的代码，所以让我们把它全部删除，然后贴上这段代码。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="3d9d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们一点一点地分解它。<code class="eh mf mg mh lx b">provider</code>部分包含关于云提供商的所有基本信息。还包括关于运行时、函数超时、环境变量和VPC配置的数据。这里需要VPC设置，因为AWS Aurora Serverless只能在VPC后面运行，所以您需要将您的<a class="ae ka" href="https://docs.aws.amazon.com/lambda/latest/dg/vpc.html" rel="noopener ugc nofollow" target="_blank"> AWS Lambda函数放在同一个VPC </a>中，以便访问数据库。</p><p id="f263" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">继续，在顶部有一个<code class="eh mf mg mh lx b">custom</code>部分，我们在这里加载环境变量，然后将它们传递给<code class="eh mf mg mh lx b">environment</code>部分。</p><p id="f657" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后说一下<strong class="je hv">功能</strong>部分。我们一共增加了6个函数:<strong class="je hv"> healthCheck </strong>，<strong class="je hv"> create </strong>，<strong class="je hv"> getOne </strong>，<strong class="je hv"> getAll </strong>，<strong class="je hv"> update </strong>，以及<strong class="je hv"> destroy </strong>。它们都指向<strong class="je hv"> handler.js </strong>文件中同名的导出函数。他们的事件触发器被挂接到HTTP事件，这些事件由<a class="ae ka" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> AWS API网关</a>处理。也就是说，对指定路径的HTTP请求将触发被引用的函数。</p><p id="301a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">差不多就这些了，最后就是增加一个插件部分和<strong class="je hv"> serverless-offline </strong>。我们在上面安装了这个模块，在部署到AWS之前，我们将用它来测试服务。</p><h2 id="5aec" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">5.添加秘密</h2><p id="a4a2" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">你在<strong class="je hv"> serverless.yml </strong>中看到我们引用了一个秘密文件。在继续之前，我们需要创建它，并确保它正确地加载了我们的秘密。</p><p id="c4bb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在项目的根目录下创建一个<code class="eh mf mg mh lx b">secrets.json</code>并将这个片段粘贴进去。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="34f8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种设置非常适合本地开发环境。一旦你想把它部署到AWS上，你就必须添加你自己的秘密。AWS Aurora Serverless将输出如上图所示的所有内容。这里重要的秘密是数据库连接参数、安全组ID和子网ID。</p><p id="6e6d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是关于YAML的一切。接下来我们来玩玩<strong class="je hv"> handler.js </strong>吧。最后，一些真正的代码！</p><h2 id="f6f0" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">6.充实功能</h2><p id="9eb1" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">首先，我们将定义6个函数。它们将描述我们想要的初始布局和行为。一旦完成，我们将使用Sequelize移动并创建数据库连接和数据库交互逻辑。</p><p id="183f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">切换到<strong class="je hv"> handler.js </strong>文件。您将看到默认的样板文件。你猜怎么着？全部删除，添加下面的代码。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="e6a3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我可以理解你认为这是一个巨大的片段。别担心。这些只是6个基本的<code class="eh mf mg mh lx b">async</code>功能。<code class="eh mf mg mh lx b">connectToDatabase()</code>函数解析为包含所有数据库模型的对象。在本教程中，我们将只实现<code class="eh mf mg mh lx b">Note</code>模型。该函数背后的逻辑将连接到SQL数据库，缓存该连接，并确保在现有连接处于活动状态时不再重试连接。</p><p id="46c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是等等，我们还没有定义或创建这些。嗯，我是故意这样做的，我首先想让你看到这并不复杂，与用Node.js和Express创建API也没有什么不同。</p><h2 id="190c" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">7.添加数据库连接</h2><p id="e32f" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">添加数据库连接是我们的下一步。当AWS Lambda函数第一次被调用时，这被称为冷启动，AWS将启动一个容器来运行代码。这是我们连接到数据库的时候。所有后续请求都将使用现有的数据库连接。从概念上讲，这很容易理解，但是当我们需要在代码中理解它的时候就很难了。这里什么都没有！</p><p id="c5a5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在服务的根目录下创建一个新文件，就在<strong class="je hv"> handler.js </strong>旁边。给它起一个很有逻辑的名字<strong class="je hv"> db.js </strong>，并添加下面的代码。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="0aae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在顶部，我们需要<code class="eh mf mg mh lx b">Sequelize</code>和<code class="eh mf mg mh lx b">NoteModel</code>。</p><p id="038e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="mj">注</em> </strong> <em class="mj">:我们还没有创建模型，但是等一下，我们会在这一部分之后马上开始。</em></p><p id="9192" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后我们初始化<code class="eh mf mg mh lx b">sequelize</code>，传入连接变量并建立连接。调用<code class="eh mf mg mh lx b">NoteModel</code>将初始化模型，然后我们将它传递给一个<code class="eh mf mg mh lx b">Models</code>常量。任意的<code class="eh mf mg mh lx b">connections</code>对象只是用作连接的<em class="mj">缓存</em>。如果没有必要，确保不要同步数据库。使用<code class="eh mf mg mh lx b">.sync()</code>和<code class="eh mf mg mh lx b">.authenticate()</code>方法的第二个原因是确保在处理任何业务逻辑之前，在初始函数调用期间建立数据库连接。</p><p id="fca3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着<strong class="je hv"> db.js </strong>文件的创建，让我们在<strong class="je hv"> handler.js </strong>中要求它。只需将这段代码添加到处理程序的顶部。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><h2 id="d69c" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">8.添加注释模型</h2><p id="885a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">跳回<strong class="je hv"> handler.js </strong>。您可以看到我们在函数中调用了<code class="eh mf mg mh lx b">const { Note } = await connectToDatabase()</code>来检索数据，但是没有定义注释模型。好吧，现在正是时候。</p><p id="6d79" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在服务根目录中创建一个新文件夹，并将其命名为<strong class="je hv"> models </strong>。在其中创建另一个文件并将其命名为<strong class="je hv"> Note.js </strong>。这将只是一个简单的模型定义。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="21ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就是这样。是时候尝试一下了。</p><p id="989d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="mj">注意</em> </strong> <em class="mj">:务必将您的</em> <code class="eh mf mg mh lx b"><em class="mj">secrets.json</em></code> <em class="mj">添加到您的</em> <code class="eh mf mg mh lx b"><em class="mj">.gitignore</em></code> <em class="mj">文件中。</em></p><h1 id="f179" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">做些测试怎么样？</h1><p id="bcba" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们准备好测试API了。为了确保安全，让我们从本地运行开始。需要考虑的一件小事是，在运行<code class="eh mf mg mh lx b">serverless-offline</code>时，我们需要添加一个标志。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="652f" class="le kc hu lx b fv mb mc l md me">$ sls offline start --skipCacheInvalidation</span></pre><p id="5f62" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="mj">注意:</em> </strong> <em class="mj">无服务器离线使节点在每次运行时都需要缓存失效默认情况下，我们添加这个标志来禁用它。在Node.js中当你</em> <code class="eh mf mg mh lx b"><em class="mj">require()</em></code> <em class="mj">一个模块时，它存储了该模块的一个缓存版本，这样以后所有对</em> <code class="eh mf mg mh lx b"><em class="mj">require()</em></code> <em class="mj">的调用都不必从文件系统中重新加载该模块。</em></p><p id="bb31" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦您在终端中运行了该命令，您应该会看到类似这样的内容。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/e38c26eda1c581d6044d10f38b63bbc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/0*WD-pG5pFDtFbGho7.png"/></div></figure><p id="ec10" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们所有的路线都正常运行。使用<a class="ae ka" href="https://insomnia.rest/" rel="noopener ugc nofollow" target="_blank">失眠症</a>，我用JSON主体创建了一个POST请求给<code class="eh mf mg mh lx b">http://localhost:3000/notes</code>。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mn"><img src="../Images/84b3ff34a958b69eabee0b6941e808e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BtUAlsYXahjd_KC2YIt_-g.png"/></div></div></figure><p id="3a7e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">检查终端，您可以看到<code class="eh mf mg mh lx b">=&gt; using new database connection</code>被记录，这意味着初始数据库连接已经建立。发送另一个POST请求，你会看到<code class="eh mf mg mh lx b">=&gt; using existing database connection</code>被记录。</p><p id="6dca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">太棒了，添加一个新笔记很有效。让我们使用<strong class="je hv"> getAll </strong>方法检索我们刚刚添加的所有注释。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/4ebe59244966daafe2f6351e30ea21e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MGjV8-PofP_JzEVeQoVBgQ.png"/></div></div></figure><p id="7896" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">自己尝试其他端点。你玩完了就回来。</p><h1 id="dec2" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">部署到AWS</h1><p id="b4e2" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">现在到了棘手的部分。确保记下您将在AWS Aurora无服务器控制台中获得的所有数据库参数，当然还有安全组ID和子网ID。通常，您有一个安全组和三个子网。但是，它可能会有所不同，所以不要担心。获得值后，将它们添加到您的<code class="eh mf mg mh lx b">secrets.json</code>中。就是这样！你已经准备好部署了。</p><p id="2d13" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">无服务器框架使部署变得快速而轻松。你需要做的就是运行一个命令。</p><p id="9ca7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它将自动在AWS上提供资源，打包并将所有代码推送到S3，然后从那里发送到Lambdas。终端应该显示类似如下的输出。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mp"><img src="../Images/42fa1e58cb2e35fd340a1846d2ae3fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IvmyHIMJvH_Nj6ZC.png"/></div></div></figure><p id="4485" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="mj">注</em> </strong> <em class="mj">:您可以使用提供的端点从上面重复测试过程。但是，对冷启动时间要有耐心。AWS Aurora无服务器大约需要10秒钟才能启动。类似的问题也出现在VPC的AWS Lambda上。</em></p><p id="58b9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是部署流程的全部内容。简单对吗？这就是我如此热爱无服务器框架的原因。</p><h1 id="7db7" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">包扎</h1><p id="5069" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这是一个不断发展的架构。随着无服务器关系数据库的兴起，创建完全无服务器基础设施的可能性是无限的。我已经尽力解释了创建一个合适的API的过程。希望你已经学到了很多。享受深入挖掘无服务器架构的可能性以及随之而来的一切吧！</p><p id="fe33" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，<a class="ae ka" href="https://github.com/adnanrahic/building-a-serverless-api-with-nodejs-and-aws-aurora-serverless" rel="noopener ugc nofollow" target="_blank">这里是回购</a>再次，如果你想让更多人在GitHub上看到它，给它一颗星。如果你想阅读我以前的一些无服务器思考，请前往<a class="ae ka" href="https://dev.to/adnanrahic" rel="noopener ugc nofollow" target="_blank">我的简介</a>或<a class="ae ka" href="https://upscri.be/b6f3d5/" rel="noopener ugc nofollow" target="_blank">加入我的无服务器时事通讯！</a></p><p id="2ac6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mj">我用AWS极光无服务器玩了个绝对。希望你们喜欢读它，就像我喜欢写它一样。如果你喜欢它，拍一下那个小独角兽，这样dev.to上会有更多的人看到这篇文章。如果你需要一个</em> <a class="ae ka" href="https://statsbot.co/" rel="noopener ugc nofollow" target="_blank"> <em class="mj">无服务器的SQL分析框架</em> </a> <em class="mj">，别忘了给Cube.js的读者一些爱！下次见，保持好奇，玩得开心。</em></p></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><p id="bde3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mj">原载于</em><a class="ae ka" href="https://dev.to/adnanrahic/a-crash-course-on-serverless-with-aws---building-apis-with-lambda-and-aurora-serverless-3fn3" rel="noopener ugc nofollow" target="_blank"><em class="mj">dev .</em></a><em class="mj">。</em></p></div></div>    
</body>
</html>