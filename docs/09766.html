<html>
<head>
<title>How to create a financial marketplace for 500,000 people 💸. Part II (technical)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为50万人创建一个金融市场💸。第二部分(技术)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-create-a-financial-marketplace-for-500-000-people-part-ii-technical-4d2456d9768d?source=collection_archive---------28-----------------------#2018-12-03">https://medium.com/hackernoon/how-to-create-a-financial-marketplace-for-500-000-people-part-ii-technical-4d2456d9768d?source=collection_archive---------28-----------------------#2018-12-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0dddac48f1e9586d6644c2e2723bdad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SsA4V5vZSWabatuT_gnxmg.png"/></div></div></figure><p id="ee00" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本文分为两部分:</p><ul class=""><li id="33ce" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated"><a class="ae kj" rel="noopener" href="/@amozgovoy/how-to-create-a-financial-marketplace-for-500-000-people-part-i-non-technical-78ab893b1a65">第一部分:非技术性</a></li><li id="2ec7" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">第二部分:技术</li></ul><p id="2802" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你对生态系统背后的决策和想法感兴趣，请查看本文第一部分<a class="ae kj" rel="noopener" href="/@amozgovoy/how-to-create-a-financial-marketplace-for-500-000-people-part-i-non-technical-78ab893b1a65">。同时，故事继续定义核心架构。</a></p><p id="684e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现代金融科技银行是一个拥有银行牌照、核心平台、KYC、CRM、API和一些核心产品的市场。金融科技银行直接提供的产品可能仅限于资金持有、银行账户、卡和支付钱包。</p><p id="21a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，我们的任务并不典型。起初，我们的主要目标是设计和构建一个能够横向扩展的金融平台，能够与多个外部服务提供商集成，拥有一个开放的API系统，并且足够模块化，能够扩展到多个产品线和功能。</p><p id="b013" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是为什么从平台的基本原则开始非常重要。</p><h1 id="7199" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">标准API定义</h1><p id="5eec" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">我们需要能够拥有一个可以在所有渠道中使用的单一规范API定义，或者允许我们至少验证客户端的正确性。</p><p id="beea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有必要标准化<a class="ae kj" href="http://www.grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>来定义服务API，标准化“逻辑”数据中心内部的gRPC，然后使用<a class="ae kj" href="https://github.com/grpc-ecosystem/Grpc-gateway" rel="noopener ugc nofollow" target="_blank"> grpc-gateway </a>来创建客户端可以调用的REST适配器。适配器的这个组件将涵盖所有客户端功能。</p><h1 id="3b27" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">横向可扩展，运营成本最低</h1><p id="d2f7" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">我们不希望在过度开发的系统上花费额外的资金来应对负载，我们也不希望额外的容量成为负担。一切都应该水平缩放。</p><p id="87c2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，我们希望将所有内容都转换成Kubernetes，并将所有服务容器化，这将使我们能够应对负载，提高效率。</p><p id="eccc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们仍然需要将Bigtable标准化为我们的永久存储，因为它的性能成本很高。</p><h1 id="a4ea" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">记录</h1><p id="b990" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">所有代码都必须有标准的日志记录方式和日志搜索支持。这是至关重要的。</p><p id="a195" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有的日志行都被转换成JSON格式的标准输出，然后使用EFK堆栈(<a class="ae kj" href="https://www.notion.so/humaniq/Backend-Infrastructure-overview-rus-22c9eb00448c4bbeaa143e7c4ed5f49d#932524524fab44bb9ce4a0ffacc8cabb" rel="noopener ugc nofollow" target="_blank">elastic search</a>+<a class="ae kj" href="http://www.fluentd.org/" rel="noopener ugc nofollow" target="_blank">fluent d</a>+<a class="ae kj" href="https://www.elastic.co/products/kibana" rel="noopener ugc nofollow" target="_blank">Kibana</a>)进行连接。</p><h1 id="536d" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">韵律学</h1><p id="cd8e" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">我们需要一种单一的标准方式来呈现指示板的指示器和警告。</p><p id="4a98" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我们已经标准化了Go for development，所以使用<a class="ae kj" href="https://golang.org/pkg/expvar/" rel="noopener ugc nofollow" target="_blank"> expvars </a>公开任何度量是有意义的，然后可以清除<a class="ae kj" href="https: //www.datadoghq .com /" rel="noopener ugc nofollow" target="_blank"> Datadog </a>或<a class="ae kj" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>。额外的好处是，因为我们标准化了gRPC，所以很容易确保所有gRPC服务都设置了一组标准的度量标准，比如对RPC端点的响应时间的百分比。</p><p id="3698" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">开发人员也可以使用相同的方法轻松地识别附加的、特定于服务的指示器。</p><h1 id="3ade" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">API网关</h1><p id="478d" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">网关应用应该是唯一向公众公开的服务。它应该执行以下标准:</p><ul class=""><li id="010f" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">网关应该能够水平扩展。因此，不应该存在任何应用程序状态；</li><li id="d2a0" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">网关必须能够异步组合请求和调用微服务；</li><li id="53ca" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">网关必须能够限制一段时间内的请求数量；</li><li id="80d6" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">网关必须能够验证认证令牌的真实性。<em class="ls">传统上，建议API网关执行认证，底层微服务执行对其资源的授权，但我们将采用何种认证方法有待讨论；</em></li><li id="2e1d" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">网关必须能够自动从微服务导入可用资源。首先，我们将选择Swagger格式，这是当今世界上最流行的格式；</li><li id="8ff4" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">网关必须能够改变(改变)微服务的回复；</li><li id="77b7" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">网关必须能够与gRPC适配器(grpc-gateway)的REST对话</li><li id="76fb" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">最后:网关应该完美地直接从Docker镜像运行，并通过环境变量进行配置。我们不需要任何额外的存储库、删除脚本等等。</li></ul><h1 id="58f1" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">GCP堆栈</h1><p id="e34f" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">在选择我们的云服务提供商时，我们决定使用谷歌云平台。我们受到三个主要因素的驱动:隔离、性能和成本，以及开箱即用的Kubernetes。</p><h2 id="aa77" class="lt kq hu bd kr lu lv lw kv lx ly lz kz jn ma mb ld jr mc md lh jv me mf ll mg dt translated"><em class="mh">隔离</em></h2><p id="ab74" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">我们知道我们想尝试更先进的地理商店和其他技术，并认为我们肯定会在早期遇到困难。在这种情况下，确保不影响其他服务的最好方法是创建一个新的、完全独立的服务。</p><h2 id="3c62" class="lt kq hu bd kr lu lv lw kv lx ly lz kz jn ma mb ld jr mc md lh jv me mf ll mg dt translated"><em class="mh">性能&amp;成本</em></h2><p id="5c36" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">有一个存储和提供大量地理标记和聚合数据的计划，我们需要一个低成本、持久的存储，它非常适合这个用例。这就是Google Bigtable真正闪光的地方，它让迁移对我们更有吸引力。例如，您可以支持默认的3节点集群，该集群支持大约30，000个QPS，每月价格约为1，500美元，包括存储。由于容量是在集群级别而不是在表级别调配的，因此您不必担心过度调配特定于用例的表而浪费资金。</p><h2 id="e739" class="lt kq hu bd kr lu lv lw kv lx ly lz kz jn ma mb ld jr mc md lh jv me mf ll mg dt translated">库伯内特斯</h2><p id="7b89" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">这个很简单。在写这篇文章的时候，AWS已经提供了“开箱即用”的Kubernetes服务，所以这个要点相对没用。然而，在设计平台的时候，这是决策制定的关键原因之一。</p><p id="3e87" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是GCP堆栈的高级概述。所有与区块链相关的数据都被排除在范围之外，也不在这里讨论。而以集中方式存储的所有数据都属于当前堆栈。</p><figure class="mj mk ml mm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/7fc18f289a1cedd65b7f52b9295367be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*irp0Oq3nngkb5cYsG0ui4g.png"/></div></div></figure><h1 id="7196" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">整体还是微服务？</h1><p id="deab" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">在这种特定情况下，最有效的方法是使用微服务。这个决定是基于创建一组核心服务和控制依赖指数的尝试。</p><figure class="mj mk ml mm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mn"><img src="../Images/d35c39dce99debe88a58d268c39cd79f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*61qqtxC1TVojW1KUMx2A2w.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">Number of services running on the platform (besides network layers)</figcaption></figure><p id="9e9f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关于微服务的简要说明。微服务是独立构建的系统，每个都在自己的进程中运行，经常与REST API通信。它们代表应用程序的不同部分，可以单独部署，每个部分都可以用任何语言编写。</p><p id="adcf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过处理单块系统的问题，你可以很容易地看到微服务是如何成为任何先进软件的需求的。</p><p id="e497" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想更深入地了解这种架构风格中的关键概念，我强烈推荐你阅读《T2》微服务(詹姆斯·刘易斯)和《单片微服务》的<a class="ae kj" href="https://dev.otto.de/2015/09/30/on-monoliths-and-microservices/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="6aee" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">库伯内特斯</h1><p id="8e76" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">Kubernetes的设计初衷是成为使用容器构建、管理和编排分布式应用程序的理想平台。它包括用于复制和服务发现的原语，作为其核心的一部分(这些是通过Mesos中的框架添加的，需要一些知识来正确配置)，Kubernetes的愿景是开发一个系统，允许企业以最高的效率、安全性和易用性管理可扩展的应用程序部署。</p><p id="5dcd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就个人而言，我喜欢将Kubernetes描述为“一种特殊的云操作系统”——这是一种允许开发人员将任意数量的机器视为一台非常强大的机器的操作系统。在我看来，K8s对于云就像Linux或者Windows对于电脑一样。</p><p id="9daf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就像操作系统为开发人员提供了一个来自组成计算机的硬件的抽象层一样，K8s为开发人员提供了一个来自组成云的计算机的抽象层。</p><p id="41a3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你对这种比较想得越多，你就会发现更多的相似之处。例如，操作系统的主要目的之一是调度进程，以便它们可以在单台机器上高效地共享硬件资源——类似地，K8s的主要目的之一是调度容器，以便它们可以在云(可能由多台机器组成)上高效地共享计算资源。</p><p id="4f1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦你认为K8s是一个“云操作系统”,商业机会就开始实现了。我们不再只是谈论一个提高部署效率的系统，而是谈论一个用于构建云原生应用的全新平台。</p><h1 id="d300" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">混合平台</h1><h2 id="2382" class="lt kq hu bd kr lu lv lw kv lx ly lz kz jn ma mb ld jr mc md lh jv me mf ll mg dt translated">它是如何工作的？</h2><p id="96a5" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">混合系统中有三层区块链:以太坊主网、主内部区块链和特定国家的区块链。每个内部区块链都是以太坊协议的修改版，交易费用和排放为零。在它们里面有一个代币，作为主要的货币，就像以太网一样。</p><p id="2ca6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，在内部区块链上没有发生发射，因为这些都是从“主钱包”中已经存在的最大可用令牌供应开始的。当令牌离开网络时，它们被发送到第二个“清算钱包”，实际上是“烧掉”或删除它们。</p><p id="ed70" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">系统必须处理三种关键情况:当用户创建帐户时；当令牌从生态系统发送到外部世界时；最后，当令牌从外部世界发送到混合生态系统时。</p><h2 id="aafc" class="lt kq hu bd kr lu lv lw kv lx ly lz kz jn ma mb ld jr mc md lh jv me mf ll mg dt translated">创建用户帐户</h2><figure class="mj mk ml mm fq iv fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/206785be74222ac87ed50009512159b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*UyjiOep9WgTPNKIqXF22uw.png"/></div></figure><p id="d423" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当用户注册一个新账户时，服务负责通过区块链API创建两个相同的钱包，重复使用相同的私钥。这样，一个用户在ETH Mainnet和私有链上都有完全相同的地址。这些信息随后被返回给Tapatybe服务(负责保存用户身份)并与账户绑定。</p><p id="e3b8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为响应，TokenRef服务被调用，它在ETH Mainnet wallet(通过调用合同并铸造令牌)和私有链上执行所需的发射:此时，令牌从主/清算wallet传输到用户的内部wallet。</p><h2 id="cb15" class="lt kq hu bd kr lu lv lw kv lx ly lz kz jn ma mb ld jr mc md lh jv me mf ll mg dt translated"><strong class="ak">从内部到外部的交易</strong></h2><figure class="mj mk ml mm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mt"><img src="../Images/4a5bbf067a60b6393a1de0e78b147f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*dF1ncdC0-pEP9StHiZxFOg.png"/></div></div></figure><p id="4f21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当用户发起交易时，有两种可能的情况:要么钱包属于网络，要么它属于以太网。</p><p id="be27" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当事务开始时，调用一个服务来确定目的地址是否存在于数据库中。如果有，它只是将交易代理给内部链的区块链API。如果地址确实是外部的，那么事务被添加到一个队列中，由第二个服务拾取。</p><p id="275d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，该服务将事务代理到ETH Mainnet，这是从中转地址广播的。一旦完成，它就会调用区块链API来创建一个交易，该交易会在用户的内部余额上“刻录”令牌，并将它们发送到清算钱包。</p><h2 id="6abb" class="lt kq hu bd kr lu lv lw kv lx ly lz kz jn ma mb ld jr mc md lh jv me mf ll mg dt translated"><strong class="ak">从外部到内部的交易</strong></h2><figure class="mj mk ml mm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mu"><img src="../Images/9d12cc7210d15ca295097c0f59ddc7a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BUxSORIQTyNnVyBgcMLpng.png"/></div></div></figure><p id="b93e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">鉴于外部交易可能随时到来，区块链服务必须“监听”所有钱包的传入交易。每当检测到新的交易时，第二个服务启动从用户的mainnet地址到Transit Wallet的资金转移，将交易分组以尽可能降低成本。</p><p id="2248" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后调用第三个服务，该服务命令内部区块链API将令牌从主钱包分发到用户的内部余额。</p><h2 id="de02" class="lt kq hu bd kr lu lv lw kv lx ly lz kz jn ma mb ld jr mc md lh jv me mf ll mg dt translated"><strong class="ak">混合系统如何实现可扩展性？</strong></h2><p id="c1df" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">私有区块链是并行工作的，这意味着我们可以根据需要添加任意多的它们来增加以太坊的TPS。当然，区块链间业务的存在意味着一些效率损失，但这只是整个交易池的一小部分。</p><h1 id="a271" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">在应用程序中共享联系人</h1><p id="c298" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">如果服务使用的标识符已经列在典型的联系人卡片中(电话号码或电子邮件)，则很容易快速显示用户的哪些联系人也注册了该服务，并立即向该用户提供社交功能。这意味着，如果朋友们已经把对方作为联系人，他们就不必在服务上“发现”对方。</p><p id="83ea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">问题是，计算注册用户和设备联系人交集的最简单方法是将地址簿中的所有联系人上传到服务，对它们进行索引，反向索引，将交集发送给客户端，并在这些联系人中的任何一个后来注册时通知客户端。</p><h1 id="335c" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">布隆过滤器和加密的布隆过滤器</h1><p id="9a7f" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">有一整个研究领域致力于解决类似这样的问题，被称为“私人信息检索”(PIR)。最简单的PIR形式是服务器向客户端发送注册用户的完整列表，然后客户端可以在本地查询。基本上，如果客户机拥有整个数据库的副本，它就不会将其数据库查询泄露给服务器。</p><p id="9708" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以通过在bloom过滤器中传输注册用户的列表来提高网络效率，bloom过滤器的误报率较低。为了避免泄露所有注册用户的列表，甚至可以通过以下方式使用“加密布隆过滤器”构建一个“对称PIR”系统:</p><ol class=""><li id="92ba" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz mv kg kh ki dt translated">服务器生成一个保密的RSA密钥对。</li><li id="bf26" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz mv kg kh ki dt translated">服务器不是将每个用户放入<a class="ae kj" href="https://en.wikipedia.org/wiki/Bloom_filter" rel="noopener ugc nofollow" target="_blank">布隆过滤器</a>，而是将每个用户的RSA签名放入布隆过滤器。</li><li id="82c9" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz mv kg kh ki dt translated">客户端请求bloom filter，它包含每个注册用户的RSA签名。</li><li id="6e0c" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz mv kg kh ki dt translated">当客户端希望查询本地bloom过滤器时，它根据David Chaum的<a class="ae kj" href="https://en.wikipedia.org/wiki/Blind_signature" rel="noopener ugc nofollow" target="_blank">盲签名方案</a>构建一个“盲”查询。</li><li id="242b" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz mv kg kh ki dt translated">客户端将隐蔽的查询发送到服务器。</li><li id="dcaa" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz mv kg kh ki dt translated">服务器对隐蔽查询进行签名，并将其发送回客户端。</li><li id="a2e3" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz mv kg kh ki dt translated">客户端<a class="ae kj" href="https://en.wikipedia.org/wiki/Blind_signature" rel="noopener ugc nofollow" target="_blank">解开查询</a>以揭示它希望查询的联系人的服务器RSA签名。</li><li id="7fb6" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz mv kg kh ki dt translated">然后，客户端检查其本地布隆过滤器中的该值。</li></ol><p id="a437" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">也可以压缩布隆过滤器的“更新”。服务器只需要计算客户端拥有的版本和更新版本的异或，然后通过<a class="ae kj" href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm" rel="noopener ugc nofollow" target="_blank"> LZMA </a>运行(输入将大部分为零)，并将压缩的diff传输到客户端。</p><h1 id="d970" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">面部识别系统</h1><p id="5e00" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">面部识别在平台的两个地方使用:</p><ul class=""><li id="4c21" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">在注册和认证期间</li><li id="eb3b" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">在钱包中执行交易时的附加验证期间</li></ul><h2 id="ebd0" class="lt kq hu bd kr lu lv lw kv lx ly lz kz jn ma mb ld jr mc md lh jv me mf ll mg dt translated">服务认证</h2><p id="a7e8" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">所有API方法都需要简单的基于令牌的HTTP认证。为了进行身份验证，您应该将world“Token”和一个密钥放入Authorization HTTP头中，用空格隔开:</p><p id="4f3c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mw mx my mz b">Authorization: Token yfT8ftheVqnDLS3Q0yCiTH3E8YY_cm4p</code></p><h2 id="3405" class="lt kq hu bd kr lu lv lw kv lx ly lz kz jn ma mb ld jr mc md lh jv me mf ll mg dt translated">常见对象类型</h2><p id="41a7" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated"><strong class="je hv">人脸<br/>T13】代表一张人脸。请注意，一张照片上可能有几个人。同一个人的不同照片也被认为是不同的面孔。</strong></p><ul class=""><li id="4b14" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated"><code class="eh mw mx my mz b">"id" (number)</code>:服务生成的人脸的唯一标识符。</li><li id="5878" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated"><code class="eh mw mx my mz b">"timestamp" (string)</code>:脸对象创建时间为ISO8601字符串。</li><li id="b259" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated"><code class="eh mw mx my mz b">"photo_hash" (string)</code>:原照片的哈希。请注意，相同的照片将始终具有相同的哈希，而不同的照片肯定会具有不同的哈希。不要解释这个值，也不要对用于哈希计算的特定哈希函数做出假设。</li><li id="fc03" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated"><code class="eh mw mx my mz b">"x1" (number)</code>:原始照片上人脸边框左上角的x坐标。</li><li id="24d4" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated"><code class="eh mw mx my mz b">"y1" (number)</code>:原始照片上人脸边框左上角的y坐标。</li><li id="749b" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated"><code class="eh mw mx my mz b">"x2" (number)</code>:原始照片上人脸边框右下角的x坐标。</li><li id="be51" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated"><code class="eh mw mx my mz b">"y2" (number)</code>:原始照片上人脸边框右下角的y坐标。</li><li id="7aa3" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated"><code class="eh mw mx my mz b">"meta" (string)</code>:元数据字符串，可以用来存储与人脸相关的任何信息。</li><li id="b622" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated"><code class="eh mw mx my mz b">"galleries" (string[])</code>:有这个面的图库名数组。</li><li id="285f" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated"><code class="eh mw mx my mz b">"photo" (string)</code>:用于创建面部对象的照片的文件名的URL。</li><li id="8125" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated"><code class="eh mw mx my mz b">"thumbnail" (string)</code>:存储在服务缓存中的脸部缩略图的URL。</li></ul><h2 id="7bcd" class="lt kq hu bd kr lu lv lw kv lx ly lz kz jn ma mb ld jr mc md lh jv me mf ll mg dt translated">方法</h2><p id="2961" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated"><strong class="je hv">创建人脸<br/> </strong>处理上传的图像或提供的URL，检测人脸并将检测到的人脸添加到可搜索的数据集中。如果照片上有多个面孔，默认情况下只会添加最大的面孔。</p><p id="8b15" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者，您可以添加一个自定义的字符串元，例如名称或ID，它唯一地标识一个人。多个面对象可能具有相同的元。我们建议您不要将相同的元分配给不同的人。因此，当使用人名作为元时，要确保所有的名字都是唯一的。</p><p id="f200" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此方法的示例响应代码如下所示:</p><pre class="mj mk ml mm fq na mz nb nc aw nd dt"><span id="432f" class="lt kq hu mz b fv ne nf l ng nh">{<br/>  "results": [<br/>    {<br/>      "age": 40,<br/>      "emotions": [<br/>        "neutral",<br/>        "surprised"<br/>      ],<br/>      "galleries": [<br/>        "default",<br/>        "ppl"<br/>      ],<br/>      "gender": "male",<br/>      "id": 2333,<br/>      "meta": "Sam Berry",<br/>      "photo_hash": "dc7ac54590729669ca869a18d92cd05e",<br/>      "timestamp": "2016-06-13T11:06:42.075754",<br/>      "x1": 225,<br/>      "x2": 307,<br/>      "y1": 345,<br/>      "y2": 428<br/>    }<br/>  ]<br/>}</span></pre><p id="666a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">检测人脸<br/> </strong>该方法在提供的图像上检测人脸。您可以将图像文件作为多部分/表单数据上传，或者提供一个URL，API将使用它来获取图像。</p><p id="1d01" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此方法的示例响应代码如下所示:</p><pre class="mj mk ml mm fq na mz nb nc aw nd dt"><span id="48d7" class="lt kq hu mz b fv ne nf l ng nh">{<br/>  "faces": [<br/>    {<br/>      "age": 36,<br/>      "emotions": [<br/>        "neutral",<br/>        "happy"<br/>      ],<br/>      "gender": "female",<br/>      "x1": 236,<br/>      "x2": 311,<br/>      "y1": 345,<br/>      "y2": 419<br/>    }<br/>  ],<br/>  "orientation": 1<br/>}</span></pre><p id="d421" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">验证人脸<br/> </strong>该方法验证两张人脸属于同一个人，或者测量两张人脸之间的相似度。您可以通过设置<code class="eh mw mx my mz b">threshold</code>参数在这两种模式之间进行选择。</p><p id="2224" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这种情况下，当需要二进制决策时，用户可以为<code class="eh mw mx my mz b">threshold</code>参数传递一个值。我们为<code class="eh mw mx my mz b">threshold</code> : <code class="eh mw mx my mz b">strict</code>、<code class="eh mw mx my mz b">medium</code>和<code class="eh mw mx my mz b">low</code>提供了3个预设值，前者旨在最小化错误接受率，而后者更宽松一些。客户端也可以通过固定的阈值来覆盖这些预设值。</p><p id="c7b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此方法的示例响应代码如下所示:</p><pre class="mj mk ml mm fq na mz nb nc aw nd dt"><span id="465f" class="lt kq hu mz b fv ne nf l ng nh">{<br/>  "results": [<br/>    {<br/>      "bbox1": {<br/>        "x1": 610,<br/>        "x2": 796,<br/>        "y1": 157,<br/>        "y2": 342<br/>      },<br/>      "bbox2": {<br/>        "x1": 584,<br/>        "x2": 807,<br/>        "y1": 163,<br/>        "y2": 386<br/>      },<br/>      "confidence": 0.9222600758075714,<br/>      "verified": true<br/>    }<br/>  ],<br/>  "verified": true<br/>}</span></pre><h1 id="421b" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">基础设施的当前外观</h1><p id="1876" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">自该应用推出以来，对基础设施的需求增加了<strong class="je hv">十倍</strong>，跨节点使用<strong class="je hv"> 96Gb </strong>内存，并达到每秒<strong class="je hv">数百兆字节</strong>的峰值流量。基础设施能够有效应对负载，平均SLA为<strong class="je hv">99.4%</strong>。所有构建和更新都是使用连续交付系统自动推出的，该系统允许服务的透明升级。</p><p id="312b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们目前的堆栈基于以下技术和语言:Java(native Android应用程序)+原生Android库、GoLang、Python、PostgreSQL、MySQL、RabbitMQ、Redis、MongoDb、Kubernetes、Docker、Tensorflow(用于基于AI的助手bot ML)、Google Cloud、Sentry、Grafana、各种分析SDK(Firebase和其他)、BigQuery、Apache Zeppelin、用于实时通信的MQTT协议、用于web服务的Node.js。</p><p id="9952" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">开发团队使用scrum方法，每周进行sprints，包括后端和前端开发人员，一名DevOps工程师，一名数据科学家，一名报告和事件工程师，一名区块链开发人员，QA工程师和一名管理员/scrum-master。在2018年6月之前，使用双周冲刺，随后减少以加快对不断变化的环境的响应。所有版本都包括在人工冒烟测试中，并且在需要时，包括完整的回归测试，以确保服务的正常运行。</p><figure class="mj mk ml mm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ni"><img src="../Images/ba59fd79cd1d8b4a40acd72e7432e379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TIbp_qiDPYLcxDFEIrfnPw.png"/></div></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek">This is what 500,000 users are supported by</figcaption></figure><h1 id="9db8" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">进一步发展基础设施</h1><h2 id="5223" class="lt kq hu bd kr lu lv lw kv lx ly lz kz jn ma mb ld jr mc md lh jv me mf ll mg dt translated">总体改进</h2><ul class=""><li id="e969" class="ka kb hu je b jf ln jj lo jn nj jr nk jv nl jz kf kg kh ki dt translated">聊天对象在Google存储上被移动到静态</li><li id="0f21" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">拒绝用于服务的大量数据库实例</li><li id="2702" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">自动列出保管库</li><li id="004c" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">展示所有服务的资源限制，包括基础设施</li><li id="aec5" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">头盔模板、部署脚本等的一致性。</li><li id="a024" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">面向云基础设施的Terraform</li><li id="0519" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">一个命名空间中的所有业务服务</li><li id="baa7" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">为域保留IP地址</li></ul><h2 id="c0f4" class="lt kq hu bd kr lu lv lw kv lx ly lz kz jn ma mb ld jr mc md lh jv me mf ll mg dt translated">可靠性</h2><ul class=""><li id="bb4d" class="ka kb hu je b jf ln jj lo jn nj jr nk jv nl jz kf kg kh ki dt translated">生产环境的集群版本和操作系统更新</li><li id="b10b" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">基础设施数据服务转移到云</li><li id="2334" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">向rabbitMQ、Redis和入口控制器的云解决方案过渡</li><li id="6ea0" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">服务应该能够在多个副本中工作</li><li id="0ab1" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">处理故障点</li><li id="1b90" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">为事故做准备，恢复计划</li><li id="41b7" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">压力测试</li><li id="30f1" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">包括检查包含大量信息的数据库</li><li id="ef1f" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">高可用性模式下的保险存储</li><li id="9923" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">多地区或多区域生产集群</li></ul><h2 id="6e58" class="lt kq hu bd kr lu lv lw kv lx ly lz kz jn ma mb ld jr mc md lh jv me mf ll mg dt translated">其他改进</h2><ul class=""><li id="db7b" class="ka kb hu je b jf ln jj lo jn nj jr nk jv nl jz kf kg kh ki dt translated">收集有关服务行为的指标，需要支持服务。</li><li id="52cf" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">具有业务指标和延迟、自动SLI计算的控制面板</li><li id="5a31" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">过渡到新的日志收集和汇总系统</li></ul><h2 id="d511" class="lt kq hu bd kr lu lv lw kv lx ly lz kz jn ma mb ld jr mc md lh jv me mf ll mg dt translated">持续集成部署交付</h2><ul class=""><li id="11d9" class="ka kb hu je b jf ln jj lo jn nj jr nk jv nl jz kf kg kh ki dt translated">发布和回滚的自动化</li><li id="05c8" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">过程可测量性</li><li id="3060" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">加速构建和发布</li><li id="d737" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">按需创建环境(看看GKE阿尔法集群)。</li><li id="081a" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">测试自动化</li><li id="0a6d" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">淡黄色，蓝绿色</li></ul></div></div>    
</body>
</html>