<html>
<head>
<title>RS256 in OCaml/ReasonML</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OCaml/ReasonML中的RS256</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/rs256-in-ocaml-reasonml-9ae579b9420a?source=collection_archive---------16-----------------------#2018-12-04">https://medium.com/hackernoon/rs256-in-ocaml-reasonml-9ae579b9420a?source=collection_archive---------16-----------------------#2018-12-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="2e21" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">我花了相当多的时间来弄清楚如何为一个GitHub应用程序的消息签名。这是我的发现。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/33bc7da65eb321e26587ecc7275099a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uxmsEQN95oGc1M2UQCIywA.png"/></div></div></figure><blockquote class="jv jw jx"><p id="3380" class="jy jz ka kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">TL；dr:下面是代码片段，原因是本地标签检查服务是GitHub 上的<a class="ae kv" href="https://github.com/Schniz/reason-pr-labels" rel="noopener ugc nofollow" target="_blank">开源</a></p></blockquote><p id="efae" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kw kj kk kl kx kn ko kp ky kr ks kt ku hn dt translated">就在我们发布新版本的<a class="ae kv" href="https://github.com/wix/yoshi" rel="noopener ugc nofollow" target="_blank"> Yoshi </a>、<a class="kz la gr" href="https://medium.com/u/2741d9d88322?source=post_page-----9ae579b9420a--------------------------------" rel="noopener" target="_blank"> Wix </a>的内部开发<a class="ae kv" href="https://hackernoon.com/tagged/toolchain" rel="noopener ugc nofollow" target="_blank">工具链</a>之前，我们使用精彩的<a class="ae kv" href="https://github.com/lerna/lerna-changelog" rel="noopener ugc nofollow" target="_blank"> lerna-changelog </a>生成了我们的<code class="eh lb lc ld le b">CHANGELOG.md</code>文件。lerna-changelog将显示自存储库中最近一次标记提交以来已合并的所有拉请求。然而，这只适用于应用了某些标签的拉取请求。GitHub标签在PRs和issues之间共享，但是其中只有一部分用于生成changelog。</p><p id="6272" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kw kj kk kl kx kn ko kp ky kr ks kt ku hn dt translated">为了减少混乱，我们选择在所有影响变更日志的标签前加上前缀“PR:”,这样维护人员就知道为每个PR至少选择一个。</p><p id="7ade" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kw kj kk kl kx kn ko kp ky kr ks kt ku hn dt translated">有时，我们忘记添加标签，这导致PR不在changelog中。对某些项目来说，这可能完全没问题，但我们希望尽可能透明，因此“隐藏”公关会伤害我们团队的核心价值观。</p><p id="bf78" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kw kj kk kl kx kn ko kp ky kr ks kt ku hn dt translated">我决定编写一个简单的应用程序，它将添加一个状态检查，只有当PR有一个有效的changelog标签时才通过，由GitHub的webhooks触发。我想用native Reason编写它，所以我将学习如何更好地使用原生的<a class="ae kv" href="https://hackernoon.com/tagged/ocaml" rel="noopener ugc nofollow" target="_blank"> OCaml </a>工具链。因此，我决定使用原生OCaml并生成一个静态二进制文件，而不是编译成JS并用Node.js运行它，就像大多数围绕Reason的教程所展示的那样。这将创建一个轻量级的可执行文件(11mb！)相比需要整个运行时间的标准节点应用程序，它的部署速度非常快。<a class="ae kv" href="https://github.com/schniz/reason-pr-labels" rel="noopener ugc nofollow" target="_blank">源代码在GitHub </a>上，给想加入或者只是看看的人。</p><p id="4022" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kw kj kk kl kx kn ko kp ky kr ks kt ku hn dt translated">起初，我所做的只是制作一个简单的服务器，它与GitHub webhooks一起工作，接受一个用户令牌作为查询参数，稍后我将把它传递给GitHub API中的<code class="eh lb lc ld le b">access_token</code>查询参数。虽然这样做很好，但是“不太安全”，因为所有的存储库管理员都可以访问某个用户的令牌。仅仅为了进行API调用而生成用户也不如仅仅使用GitHub应用安全。所以我决定用GitHub apps。</p><p id="beac" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kw kj kk kl kx kn ko kp ky kr ks kt ku hn dt translated">使用webhooks到GitHub应用程序的唯一区别是授权过程。应用程序正在使用<code class="eh lb lc ld le b">RS256</code>签名的JWT，正如在<a class="ae kv" href="https://developer.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app" rel="noopener ugc nofollow" target="_blank">文档</a>中提到的，为特定的安装(或回购)请求一个短期令牌。然后，剩下的都是一样的——我们得到一个令牌，就像我们从查询参数中得到的一样。</p><p id="295c" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kw kj kk kl kx kn ko kp ky kr ks kt ku hn dt translated">为了制作JWT，我尝试使用<code class="eh lb lc ld le b">ocaml-jwt</code>库，但不幸的是，它不支持RS256开箱即用，尽管有一个PR添加了支持，所以我决定从头开始:搜索一个库来签署我的请求并自己构建JWT。</p><p id="739b" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kw kj kk kl kx kn ko kp ky kr ks kt ku hn dt translated">因为我是OCaml的新手，所以我不知道什么是库，所以我只是四处搜索并寻找包。经过长时间的研究，当我看到一个名为<code class="eh lb lc ld le b">ocaml-letsencrpt</code> <a class="ae kv" href="https://github.com/mmaker/ocaml-letsencrypt/blob/de05f574c8c037b0668ce5369f26eccdf5cee756/src/primitives.ml#L16-L20" rel="noopener ugc nofollow" target="_blank">的github repo实现了我所需要的功能</a>时，我决定使用<code class="eh lb lc ld le b"><a class="ae kv" href="https://github.com/mirleft/ocaml-nocrypto" rel="noopener ugc nofollow" target="_blank">nocrypto</a></code>(以及<code class="eh lb lc ld le b"><a class="ae kv" href="https://github.com/mirleft/ocaml-x509" rel="noopener ugc nofollow" target="_blank">x509</a></code>),这个功能接受一个私钥、一个字符串并返回一个带符号的字符串。以下是Reason语法中的函数:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lf lg l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Sign with RS256: just copy and paste!</figcaption></figure><p id="4298" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kw kj kk kl kx kn ko kp ky kr ks kt ku hn dt translated">我在这里使用了3个库:<code class="eh lb lc ld le b">nocrypto</code>、<code class="eh lb lc ld le b">x509</code>和<code class="eh lb lc ld le b">cstruct</code>。因此，请确保在项目中使用它们之前安装它们:</p><pre class="jk jl jm jn fq ll le lm ln aw lo dt"><span id="20d2" class="lp lq hu le b fv lr ls l lt lu">opam install nocrypto x509 cstruct</span></pre><p id="1920" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kw kj kk kl kx kn ko kp ky kr ks kt ku hn dt translated">上面的函数接受一个私钥和一个字符串，然后对字符串进行签名。所以我们需要得到私钥，特别是一个<code class="eh lb lc ld le b">Nocrypto</code>私钥。这里有一种将PEM文件读入<code class="eh lb lc ld le b">Nocrypto</code> RSA私钥的快速方法:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lf lg l"/></div><figcaption class="lh li fg fe ff lj lk bd b be z ek">Now, `key` is our private GitHub key. Again, just copy-and-paste!</figcaption></figure><p id="6e47" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kw kj kk kl kx kn ko kp ky kr ks kt ku hn dt translated">现在，我们可以简单地用我们的私钥签署请求。剩下的JWT一代代码住在这里。它非常简单，但是很粗糙——我使用的是硬编码的stringified JSON，我甚至不感到抱歉——因为有类型检查，所以感觉很安全。它格式化了一些<code class="eh lb lc ld le b">int</code> s，所以JSON不需要转义。感觉不错。</p></div><div class="ab cl lv lw hc lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hn ho hp hq hr"><p id="58fc" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kw kj kk kl kx kn ko kp ky kr ks kt ku hn dt translated"><a class="ae kv" href="https://hackernoon.com/the-programming-language-im-looking-for-948d93f7a396" rel="noopener ugc nofollow" target="_blank">正如我在</a>之前提到的，文档和进入壁垒不是OCaml/Reason land最强的方面，所以我希望这能帮助其他人，甚至是未来的我。请不要犹豫<a class="ae kv" href="https://twitter.com/galstar" rel="noopener ugc nofollow" target="_blank">在twitter上给我发短信</a>或者在这里回复。我很想聊天！</p><p id="4d10" class="pw-post-body-paragraph jy jz hu kb b kc kd iv ke kf kg iy kh kw kj kk kl kx kn ko kp ky kr ks kt ku hn dt translated">干杯！</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mc lg l"/></div></figure></div></div>    
</body>
</html>