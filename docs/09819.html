<html>
<head>
<title>Integrating Push Notifications in your React Web App (CRA)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React Web应用程序中集成推送通知(CRA)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/integrating-push-notifications-in-your-react-web-app-cra-22d3010392e?source=collection_archive---------1-----------------------#2018-12-05">https://medium.com/hackernoon/integrating-push-notifications-in-your-react-web-app-cra-22d3010392e?source=collection_archive---------1-----------------------#2018-12-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/702200b80033c71c0f91185a7b9399ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*96VdeZrtfcvvsvHzuph-Cw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">mobify.com</figcaption></figure><p id="9fa8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为react应用程序实现推送通知非常简单，除非你必须在用<a class="ae ke" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> Create React App </a>构建的应用程序上这样做，你可能会有一个新的服务工作者文件要处理。</p><p id="4802" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">作为一个稍微熟悉CRA应用程序的文件夹结构的人，你会知道这将导致冲突或一个服务人员试图覆盖其他人。</p><p id="c6d1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">事情变得很复杂。</p><p id="30ad" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这有三个原因:</p><ol class=""><li id="e1c3" class="kf kg hu ji b jj jk jn jo jr kh jv ki jz kj kd kk kl km kn dt translated">使用CRA <code class="eh ko kp kq kr b">npm run build</code>的默认脚手架流程，自动生成服务人员。如果你现在经历它，可能需要一段时间才能理解它在做什么。</li><li id="d23f" class="kf kg hu ji b jj ks jn kt jr ku jv kv jz kw kd kk kl km kn dt translated">您不能简单地编辑这个文件来包含您的firebase service worker方法和导入。你将不得不特别做<code class="eh ko kp kq kr b">npm run eject</code>，这意味着你将不得不靠自己<a class="ae ke" href="https://stackoverflow.com/questions/42817478/what-do-you-lose-by-ejecting-a-react-app-that-was-created-using-create-react-app" rel="noopener ugc nofollow" target="_blank"/>。</li><li id="1b2d" class="kf kg hu ji b jj ks jn kt jr ku jv kv jz kw kd kk kl km kn dt translated">当你下一次<code class="eh ko kp kq kr b">npm run build</code>你的项目时，你必须使用<strong class="ji hv"> Webpack </strong>插件来生成合适的服务工人。</li></ol><p id="4a33" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">npm包ServiceWorkerWebpackPlugin就是一个例子</p><p id="5334" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这些插件的工作方式是发布一个动态的<strong class="ji hv">服务工作者</strong>文件，用一个运行时助手代替默认的<strong class="ji hv"> <em class="kx"> sw </em> </strong>。</p><h1 id="cbae" class="ky kz hu bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">解决方案</h1><p id="57d9" class="pw-post-body-paragraph jg jh hu ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd hn dt translated">另一种方法是避免修改。/src和在/build中生成的文件(我们实际上没有这方面的业务)，它很可能被命名为类似“registerServiceWorker.js”的名称。</p><p id="34e3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">您应该尝试将新的服务人员放在公共/资产文件夹中，这是用于保存我们的资产的文件夹。我的服务人员名为“firebase-messaging-sw.js”</p><p id="a10b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这个想法是，webpack不会将js文件捆绑在public/assets文件夹中，这与。/src，然后我们可以调用它，并在react应用程序的根目录下注册它。</p><p id="d804" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我决定这样构建我的应用程序:</p><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="8448" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在initializePush()函数中，我们将询问用户是否希望我们给他们发送通知。并且它仅在注册/更新服务工作者文件之后被调用。</p><blockquote class="mh mi mj"><p id="fdd8" class="jg jh kx ji b jj jk jl jm jn jo jp jq mk js jt ju ml jw jx jy mm ka kb kc kd hn dt translated">在浏览器对新旧文件进行二进制比较之后，服务工作器被更新；在比较后发现输出差异时，它将安装新的服务工作器，然后生成新的令牌。</p></blockquote><p id="1e0d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">下面是第一次请求向用户发送推送通知时显示的模式。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mn"><img src="../Images/f88f4ce8954ed85a9c4e04996ba72129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aYtzosBRQyKaCI6VO3SBSw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Show notifications modal</figcaption></figure><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="aafb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，根据您当前的firebase实例获取令牌。您会注意到这个函数有<em class="kx"> requestPermission() </em>函数和<em class="kx">消息传递</em>。<em class="kx"> getToken() </em>然后是<em class="kx"> sendTokenToServer() </em>都在<strong class="ji hv">里。然后()</strong>连锁。这是否意味着每次我们到达代码中的这一点时，都会从firebase获得一个新的令牌？</p><p id="b13c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">显然，事实证明我们没有。每次函数被调用时，我们不会得到一个新的令牌。实际情况是，第一次调用getToken方法时，会进行网络调用，一旦检索并使用(发送到我们的后端)对<em class="kx"> getToken </em>()的后续调用，令牌将从缓存中返回。</p><h1 id="b7ab" class="ky kz hu bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated"><strong class="ak">临时演员</strong></h1><p id="d40e" class="pw-post-body-paragraph jg jh hu ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd hn dt translated"><code class="eh ko kp kq kr b">message.onMessage()</code></p><p id="4503" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当客户端打开应用程序时，接收发送到此客户端的消息。</p><p id="4b69" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh ko kp kq kr b">self.addEventListener("notificationclick",()=&gt;{})</code></p><p id="470f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当客户端点击从应用服务器发送的通知时调用。</p><p id="b34b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh ko kp kq kr b">message.setBackgroundMessageHandler</code></p><p id="d826" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">此方法处理客户端没有打开应用程序时收到的消息。</p><p id="6694" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">记得在另一个目录中实例化你的firebase实例，以防你错过了，这里用到了；<code class="eh ko kp kq kr b">import messaging from 'config/firebase'</code></p><p id="9045" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">祝你好运！</p></div></div>    
</body>
</html>