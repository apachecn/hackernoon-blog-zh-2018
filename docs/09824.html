<html>
<head>
<title>Upgradeable Ethereum Contracts V2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可升级以太坊合同V2</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/upgradeable-ethereum-contracts-v2-786d9c18cd9d?source=collection_archive---------6-----------------------#2018-12-05">https://medium.com/hackernoon/upgradeable-ethereum-contracts-v2-786d9c18cd9d?source=collection_archive---------6-----------------------#2018-12-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="9b73" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">充分利用委托通话</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/2e43e43f5c30d949ee3dd4940f70fb0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NtJ8sgGGPlVww5TD"/></div></div></figure><h2 id="9f3f" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated"><a class="ae kt" href="https://github.com/kyriediculous/upgradeable-contracts-v2" rel="noopener ugc nofollow" target="_blank">寻找代码？</a></h2><p id="2773" class="pw-post-body-paragraph ku kv hu kw b kx ky iv kz la lb iy lc kg ld le lf kk lg lh li ko lj lk ll lm hn dt translated">几个月前，我在<a class="ae kt" href="https://hackernoon.com/tagged/ethereum" rel="noopener ugc nofollow" target="_blank">以太坊</a> <a class="ae kt" href="https://hackernoon.com/tagged/blockchain" rel="noopener ugc nofollow" target="_blank">区块链</a>写了第一篇关于可升级智能合约的博文。我们解释过，智能合同一旦部署到区块链上，就不能更改。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="ab fr cl ln"><img src="../Images/5721a62eeb01e1ad12eeb769bb55e834.png" data-original-src="https://miro.medium.com/v2/format:webp/1*r6LLu7uRLpMBsmTa0b58aQ.png"/></div></figure><p id="eba4" class="pw-post-body-paragraph ku kv hu kw b kx lo iv kz la lp iy lc kg lq le lf kk lr lh li ko ls lk ll lm hn dt translated">等等？启动后无法升级代码？这似乎是个坏主意，尤其是如果你习惯于敏捷开发周期的话。虽然有保证的代码执行可能是一个好处，但当有一个错误时，它是完全相反的。智能合约中的漏洞导致了数百万美元的损失，甚至诞生了我们今天所知道的以太坊，在早期最受欢迎的智能合约之一<em class="lt"> slock.it DAO </em>被发现存在漏洞，允许攻击者耗尽合约中的所有资金(<a class="ae kt" href="https://solidity.readthedocs.io/en/v0.4.25/security-considerations.html#re-entrancy" rel="noopener ugc nofollow" target="_blank">重入攻击</a>)。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/e22b2393d702210ae487046475d3857c.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*Z6WPXJzb1J1Rz9I9Vmkf_A.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek"><a class="ae kt" rel="noopener" href="/swlh/the-story-of-the-dao-its-history-and-consequences-71e6a8a551ee">https://medium.com/swlh/the-story-of-the-dao-its-history-and-consequences-71e6a8a551ee</a></figcaption></figure><h1 id="99a5" class="lz jw hu bd jx ma mb mc kb md me mf kf ja mg jb kj jd mh je kn jg mi jh kr mj dt translated">第一版</h1><p id="5ff7" class="pw-post-body-paragraph ku kv hu kw b kx ky iv kz la lb iy lc kg ld le lf kk lg lh li ko lj lk ll lm hn dt translated"><a class="ae kt" href="https://hackernoon.com/upgradeable-smart-contracts-a7e9aef76fdd" rel="noopener ugc nofollow" target="_blank">在我们关于这个主题的上一篇博文</a>中，我们探索了一种基于<a class="ae kt" href="https://github.com/monax/legacy-docs/blob/master/solidity/solidity_1_the_five_types_model.md" rel="noopener ugc nofollow" target="_blank"> <em class="lt">五类型模型</em> </a>的策略，这是Monax(现在的<a class="ae kt" href="https://www.hyperledger.org/projects/hyperledger-burrow" rel="noopener ugc nofollow" target="_blank"> Hyperledger Burrow </a>)在Solc发布之前构思的，所以它在以太坊世界中已经相当古老了。这种模型将存储和逻辑划分到单独的契约中，并有一个注册表来跟踪各个部分。这个版本的部署变得很昂贵，尤其是如果我们一次又一次地实例化同一个契约。这类似于在传统编程中实例化类，但是以太坊区块链上的契约部署花费了大量金钱，所以我们不想花费不必要的费用。</p><h1 id="6946" class="lz jw hu bd jx ma mb mc kb md me mf kf ja mg jb kj jd mh je kn jg mi jh kr mj dt translated">代理库</h1><p id="5f14" class="pw-post-body-paragraph ku kv hu kw b kx ky iv kz la lb iy lc kg ld le lf kk lg lh li ko lj lk ll lm hn dt translated"><em class="lt">五种类型的模型</em>开始还可以，但不是最佳的。对于代理库，我们的基本合同是一个已经部署在区块链上的库。当我们创建一个这样的实例时，我们将部署一个将它的调用转发到指定地址的契约。如果我们想要更新库中的一些函数逻辑，我们将重新部署库，并将我们的契约指向这个新库。即使采用这种策略，也有相当多的代码开销来实现它。最终，我们的目标是将实例化契约的代码限制为只有一个函数，一个转发函数。</p><h1 id="110b" class="lz jw hu bd jx ma mb mc kb md me mf kf ja mg jb kj jd mh je kn jg mi jh kr mj dt translated">可升级的V2</h1><p id="6c07" class="pw-post-body-paragraph ku kv hu kw b kx ky iv kz la lb iy lc kg ld le lf kk lg lh li ko lj lk ll lm hn dt translated">一年多前，Vitalik在Reddit上发布了一篇关于期货合同的帖子<a class="ae kt" href="https://www.reddit.com/r/ethereum/comments/6c1jui/delegatecall_forwarders_how_to_save_5098_on/" rel="noopener ugc nofollow" target="_blank">。问题是在metropolis之前(写这篇文章的时候)，转发函数的输出大小不能是动态的，并且被限制在<em class="lt"> 4096字节</em>。该问题已在<em class="lt"> Metropolis </em>中修复，现在我们可以正确实现这种类型的转发。<br/> <br/>契约调用使用<strong class="kw hv"> DELEGATECALL </strong>的低级版本转发(虽然在solidity 0.5.0中，高级版本现在也返回数据)。Delegatecall将调用转发给另一个契约，并允许该契约<strong class="kw hv">更改委托者的存储，同时保留原始消息对象</strong>。</a></p><p id="009a" class="pw-post-body-paragraph ku kv hu kw b kx lo iv kz la lp iy lc kg lq le lf kk lr lh li ko ls lk ll lm hn dt translated">委托通话没有很好的记录。文档说明它获取调用契约的上下文(消息对象和存储)并在转发的调用中使用它。一个未记载的特征是，如果转发器在协定中没有它自己的存储定义，只要存储顺序匹配，它在初始化之后仍将采用主协定的定义和它自己的值。</p><p id="4f49" class="pw-post-body-paragraph ku kv hu kw b kx lo iv kz la lp iy lc kg lq le lf kk lr lh li ko ls lk ll lm hn dt translated">让我们用一个代码例子让它更清楚(感谢来自<a class="ae kt" href="https://www.originprotocol.com/" rel="noopener ugc nofollow" target="_blank"> Origin Protocol </a>的家伙给我指出了这个方法)</p><h1 id="91a5" class="lz jw hu bd jx ma mb mc kb md me mf kf ja mg jb kj jd mh je kn jg mi jh kr mj dt translated">例子</h1><p id="a91a" class="pw-post-body-paragraph ku kv hu kw b kx ky iv kz la lb iy lc kg ld le lf kk lg lh li ko lj lk ll lm hn dt translated">首先，我们有一份主合同。它在存储器中有一个名为<em class="lt"> count </em>的无符号整数集和两个函数。一个用于将<em class="lt">计数</em>加1，一个用于检索变量。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mk ml l"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">DummyMaster.sol</figcaption></figure><p id="a744" class="pw-post-body-paragraph ku kv hu kw b kx lo iv kz la lp iy lc kg lq le lf kk lr lh li ko ls lk ll lm hn dt translated">接下来我们有一个契约，它将作为<em class="lt"> DummyMaster.sol </em>，<strong class="kw hv">的实例。注意，两个契约都以<em class="lt">地址impl </em>开始，因为契约需要遵循彼此的存储顺序。</strong>在<em class="lt"> Dummy.sol </em>的构造函数中我们设置了<em class="lt"> DummyMaster.sol </em>的地址。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mk ml l"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Dummy.sol</figcaption></figure><p id="7504" class="pw-post-body-paragraph ku kv hu kw b kx lo iv kz la lp iy lc kg lq le lf kk lr lh li ko ls lk ll lm hn dt translated">编译后，<em class="lt"> Dummy.sol </em>没有匹配DummyMaster的ABI，为了更容易与契约交互，我们可以编写一个未部署的接口契约。这一步不是必需的，但是通过在代理地址实例化接口，这样更容易创建<em class="lt"> calldata </em>(参见<em class="lt"> test.js </em>)。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mk ml l"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">DummyInterface.sol</figcaption></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mk ml l"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">test.js</figcaption></figure><p id="e07c" class="pw-post-body-paragraph ku kv hu kw b kx lo iv kz la lp iy lc kg lq le lf kk lr lh li ko ls lk ll lm hn dt translated">让我们测试我们的新架构！首先部署主服务器，然后部署几次代理服务器，并在构造函数中传递主服务器地址。在我们的测试中，我们部署代理三次。我们可以测试每个代理都有单独的存储，如果我们每次都使用相同的契约，那么所有情况下的计数都必须等于1，计数应该是3。</p><p id="fbd9" class="pw-post-body-paragraph ku kv hu kw b kx lo iv kz la lp iy lc kg lq le lf kk lr lh li ko ls lk ll lm hn dt translated">就是这样，一个非常简单的方法来编写可升级的智能合同！一个警告是，这些合约的交易稍微昂贵一些，因此将它与保存所有数据的整体合约(如ERC20令牌合约)一起使用不是一个好主意。</p><p id="2cab" class="pw-post-body-paragraph ku kv hu kw b kx lo iv kz la lp iy lc kg lq le lf kk lr lh li ko ls lk ll lm hn dt translated">另一方面，按用户或有限用户之间的合同，如第三方托管、奖金或身份声明注册，将大大受益于此。</p><p id="155a" class="pw-post-body-paragraph ku kv hu kw b kx lo iv kz la lp iy lc kg lq le lf kk lr lh li ko ls lk ll lm hn dt translated">完整代码可以在<a class="ae kt" href="https://github.com/kyriediculous/upgradeable-contracts-v2" rel="noopener ugc nofollow" target="_blank"> my Github </a>上找到！感谢阅读！</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><a href="http://bit.ly/2G71Sp7"><div class="fe ff mm"><img src="../Images/449450761cd76f44f9ae574333f9e9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKX2mtg7p1lOs7JmosPLsA.png"/></div></a><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Learn smart contract development</figcaption></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mn ml l"/></div></figure></div></div>    
</body>
</html>