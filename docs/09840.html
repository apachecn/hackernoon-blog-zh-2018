<html>
<head>
<title>From MVC to Modern Web Frameworks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从MVC到现代Web框架</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/from-mvc-to-modern-web-frameworks-8067ec9dee65?source=collection_archive---------0-----------------------#2018-12-06">https://medium.com/hackernoon/from-mvc-to-modern-web-frameworks-8067ec9dee65?source=collection_archive---------0-----------------------#2018-12-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="c9a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">模型-视图-控制器(MVC)是软件体系结构中最广泛和最有影响力的模式之一。尽管有MVC死亡的传言，但它仍然是<a class="ae jp" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener ugc nofollow" target="_blank">理解</a>的有用模式。在这篇文章中，我不会局限于MVC的各种定义，而是强调它是如何演变成我们今天所知道和喜爱的现代web框架的。</p><h1 id="c6c3" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">开始</h1><p id="2146" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">1978年，Trygve Reenskaugh和Adele Goldberg创造了“模型-视图-控制器”这个名字。Trygve认为MVC及其变体形成了一种<a class="ae jp" href="https://en.wikipedia.org/wiki/A_Pattern_Language" rel="noopener ugc nofollow" target="_blank">模式语言</a>，一种人们谈论问题及其解决方案的共享语言。软件模式语言的概念也影响了“四人帮”写的《设计模式》一书。如果MVC包含在设计模式书中，我们可能会在<a class="ae jp" href="https://en.wikipedia.org/wiki/Behavioral_pattern" rel="noopener ugc nofollow" target="_blank">行为模式</a>部分找到它，与<a class="ae jp" href="https://en.wikipedia.org/wiki/Mediator_pattern" rel="noopener ugc nofollow" target="_blank">中介</a>和<a class="ae jp" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">观察者</a>这样的模式混在一起。</p><p id="a873" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是try gve 2003年的回顾论文，<a class="ae jp" href="http://heim.ifi.uio.no/~trygver/2003/javazone-jaoo/MVC_pattern.pdf" rel="noopener ugc nofollow" target="_blank"> MVC，它的过去和现在</a>。Trygve列举了构成MVC模式语言的11种模式。只有两个在很大程度上停滞不前:<em class="kt">模型/编辑器分离</em>和<em class="kt">输入/输出分离</em>，我认为它们本质上是相同的:</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="fe ff ku"><img src="../Images/b3ca3d013794c61c50e37195d3c6c7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7LesGFlzQzpGiP8m"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek"><em class="lk">Variants where the input goes through the View are also common.</em></figcaption></figure><blockquote class="ll lm ln"><p id="4515" class="ir is kt it b iu iv iw ix iy iz ja jb lo jd je jf lp jh ji jj lq jl jm jn jo hn dt translated">“当视图和控制器紧密耦合时，它们可能由同一个对象扮演”——Trygve Reenskaugh(这一点在社区中一直争论不休)</p></blockquote><h1 id="2783" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">本机MVC</h1><p id="f700" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在接下来的几十年里，随着Mac OS和Windows系统的快速发展和演变，MVC比Smalltalk和powered应用程序存在得更久。后来，当智能手机开始出现时，Windows Mobile的原生移动应用和iOS的早期版本也依赖于MVC及其变体。在微软，MVC后来演变成了<a class="ae jp" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" rel="noopener ugc nofollow" target="_blank"> MVVM </a>，为WPF、Silverlight和Xamarin等项目提供动力。</p><h1 id="3182" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">Web MVC</h1><p id="0e76" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在21世纪初，几个重要的web框架采用了MVC模式语言:Spring、Ruby on Rails、PHP和ASP.net。这些框架为控制器增加了新的职责:处理初始HTTP请求。事情是这样的:</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="fe ff lr"><img src="../Images/5742a1d24ced09b152550814aa9d66b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1VVNmPlwpfeytDMh"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">Controllers respond to HTTP requests</figcaption></figure><p id="1815" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">控制器现在是应用程序的入口点，而不是视图。视图的职责也发生了变化:它的工作不再是直接向用户呈现和处理输入，而是组装一堆HTML、JS和CSS供浏览器呈现。HTML/JS将包含类似按钮点击处理程序的逻辑，该处理程序将通过XMLHttpRequest将动作发送回控制器。请注意，浏览器中并没有明显的MVC模式。随着现代Web框架的出现，这种情况很快就会改变。</p><h1 id="e158" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">现代Web框架</h1><p id="920f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">随着浏览器大战的平息，我们终于有了好东西:XMLHttpRequest、稳定的DOM API、ES6等等。随着能力和灵活性的增加，公司开始构建越来越复杂的网络应用程序(有时被称为<a class="ae jp" href="https://en.wikipedia.org/wiki/Single-page_application" rel="noopener ugc nofollow" target="_blank">单页应用程序- SPA </a>)，而不是相关的简单网页集。现代Web框架有助于组织这种日益增加的客户端复杂性，并保持应用程序开发的可预测性和高效性。</p><p id="ed24" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通常，这些框架引入了额外的构建步骤来创建HTML、JS和CSS的静态包，以便通过简单的“视图控制器”(通常是/或/index.html中的处理程序)直接托管。这些资源的静态性质意味着我们可以设置缓存控制头，并依靠cdn来帮助以更低的延迟为它们提供服务。这些单页应用程序包括针对“API控制器”提供的一组资源发出HTTP API请求的逻辑(在JS中),这些资源通常用JSON响应:</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="fe ff ls"><img src="../Images/b2464d01fd950e4612e66788388e4285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dTPUy_vSyQPHe-kX"/></div></div></figure><p id="c883" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就把我们带到了今天:<a class="ae jp" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>、<a class="ae jp" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue </a>和<a class="ae jp" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>是最流行的现代Web框架。这些框架的组织模式与MVC有多相似？所有这些都有某种“视图”，因此任何比较都需要在下一层完成:状态(模型)、中介逻辑(控制器)和同步。</p><p id="e6f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将通过最常用的方法来描述这些框架。我敢肯定，某处有人坚持将数据绑定与React、Flux与Angular、炸薯条与花生酱结合起来。</p><p id="8cf8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Vue是最直接的:它的文档清楚地表明<a class="ae jp" href="https://012.vuejs.org/guide/" rel="noopener ugc nofollow" target="_blank"> Vue是MVVM </a>的一个实现。默认情况下，Angular也是MVVM风格的<a class="ae jp" href="https://angular.io/guide/architecture" rel="noopener ugc nofollow" target="_blank">。然而，React是从一颗垂死恒星的心脏中锻造出来的，使用了一种叫做</a><a class="ae jp" href="https://github.com/facebook/flux" rel="noopener ugc nofollow" target="_blank">通量</a>的超级模式:</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="fe ff lt"><img src="../Images/328c84c22cadb8ed93c5e7edbc889e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f2gaPN1PjH_mjJC-"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek"><em class="lk">Chris Hemsworth creating React at Facebook</em></figcaption></figure><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="fe ff ls"><img src="../Images/87390d2397a47d5d22ac4663d2033b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HIDi0gB-gme8JrcD"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">Actual Flux diagram; a<em class="lk">ll the arrows on the right-side point clockwise.</em></figcaption></figure><p id="7300" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Flux完全是单向数据流。回想一下，MVC中的模型表示将由视图呈现的持久化数据。Flux分割了MVC模型的职责；它将动作/API用于业务逻辑，将“存储”用于处理状态。你可以把商店想象成整个应用程序的一个整体被动模型。</p><p id="3e0d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为什么Flux拥抱单向数据流？原因是这样的:随着应用程序变得越来越复杂，用视图更新来管理状态变化变得越来越困难，尤其是当这些变化来自不同的来源时。与<a class="ae jp" href="https://en.wikipedia.org/wiki/Data_binding" rel="noopener ugc nofollow" target="_blank">数据绑定</a>相反，在数据绑定中，视图观察ViewModel的可变实例的属性变化，<a class="ae jp" href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html#components-can-be-classes-or-functions" rel="noopener ugc nofollow" target="_blank"> React创建一个新视图作为不可变状态/属性的函数</a>。视图从不需要担心本地状态的变化。应用程序只能通过在状态树中创建新的模型实例来进行更改。当React想要更新应用程序时，它会用一个新对象替换其状态树的一部分，这将触发新视图的创建。</p><p id="5000" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然单向数据流是一个强大的概念，但它不是装满银弹的免费午餐盒，也不会将反应/流量提升到与角度/Vue不同的T2级别。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="fe ff lu"><img src="../Images/e799ec9813abc1e54d26a3f1b4b630d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g2vZ_UYqzRWpp-Oj"/></div></div><figcaption class="lg lh fg fe ff li lj bd b be z ek">The MVC tree of life</figcaption></figure><p id="b088" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望这是有用的。如果没用，那就有意思。如果不有趣…那是过去的事了，过去是不可改变的；也许您应该用一个新的函数生成的不可变实例来代替自己，这个实例可以更好地决定阅读哪些文章=)。</p></div></div>    
</body>
</html>