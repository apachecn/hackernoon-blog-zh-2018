<html>
<head>
<title>The Ultimate Guide for Implementing a Simple Modal Component in Vanilla JavaScript, React, Angular, and Vue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用普通JavaScript、React、Angular和Vue实现简单模态组件的终极指南</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-ultimate-guide-for-creating-a-simple-modal-component-in-vanilla-javascript-react-angular-8733e2859b42?source=collection_archive---------2-----------------------#2018-12-06">https://medium.com/hackernoon/the-ultimate-guide-for-creating-a-simple-modal-component-in-vanilla-javascript-react-angular-8733e2859b42?source=collection_archive---------2-----------------------#2018-12-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9f44" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最近，我从<strong class="it hv">微软</strong>离职，重新加入<a class="ae jp" href="https://www.outbrain.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Outbrain </strong> </a>。</p><p id="54bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在公司之间转移并不总是容易的，因为每个公司用于开发其前端项目的技术和库之间并不一定一致。例如，在微软，我们的项目使用React，而在Outbrain，最常见的框架是Angular。</p><p id="f752" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无论你打算用哪个框架或库来开发，产品的规格和开发web应用的需求大部分都是一样的，所以你可能会一次又一次地为不同的库创建相同的组件。</p><p id="9d8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">web应用程序中最常见的组件之一是(强大的)模型。在本文中，我将通过<strong class="it hv">向您介绍如何用普通的JavaScript以及3个最流行的JavaScript库&amp;框架中的每一个创建一个简单的模态组件</strong>:<strong class="it hv">React</strong>、<strong class="it hv"> Angular </strong>和<strong class="it hv"> Vue </strong>。</p><p id="2ded" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">深呼吸，我们要进去了。</p><p id="269c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">顺便说一句，如果你没有10分钟的时间来阅读整篇文章，你可以在这里找到包含所有例子的Github库:</p><div class="jq jr fm fo js jt"><a href="https://github.com/dsternlicht/the-ultimate-guide-for-creating-a-simple-modal-in-react-vue-angular-and-vanilla-js" rel="noopener  ugc nofollow" target="_blank"><div class="ju ab ej"><div class="jv ab jw cl cj jx"><h2 class="bd hv fv z el jy eo ep jz er et ht dt translated">dsternlicht/创建简单模式的终极指南</h2><div class="ka l"><h3 class="bd b fv z el jy eo ep jz er et ek translated">我的中型文章“用香草创建简单模态组件的终极指南…</h3></div><div class="kb l"><p class="bd b gc z el jy eo ep jz er et ek translated">github.com</p></div></div><div class="kc l"><div class="kd l ke kf kg kc kh ki jt"/></div></div></a></div><h1 id="204f" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">投机</h1><p id="db78" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">在我们开始创建模态组件之前，我们需要理解它的核心概念和需求。</p><ul class=""><li id="9436" class="lm ln hu it b iu iv iy iz jc lo jg lp jk lq jo lr ls lt lu dt translated">模态是在页面上发生事件(页面加载、点击、滚动等)后出现和消失的元素。).</li><li id="362c" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">Modal应该支持所有类型的内容，包括文本、图像、视频。</li><li id="ead7" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">模态应该反应灵敏，适合各种屏幕尺寸。</li><li id="53fe" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">传统上，一个模态有两层:一个覆盖层(用于隐藏页面内容)，和模态本身。</li><li id="9eba" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">Modal应该有一个默认的设计，但是支持定制类来定制特定元素的设计。</li><li id="8934" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">模式应该有一个关闭按钮。</li><li id="8739" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">模态控制器应该被通知模态事件(例如模态打开、模态关闭等)。</li></ul><p id="eb79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了完善规范，这里有一个在Twitter中撰写新推文的模型示例:</p><figure class="mb mc md me fq mf fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff ma"><img src="../Images/f3af9edfa6718a3d1cca9316af1fb9ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AQWb83D3VLp018KDG2-56g.png"/></div></div></figure><h1 id="94a2" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">基础</h1><p id="6b00" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">尽管我们将在4个不同的JavaScript库和方法中实现我们的模型，但我们可以使用相同的基本CSS和HTML来模仿我们的模型。</p><p id="c66b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">HTML:</p><figure class="mb mc md me fq mf"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="f8ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如您所见，HTML代码非常简单。我们有一个类为<code class="eh mn mo mp mq b">modal</code>的包装器div元素，它有两个子元素:</p><ul class=""><li id="888f" class="lm ln hu it b iu iv iy iz jc lo jg lp jk lq jo lr ls lt lu dt translated"><code class="eh mn mo mp mq b">overlay</code> —这个元素将在后台，负责隐藏我们的web应用程序的内容。</li><li id="c075" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated"><code class="eh mn mo mp mq b">modal_content</code> —该元素是模态本身，将包括模态的内容。</li></ul><p id="98e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">CSS(魔法真正发生的地方🎩):</p><figure class="mb mc md me fq mf"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="1739" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们为模态的包装元素设置一个<code class="eh mn mo mp mq b">position: fixed;</code>(带有<code class="eh mn mo mp mq b">.modal</code>类的那个)。此外，我们将通过设置<code class="eh mn mo mp mq b">width: 100%; height: 100%;</code>来确保它占据我们的视口的100%的宽度和高度。我们还会用<code class="eh mn mo mp mq b">left: 0; top: 0;</code>将它对齐到屏幕的左上角。这将确保我们的模态得到所有的关注，因为屏幕的其他部分不会是交互式的。</p><p id="12ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们需要创建一个漂亮的有点透明的叠加层。我们将为<code class="eh mn mo mp mq b">.overlay</code> div设置一个<code class="eh mn mo mp mq b">absolute</code>位置，并使用与<code class="eh mn mo mp mq b">.modal</code>元素相同的技术在视口中拉伸它。然后，我们将添加一个透明的黑色背景色，以获得我们想要的效果(第17行)。</p><p id="6159" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们需要通过向<code class="eh mn mo mp mq b">.modal_content</code> div元素添加样式来设计模态本身。为了确保它总是与我们的视口中心对齐，我们将设置一个绝对位置并添加<code class="eh mn mo mp mq b">left: 50%; top: 50%;</code>对齐。此外，我们将添加<code class="eh mn mo mp mq b">transform: translate(-50%, -50%);</code>,这将确保模态始终与中心对齐，而不依赖于模态的宽度和高度。我们将使用的另一个技术是将<code class="eh mn mo mp mq b">max-height</code>设置为模态元素的90%，并确保如果内容高于这个值，浏览器将添加滚动条— <code class="eh mn mo mp mq b">overflow: auto;</code>(第27行)。</p><p id="93a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">背景颜色和其他属性由您决定。我使用了白色背景，添加了一个<code class="eh mn mo mp mq b">border-radius</code>和一个默认宽度。</p><p id="25ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">结果如下:</p><figure class="mb mc md me fq mf fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/93cfce03cfc3ebf99f75bb454356d4d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*u_Do6QsTLfpnIijBwI4usw.png"/></div><figcaption class="ms mt fg fe ff mu mv bd b be z ek">Ladies &amp; gentlemen we’ve got a modal!</figcaption></figure><p id="2457" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来:<strong class="it hv">让它发挥作用</strong>。</p><h1 id="447f" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">香草JS中的Modal</h1><p id="d3ca" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">如果我们看一下规范，模态的第一个要求是能够按需出现和消失，或者更准确地说，当事件在网页上发生时。出于本教程的考虑，我们将在用户单击特定按钮时打开模态。</p><p id="97bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，让我们创建一个按钮:</p><p id="be9f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mn mo mp mq b">&lt;button id="modal_opener"&gt;Click Me! I Don't Bite... 😛&lt;/button&gt;</code></p><p id="1734" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们将添加基本示例中的模态HTML，并更改内容:</p><figure class="mb mc md me fq mf"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="54cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，模态<code class="eh mn mo mp mq b">display</code>被设置为<code class="eh mn mo mp mq b">none</code>，因为我们不希望模态出现在页面加载中。</p><p id="c5de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将导入一个包含页面&amp;模态CSS的<code class="eh mn mo mp mq b">style.css</code>文件(同样，来自本教程的“<strong class="it hv">基础</strong>”部分)。</p><p id="bfa8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们将创建一个名为<code class="eh mn mo mp mq b">modal.js</code>的脚本来处理功能。</p><p id="9d47" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您应该得到以下HTML:</p><figure class="mb mc md me fq mf"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="f6ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在给页面添加了一些样式后，我设法得到了以下结果:</p><figure class="mb mc md me fq mf fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mw"><img src="../Images/db166e62b992f825d8e9d3bb6ac5736a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ou53UKYH-uxGOuJlXrETUw.png"/></div></div></figure><p id="2d01" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在是有趣的部分。</p><p id="abcb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是<code class="eh mn mo mp mq b">modal.js</code>的样子:</p><figure class="mb mc md me fq mf"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="4b94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是怎么回事？</p><p id="9831" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们创建了两个变量来保存我们将要使用的DOM元素:</p><ul class=""><li id="eb4e" class="lm ln hu it b iu iv iy iz jc lo jg lp jk lq jo lr ls lt lu dt translated"><strong class="it hv"> btn </strong> —将按住触发模态出现的按钮(第1行)。</li><li id="ceba" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated"><strong class="it hv">模态</strong> —将保存模态元素本身(第2行)。</li></ul><p id="149e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们将添加3个不同的功能:</p><ul class=""><li id="7289" class="lm ln hu it b iu iv iy iz jc lo jg lp jk lq jo lr ls lt lu dt translated"><strong class="it hv"> toggleModal </strong> —主要功能。它将通过查看<code class="eh mn mo mp mq b">modal.style.display</code>属性来检查模态的当前状态(第18行)。如果值是<code class="eh mn mo mp mq b">none</code>，它会将值设置为<code class="eh mn mo mp mq b">block</code>，这样模态就会可见(第19行)，并附加关闭模态的事件(第20行)。否则，如果模态是可见的，它将把值设置为<code class="eh mn mo mp mq b">none</code>，并将分离关闭事件(第23行)。</li><li id="40f3" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated"><strong class="it hv"> attachModalListeners </strong> —将添加2个事件监听器用于关闭模式。一次点击<code class="eh mn mo mp mq b">.overlay</code>层，另一次点击<code class="eh mn mo mp mq b">.close_modal</code>元素。</li><li id="e8cf" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated"><strong class="it hv"> detachModalListeners </strong> —将从我们上面提到的2个元素中移除事件处理程序。</li></ul><p id="f2ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后一部分是在单击按钮时添加事件处理程序本身:</p><p id="06e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mn mo mp mq b">btn.addEventListener('click', toggleModal);</code>(第二十七行)</p><p id="341e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就是这样！你得到了一个很好的香草JS模型:</p><figure class="mb mc md me fq mf fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/c04c6d28ebea83b1241ecd3987a3f7f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/1*V8VwkgIw-Wnuzkq28TyCnQ.gif"/></div></figure></div><div class="ab cl my mz hc na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hn ho hp hq hr"><h1 id="9161" class="kj kk hu bd kl km nf ko kp kq ng ks kt ku nh kw kx ky ni la lb lc nj le lf lg dt translated">反应中的模态</h1><p id="0a3d" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">在React中，开发一个可重用的组件是设计好的。所以创建我们的模态组件将会很容易。</p><p id="c46d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了简单起见，我们将使用<code class="eh mn mo mp mq b">create-react-app</code>生成一个新的应用程序。</p><p id="de81" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们将研究两个主要部分:</p><ul class=""><li id="cb5d" class="lm ln hu it b iu iv iy iz jc lo jg lp jk lq jo lr ls lt lu dt translated"><code class="eh mn mo mp mq b">app.js</code> —我们的应用程序的主要组件，将包含触发模态打开的按钮，并将导入模态组件。</li><li id="602d" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated"><code class="eh mn mo mp mq b">modal.js</code> —可重用的模态组件。</li></ul><p id="fa13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建了<code class="eh mn mo mp mq b">modal</code>文件夹和文件后，我们项目的结构将如下所示:</p><figure class="mb mc md me fq mf fe ff paragraph-image"><div class="fe ff nk"><img src="../Images/5d5baa96a93e4004a713693604789f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*BryUmUKOomMaAPmswejufQ.png"/></div><figcaption class="ms mt fg fe ff mu mv bd b be z ek">React’s “src” folder after creating a modal folder and component.</figcaption></figure><p id="5477" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们来看看情态成分(<code class="eh mn mo mp mq b">modal.js</code>):</p><figure class="mb mc md me fq mf"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="16ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看这里有什么。</p><p id="9156" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，在第1-4行，我们导入了所有相关的依赖项，包括模态组件的CSS(我从前面的例子中复制的)。</p><p id="6c4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们创建了一个接受4个属性的无状态组件:</p><ul class=""><li id="a8a3" class="lm ln hu it b iu iv iy iz jc lo jg lp jk lq jo lr ls lt lu dt translated"><strong class="it hv"> children </strong> —这个参数将是我们的modal的动态内容部分的占位符。它将被我们添加到模态组件的内容所取代。</li><li id="a5e3" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated"><strong class="it hv">显示</strong> —一个布尔值，它将决定模态是可见还是隐藏。</li><li id="87c1" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated"><strong class="it hv"> closeCallback </strong> —一个回调函数，一旦用户点击关闭按钮或覆盖层，该函数将被调用。</li><li id="d30a" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated"><strong class="it hv"> customClass </strong> —如果我们为模态组件设置一个自定义类，它将被链接到模态的容器。如果需要，这将帮助我们定制模态内容。</li></ul><p id="cbfb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有属性都是可选的，并且有一个默认值(第25–30行)。</p><p id="40c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们已经准备好了模态组件，是时候使用它了。</p><figure class="mb mc md me fq mf"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="5b31" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<code class="eh mn mo mp mq b">app.js</code>中，我们导入了模态<strong class="it hv"> </strong>组件(第3行)。</p><p id="be40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">app组件的状态包含一个名为<code class="eh mn mo mp mq b">showModal</code>的布尔属性(第9行)。该属性将负责模式可见性。此外，我们添加了一个<code class="eh mn mo mp mq b">toggleModal</code>方法(第12行),顾名思义，它将打开和关闭模态的可见性。</p><p id="2eb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mn mo mp mq b">render</code>方法将包括两个要素:</p><ul class=""><li id="44ba" class="lm ln hu it b iu iv iy iz jc lo jg lp jk lq jo lr ls lt lu dt translated">一个按钮元素，带有一个<code class="eh mn mo mp mq b">onClick</code>方法，一旦被点击就会调用<code class="eh mn mo mp mq b">toggleModal</code>并打开模态(第21–23行)。</li><li id="2eca" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">具有相关属性的模态组件(第25–29行)，以及将用作模态内容的子元素(第30–33行)。</li></ul><p id="66a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后…给你。React中的一个模态分量！</p></div><div class="ab cl my mz hc na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hn ho hp hq hr"><h1 id="61e2" class="kj kk hu bd kl km nf ko kp kq ng ks kt ku nh kw kx ky ni la lb lc nj le lf lg dt translated">角度模式</h1><p id="6af3" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">这很有趣。我对Angular并不陌生，事实上，我职业生涯的大部分时间都在使用AngularJS和Angular进行开发，然而，用Angular实现modal花费了我最长的时间，我发现自己一直对数据绑定的Angular注释感到困惑。</p><p id="463a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无论如何…</p><p id="3961" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将使用<a class="ae jp" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular CLI </a>生成一个新的Angular app，并运行<code class="eh mn mo mp mq b">ng new modal-app</code>命令。</p><p id="ba15" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们将通过运行<code class="eh mn mo mp mq b">ng generator c modal</code>添加一个名为“<strong class="it hv">模态</strong>的新组件。</p><p id="309e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">仅供参考，这是我们的<code class="eh mn mo mp mq b">src</code>文件夹的样子:</p><figure class="mb mc md me fq mf fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/dbc80e20dc77d4795e431468eb54c4dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*DN8zxrlouxK9UDqfpjZKvg.png"/></div><figcaption class="ms mt fg fe ff mu mv bd b be z ek">Angular’s “src” folder after generating a modal component.</figcaption></figure><p id="f540" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们从<code class="eh mn mo mp mq b">app.component.ts</code>文件开始:</p><figure class="mb mc md me fq mf"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="715e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很简单，对吧？</p><p id="61bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mn mo mp mq b">AppComponent</code>有一个<code class="eh mn mo mp mq b">showModal</code>属性，用于确定是否应该打开模态。此外，它有一个<code class="eh mn mo mp mq b">toggleModal</code>方法，可以双向地将<code class="eh mn mo mp mq b">showModal</code>属性从<code class="eh mn mo mp mq b">true</code>切换到<code class="eh mn mo mp mq b">false</code>。</p><p id="549c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们来看看<code class="eh mn mo mp mq b">modal.component.ts</code>文件:</p><figure class="mb mc md me fq mf"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="35bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">模态分量接受3个输入:</p><ul class=""><li id="a209" class="lm ln hu it b iu iv iy iz jc lo jg lp jk lq jo lr ls lt lu dt translated"><strong class="it hv">显示</strong> —显示/隐藏模态的布尔值。</li><li id="4b8f" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated"><strong class="it hv"> customClass </strong> —一个可选字符串，它将被链接到<code class="eh mn mo mp mq b">.modal</code>类，以便对特定的模态进行样式化。</li><li id="642f" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated"><strong class="it hv"> closeCallback </strong> —负责关闭模态的函数。</li></ul><p id="a1a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将在<code class="eh mn mo mp mq b">modal.component.html</code>模板中使用这3个输入:</p><figure class="mb mc md me fq mf"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="c22a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在第1行中，我们将使用<code class="eh mn mo mp mq b">[ngClass]</code>动态添加自定义类，如果<code class="eh mn mo mp mq b">show</code>属性设置为<code class="eh mn mo mp mq b">true</code>，则将display属性设置为<code class="eh mn mo mp mq b">block</code>，如果设置为<code class="eh mn mo mp mq b">false</code>，则将display属性设置为<code class="eh mn mo mp mq b">none</code>。</p><p id="e4de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在第2 &amp; 5行中，我们在点击事件上附加了<code class="eh mn mo mp mq b">closeCallback</code>方法，在第4行中，我们包含了模态内容。</p><p id="040a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是我们如何将模态添加到<code class="eh mn mo mp mq b">app.component.html</code>文件中:</p><figure class="mb mc md me fq mf"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="8b3a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，组件的名称是<code class="eh mn mo mp mq b">app-modal</code>，它被设置在<code class="eh mn mo mp mq b">selector</code>属性下的<code class="eh mn mo mp mq b">modal.component.ts</code>文件中。</p></div><div class="ab cl my mz hc na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hn ho hp hq hr"><h1 id="b6c9" class="kj kk hu bd kl km nf ko kp kq ng ks kt ku nh kw kx ky ni la lb lc nj le lf lg dt translated">Vue中的模态</h1><p id="62a5" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">我们从安装<a class="ae jp" href="https://cli.vuejs.org/" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">Vue CLI</strong></a><strong class="it hv"/>开始，通过运行<code class="eh mn mo mp mq b">vue create modal-app</code>生成一个新的Vue app。</p><p id="c8b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，在<code class="eh mn mo mp mq b">components</code>文件夹下，我们将为我们的模态组件创建一个新的Vue文件。</p><p id="632e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们应用程序的<code class="eh mn mo mp mq b">src</code>文件夹应该是这样的:</p><figure class="mb mc md me fq mf fe ff paragraph-image"><div class="fe ff nm"><img src="../Images/643e3d85200ad30d25d9661bc616c6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*b3BOBJ1T-eoEOUDgkF7ldA.png"/></div><figcaption class="ms mt fg fe ff mu mv bd b be z ek">Vue’s “src” folder after creating a modal component.</figcaption></figure><p id="a6b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们来看看<code class="eh mn mo mp mq b">App.vue</code>文件:</p><figure class="mb mc md me fq mf"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="5320" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在第16行，我们创建了一个脚本标签。在这个脚本中，我们将首先导入模态组件(第17行)，然后用我们的配置导出Vue对象。</p><p id="3f0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<code class="eh mn mo mp mq b">components</code>属性中，我们声明了<code class="eh mn mo mp mq b">Modal</code>组件(第21行),这样我们的模板就可以使用它了。在第25行，我们将把带有布尔值的<code class="eh mn mo mp mq b">show</code>属性添加到我们的数据对象中，在第28行，我们将添加<code class="eh mn mo mp mq b">toggleModal</code>方法，该方法将负责从<code class="eh mn mo mp mq b">true</code>和<code class="eh mn mo mp mq b">false</code>切换<code class="eh mn mo mp mq b">show</code>属性值，反之亦然。</p><p id="e495" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mn mo mp mq b">&lt;template&gt;</code>部分包括一个带有Vue事件监听器<code class="eh mn mo mp mq b">v-on:click</code>的<code class="eh mn mo mp mq b">button</code>元素(第3行),该监听器将在click事件时调用<code class="eh mn mo mp mq b">toggleModal</code>方法，还包括一个绑定3个属性的<code class="eh mn mo mp mq b">Modal</code>元素(第8行):</p><ul class=""><li id="f7d3" class="lm ln hu it b iu iv iy iz jc lo jg lp jk lq jo lr ls lt lu dt translated"><strong class="it hv">显示</strong> —一个布尔值，用于确定模态是否打开。</li><li id="f19f" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated"><strong class="it hv"> closeCallback </strong> —用户点击关闭按钮后调用的回调函数。</li><li id="4b87" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated"><strong class="it hv"> customClass </strong> —将被添加到模式包装器元素以进行样式定制的字符串。</li></ul><p id="d88f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可能想知道模态组件在Vue中会是什么样子，所以这里是:</p><figure class="mb mc md me fq mf"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="6847" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们定义了一个模板，其中包含了我们的模态的HTML。</p><p id="748d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要注意的几件事:</p><ul class=""><li id="4efb" class="lm ln hu it b iu iv iy iz jc lo jg lp jk lq jo lr ls lt lu dt translated">第2行:我们通过使用<code class="eh mn mo mp mq b">v-bind:class</code>注释添加自定义类，并通过使用<code class="eh mn mo mp mq b">v-bind:style</code>更改CSS <code class="eh mn mo mp mq b">display</code>属性，如果<code class="eh mn mo mp mq b">show</code>属性被相应地设置为<code class="eh mn mo mp mq b">true</code>或<code class="eh mn mo mp mq b">false</code>，则将其值从<code class="eh mn mo mp mq b">block</code>更改为<code class="eh mn mo mp mq b">none</code>。</li><li id="b5cb" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">第3 &amp; 6行:为了使用<code class="eh mn mo mp mq b">closeCallback</code>方法，我们使用了<code class="eh mn mo mp mq b">@click</code>注释。</li><li id="1b51" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">第5行:<code class="eh mn mo mp mq b">&lt;slot&gt;&lt;/slot&gt;</code>标签将用于包含模态内容。</li></ul><p id="47d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们导出一个名为<code class="eh mn mo mp mq b">Modal</code>的Vue对象(第14行)，并设置我们想要支持的每个道具的类型(第16行)。</p><p id="4954" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你就完事了！</p><p id="1f13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">补充说明</strong>:这是我第一次用<strong class="it hv"> Vue </strong>编写web应用，比Angular &amp; React(我非常熟悉)花费的时间要少😌。总结一下我对Vue的第一次体验:</p><figure class="mb mc md me fq mf"><div class="bz el l di"><div class="nn mm l"/></div></figure></div><div class="ab cl my mz hc na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hn ho hp hq hr"><h1 id="295f" class="kj kk hu bd kl km nf ko kp kq ng ks kt ku nh kw kx ky ni la lb lc nj le lf lg dt translated">包扎</h1><p id="2822" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">尽管每个库和框架都有自己的语法和注释，但概念是相同的。</p><p id="7a94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦我们理解了用普通JavaScript创建简单模态组件背后的技术，用React、Vue和Angular实现它就很容易了。</p><p id="7be5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">顺便说一下，在HTML 5中有一个<code class="eh mn mo mp mq b"><a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog" rel="noopener ugc nofollow" target="_blank">dialog</a></code> <a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog" rel="noopener ugc nofollow" target="_blank">元素</a>，带有一些很好的本地API，允许自定义样式，尽管有一些现成的polyfills，但大多数浏览器仍然不支持它。</p><p id="caa5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是包含所有示例的Github repo:</p><div class="jq jr fm fo js jt"><a href="https://github.com/dsternlicht/the-ultimate-guide-for-creating-a-simple-modal-in-react-vue-angular-and-vanilla-js" rel="noopener  ugc nofollow" target="_blank"><div class="ju ab ej"><div class="jv ab jw cl cj jx"><h2 class="bd hv fv z el jy eo ep jz er et ht dt translated">dsternlicht/创建简单模式的终极指南</h2><div class="ka l"><h3 class="bd b fv z el jy eo ep jz er et ek translated">我的中型文章“用香草创建简单模态组件的终极指南…</h3></div><div class="kb l"><p class="bd b gc z el jy eo ep jz er et ek translated">github.com</p></div></div><div class="kc l"><div class="kd l ke kf kg kc kh ki jt"/></div></div></a></div><p id="5ea0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你喜欢这篇文章，请随意分享，鼓掌，喜欢，再读一遍，发送给你的朋友，并在睡觉前读给你的孩子听🙂</p></div></div>    
</body>
</html>