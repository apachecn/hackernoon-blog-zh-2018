<html>
<head>
<title>How a Model Controller works with Core Data in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模型控制器如何在Swift中处理核心数据</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-a-model-controller-works-with-core-data-in-swift-c94481ff5316?source=collection_archive---------3-----------------------#2018-12-06">https://medium.com/hackernoon/how-a-model-controller-works-with-core-data-in-swift-c94481ff5316?source=collection_archive---------3-----------------------#2018-12-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b9ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">来自<a class="ae jp" href="https://emanleet.com/category/swiftcraft-podcasts/" rel="noopener ugc nofollow" target="_blank"> SwiftCraft播客</a>的最近一集特别报道了对<a class="ae jp" href="https://twitter.com/MatManferdini" rel="noopener ugc nofollow" target="_blank"> Matteo Manferdini </a>的有趣采访，Matteo Manferdini从第一代iPhone开始就一直在iOS中开发，在那之前一直在开发Mac应用。</p><p id="4169" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它提供了目前对iOS体系结构的反向观点，但却引起了我的共鸣——支持MVC。</p><p id="bfb9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在快速变化的软件行业中，保持一个极度开放的思维是非常重要的，因为时尚和革命之间的界限很窄。尽管近年来我一直在探索MVP、MVVM和VIPER，但它们都没有足够的说服力让我相信它们没有MVC <em class="jq">那么复杂和干净。</em></p><p id="4f0d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我一直想写一篇博文来阐述Matteo的<a class="ae jp" href="https://matteomanferdini.com/ios-architecture-lotus-mvc-pattern/" rel="noopener ugc nofollow" target="_blank"> Lotus MVC模式</a>，为什么无情的精益MVC可能是最干净的解决方案，以及这一切是如何与编程文化联系在一起的<strong class="it hv">我们正在将稍微复杂的概念变成极其复杂的解决方案</strong>。</p><p id="347a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对我来说，Lotus MVC模式仍然有点太接近VIPER，但这是我所见过的最接近于支持精益MVC的文献，精益MVC能够有机地增长，而不是从一开始就设置不必要的样板代码。我将详细阐述我对Lotus MVC的想法，以及它如何与一种我称之为<strong class="it hv"> FUMVC </strong>(半开玩笑半认真)的模式联系起来，以对抗复杂性加倍的趋势。</p><p id="1e39" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当高内聚和低耦合的经典软件工程概念与坚实的原则一起应用时，iOS中的MVC倾向于在一个特别好的抽象但易于遵循的架构之间取得平衡。这对快速原型或MVP，或长期遗留代码(<em class="jq">有机的</em> MVC增长)都是有益的。</p><p id="9d87" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Matteo提到的模型和视图控制器之间的抽象是一个<strong class="it hv">模型控制器</strong>，我不禁认为这是我通常用于任何核心数据工作的小型且可管理的模式。除了我通常称之为<code class="eh jr js jt ju b">ModelManager</code>或<code class="eh jr js jt ju b">ModelCoordinator</code>之类的东西。</p></div><div class="ab cl jv jw hc jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hn ho hp hq hr"><h1 id="aa7e" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">尝试不同的抽象</h1><p id="1ce1" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">多年来，我在处理核心数据的几种不同模式之间摇摆不定，这些模式可以总结为以下几个阶段:</p><ol class=""><li id="9c36" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated">当我启动iOS dev时，我更多地使用模型控制器模式，中央模型对象执行CRUD操作(或者在iOS中更学究式地说，添加、获取、保存和删除)，并设置<code class="eh jr js jt ju b">NSManagedObjectContext</code>、<code class="eh jr js jt ju b">NSPersistentStoreCoordinator</code>、<code class="eh jr js jt ju b">NSManagedObjectModel</code>核心数据堆栈，以及所需的任何<em class="jq">重量级迁移</em>。不幸的是，这通常也是一个单一的。</li><li id="1e3b" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">在一个特定的项目中，一名前端开发人员提供了一些关于API接口调用的反馈，他认为这对iOS前端更有意义。基于此，我尝试采用一种模式，其中每个模型的类或扩展包含它们自己的CRUD操作。因此，它们可以像下面的<code class="eh jr js jt ju b">modelType.create(withProperty: String)</code>或<code class="eh jr js jt ju b">modelType.fetch(byProperty: String, containingValue: String)</code>一样使用。这里有很多样板文件，但都没有什么收获。像fetch调用这样的东西的最初意图是作为指定谓词字符串的替代，并使用来自枚举的定制排序描述符等。但是仔细想想，我认为每个开发人员都应该熟悉谓词字符串，因为语法普遍适用于SQL查询，每个开发人员都应该熟悉SQL查询，即使是在使用ORM时。</li><li id="f8d5" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">从iOS 10开始，当<code class="eh jr js jt ju b">NSPersistentContainer</code>简化了核心数据堆栈的设置，在此之前，当泛型随着Swift的兴起而成为一件事情时，我一直倾向于一种方法，其中1或2个较小的抽象在数据模型和视图控制器之间进行协调。泛型使得减少样板代码的前景变得特别有吸引力，并且每当你需要一个后台MOC时,<code class="eh jr js jt ju b">NSPersistentContainer</code>温和地引导你创建一个新的后台MOC，这也有助于在精神上阻止你作为一个单独的实现它。</li></ol><figure class="lu lv lw lx fq ly fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff lt"><img src="../Images/7999c6e726d8b778fbe4e3def918db0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IIGdkajPd8gZs6cQxFWzqg.png"/></div></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek">A slide <a class="ae jp" href="https://developer.apple.com/videos/play/wwdc2016/242/" rel="noopener ugc nofollow" target="_blank">from WWDC 2016</a>, the introduction of NSPersistentContainer.</figcaption></figure><p id="2645" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于这一点，我想我可以分享上面我喜欢的核心数据<code class="eh jr js jt ju b">ModelController</code>的最新实现——目的是任何人<em class="jq"/>都可以把它放到他们的代码库中，不管你的数据模型是如何建立的！</p></div><div class="ab cl jv jw hc jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hn ho hp hq hr"><h1 id="59d7" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">模型控制器</h1><p id="c82e" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">我已经将它上传到了一个新的<a class="ae jp" href="https://github.com/thepost/FUMVC" rel="noopener ugc nofollow" target="_blank">库</a>中，这个库将用于更大的可重用<strong class="it hv"> FUMVC </strong>抽象的目的。这是对FUMVC 的第1个<a class="ae jp" href="https://github.com/thepost/FUMVC" rel="noopener ugc nofollow" target="_blank">贡献，所以这个库目前真的很小。</a></p><p id="9ba6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果它的主要目的是高度可重用，就不应该尝试所有的事情。出于这个原因，我将代码保持在最低限度。</p><p id="e143" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我通常使用传统的冗长的苹果影响的函数名，比如像<code class="eh jr js jt ju b">addDataStorageEntry</code>这样的名字。然而，最近我受到了我在React应用程序中的工作的影响，它的命名似乎受到了中间操作的影响——这似乎也是苹果正在向转移的命名惯例。所以函数定义为:</p><ul class=""><li id="ce91" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo mj ll lm ln dt translated"><code class="eh jr js jt ju b">add(type:)</code></li><li id="fb9f" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo mj ll lm ln dt translated"><code class="eh jr js jt ju b">total(type:)</code></li><li id="1dbe" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo mj ll lm ln dt translated"><code class="eh jr js jt ju b">fetch(type: predicate: sort:)</code></li><li id="5fa6" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo mj ll lm ln dt translated"><code class="eh jr js jt ju b">save()</code></li><li id="26bb" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo mj ll lm ln dt translated"><code class="eh jr js jt ju b">delete(by objectID:)</code></li><li id="4636" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo mj ll lm ln dt translated"><code class="eh jr js jt ju b">delete(type: predicate:)</code></li></ul><p id="4f1f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇博文中的示例代码没有做到的是——它只使用了一个托管对象上下文(用于主线程的视图上下文)，并且它没有实现线程处理，因为它会转移对主主题的注意力。虽然我已经用一些线程处理更新了Github库，并在下面稍微介绍了一下。但是现在，让我们深入研究上面的每一个功能…</p><figure class="lu lv lw lx fq ly"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="76b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jr js jt ju b">ModelController</code>属性仅仅由一个<code class="eh jr js jt ju b">NSPersistentContainer</code>和两个<code class="eh jr js jt ju b">NSManagedObjectContext</code>组成，分别用于主线程和后台线程。</p><p id="b041" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有一个方便的初始化器，它的唯一目的是通过依赖注入来设置模型名称，而不是耦合到核心数据抽象。<code class="eh jr js jt ju b">NSPersistentContainer</code>也因此偷懒。private <code class="eh jr js jt ju b">modelName</code>的默认值应该将模型名设置为bundle，如果您选择指定的初始化器，这可能是一个安全的场景。<code class="eh jr js jt ju b">modelName</code>是通过便利的初始化器而不是设置器来设置的，因为它的唯一目的是在实例化时被需要，而不是在其他地方。</p><figure class="lu lv lw lx fq ly"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="3476" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jr js jt ju b">ModelController+Add</code>负责创建一个新的<code class="eh jr js jt ju b">NSManagedObject</code>子类。如果Recipe是您的模型实体之一，您可以通过<code class="eh jr js jt ju b">modelController.add(Recipe.self)</code>使用它。</p><figure class="lu lv lw lx fq ly"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="c1a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在<code class="eh jr js jt ju b">ModelController+Fetch</code>中包含了一个total函数和一个fetch函数，因为它们都与fetch相关。这是完成<code class="eh jr js jt ju b">NSFetchRequest</code>的地方，谓词字符串和排序描述符是可选的，因为您可能希望使用fetch简单地检索所有记录。</p><p id="5680" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如何使用total和fetch:</p><pre class="lu lv lw lx fq mm ju mn mo aw mp dt"><span id="813c" class="mq kd hu ju b fv mr ms l mt mu">let total = modelController.total(Recipe.self)</span><span id="f227" class="mq kd hu ju b fv mv ms l mt mu">let predicate = NSPredicate(format: "name LIKE %@", "Fetcheroni Pizza")<br/>let fetched = modelController.fetch(Recipe.self, predicate: predicate)</span></pre><figure class="lu lv lw lx fq ly"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="70d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jr js jt ju b">ModelController+Save</code>相当标准。即使你没有使用核心数据抽象，你也很可能已经编写了一个<code class="eh jr js jt ju b">save()</code>方法来检查<code class="eh jr js jt ju b">hasChanges</code>并包装一个try/catch。</p><figure class="lu lv lw lx fq ly"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="0e6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后是<code class="eh jr js jt ju b">ModelController+Delete</code>。这里有两个删除方法——一个是fetch方法中使用的标准接口模式，传递类型和谓词来查找要删除的对象。</p><p id="aac3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个检查<code class="eh jr js jt ju b">NSManagedObjectID</code>，这是一个在删除核心数据对象时经常被忽略的问题。通过fetch访问对象并不能保证相同的对象会在访问它的同一线程上被删除，所以Apple推荐使用ID删除。由于这个原因，谓词方法也包装了<code class="eh jr js jt ju b">delete(by objectID:)</code>方法。</p><p id="4d87" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如何使用:</p><pre class="lu lv lw lx fq mm ju mn mo aw mp dt"><span id="f800" class="mq kd hu ju b fv mr ms l mt mu">modelController.delete(by: recipe.objectID)</span><span id="c250" class="mq kd hu ju b fv mv ms l mt mu">let predicate = NSPredicate(format: "name LIKE %@", "Deep Pan Pizza")<br/>modelController.delete(Recipe.self, predicate: predicate)</span></pre></div><div class="ab cl jv jw hc jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hn ho hp hq hr"><h1 id="2d55" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">线程处理</h1><p id="1ddd" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">使用<code class="eh jr js jt ju b">perform(_:) </code>和<code class="eh jr js jt ju b">performAndWait(_:)</code>都有好处。这两个函数都接受闭包，使您能够在与托管对象关联的正确线程上使用托管对象上下文。</p><p id="4930" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，这与使用<code class="eh jr js jt ju b">DispatchQueue.global()</code> <code class="eh jr js jt ju b">async(_:)</code>或<code class="eh jr js jt ju b">sync(_:)</code>略有不同，当然，虽然它们可能会在不同的线程上执行，但您不一定要启用上下文来将匹配到与相关联的<em class="jq">线程。</em></p><p id="67e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">回到<code class="eh jr js jt ju b">perform(_:)</code>和<code class="eh jr js jt ju b">performAndWait(_:)</code>，两者之间唯一的区别是<code class="eh jr js jt ju b">perform(_:)</code>继续执行流程。因此，在一个函数中，如果您出于某种原因想要返回值，而该返回值不依赖于任何异步操作，那么您可以使用<code class="eh jr js jt ju b">perform(_:)</code>继续执行并返回不基于该块的内容。</p><p id="4a41" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一方面，如果你的函数返回的内容依赖于块，你可以使用<code class="eh jr js jt ju b">performAndWait(_:)</code>来允许块在函数返回之前完成执行。这里更多的是<a class="ae jp" href="https://cocoacasts.com/more-core-data-and-concurrency" rel="noopener ugc nofollow" target="_blank">解释</a>。</p><p id="2822" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以采用<code class="eh jr js jt ju b">ModelController</code>中的任何一种方法，或者我们甚至可以采用一种组合。现在，我已经用<code class="eh jr js jt ju b">perform(_:)</code>方法更新了repo(上面的示例代码没有线程处理)，并添加了一个完成块作为函数参数，以允许通过完成继续执行(与使用<code class="eh jr js jt ju b">performAndWait(_:)</code>的返回方法相反)。</p><p id="c079" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我只是认为通过限制<code class="eh jr js jt ju b">performAndWait(_:)</code>的使用直到真正需要的时候，减少了阻塞主UI线程的机会。毕竟，<code class="eh jr js jt ju b">ModelController</code>和大多数好的抽象一样，不应该限制调用组件使用它的灵活性——由父对象决定是否阻塞主线程，而不是封装接口中的神秘盒子行为。</p><p id="04fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，保持提供<code class="eh jr js jt ju b">performAndWait(_:)</code>返回和<code class="eh jr js jt ju b">perform(_:)</code>完成块的灵活性需要付出一点代码清理的代价。出于这个原因，如果<code class="eh jr js jt ju b">ModelController</code>最终会将<code class="eh jr js jt ju b">performAndWait(_:)</code>行为添加到它的实现中，我想通过Max Howell的<a class="ae jp" href="https://github.com/mxcl/PromiseKit" rel="noopener ugc nofollow" target="_blank"> PromiseKit </a>来实现。这使用了JavaScript的承诺概念，以减少嵌套完成块的混乱，并传播错误处理。</p><p id="5e3e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jr js jt ju b">ModelController</code> repo目前也没有利用后台上下文，提供该功能将是下一个明显的实现。它不需要再吹了，这应该是一个非常简单和精简的可重用库，作为任何核心数据代码库的第一个调用点。我觉得可重用库是最好的方式，任何额外的功能都应该是该库的扩展，或者只是为正在工作的特定代码库定制的。否则它不会得到重用的<strong class="it hv"/>，这就是库的全部意义。</p></div><div class="ab cl jv jw hc jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hn ho hp hq hr"><h1 id="187a" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">接下来去哪里？</h1><p id="a17d" class="pw-post-body-paragraph ir is hu it b iu la iw ix iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo hn dt translated">我发现按照<code class="eh jr js jt ju b">EntityName.self</code>的思路将类型作为值来访问有点多余，而从一个优雅的API中一步就可以解决这个问题。我不确定这是否可能，但是如果您能够通过实现<code class="eh jr js jt ju b">StringLiteralConvertible</code>协议，为核心数据模型类型添加一个枚举，就像Benedikt Terhechte的博客文章中关于<a class="ae jp" href="https://appventure.me/2015/10/17/advanced-practical-enum-examples/" rel="noopener ugc nofollow" target="_blank">使用定制数据类型</a>的部分一样，那将会非常好。另一方面，这是与Swift中的<em class="jq">枚举</em>相关的所有内容的绝佳参考，我强烈推荐给它添加书签。</p><p id="4983" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最紧迫的问题是为后台托管对象上下文提供一个优雅且最小的接口。这可以通过在<code class="eh jr js jt ju b">ModelController</code>上的扩展或选项协议来完成，因为我认为拥有一个后台MOC是大多数开发人员在不需要它的情况下匆忙做的事情。</p><p id="8a43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jq">我还会在博客上更新FUMVC的更大概念，以及资源库可能会如何形成。</em></p></div></div>    
</body>
</html>