<html>
<head>
<title>Making Sense of Azure Durable Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Azure持久功能</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/making-sense-of-azure-durable-functions-645ecb3c1d58?source=collection_archive---------0-----------------------#2018-12-07">https://medium.com/hackernoon/making-sense-of-azure-durable-functions-645ecb3c1d58?source=collection_archive---------0-----------------------#2018-12-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f1557758a3e365c3a62f4f47ce89f867.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0R7Wy1EJa59bvMNMHJaM4A.jpeg"/></div></div></figure><p id="55e5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">无状态<a class="ae ka" href="https://hackernoon.com/tagged/serverless" rel="noopener ugc nofollow" target="_blank">无服务器</a>云函数之上的有状态工作流——这是Azure持久函数库的精髓。在一句话中有很多新奇的词语，对于大多数读者来说可能很难理解。</p><p id="4d0b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请和我一起踏上旅程，我会试着解释这些流行语是如何组合在一起的。我将分三步完成:</p><ul class=""><li id="8659" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">描述依赖无服务器架构的现代云应用的背景；</li><li id="8204" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">确定用简单的构件组成应用程序的基本方法的局限性；</li><li id="ed15" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">解释持久函数为这些问题提供的解决方案。</li></ul><h1 id="4eaf" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">微服务</h1><p id="890b" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">传统上，服务器端应用程序是以一种现在被称为<strong class="je hv"> Monolith </strong>的风格构建的。如果多个人和团队在开发同一个应用程序的一部分，他们大部分都贡献给了同一个代码库。如果代码库结构良好，它会有一些独特的模块或组件，一个团队通常会拥有每个模块:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ls"><img src="../Images/435137adc75e8fe6f0139eb4cc2e1a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CFQBecHCi9T1PT7T.png"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Multiple components of a monolithic application</figcaption></figure><p id="4a99" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通常，模块会在构建时打包在一起，然后作为一个单元部署，因此模块之间的大量通信会留在操作系统进程中。</p><p id="c9d9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽管随着时间的推移，模块可以保持松散耦合，但耦合几乎总是发生在数据存储层，因为所有团队都将使用单一的集中式数据库。</p><p id="928c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种模型非常适合中小型应用程序，但是随着应用程序的增长，团队开始妨碍彼此，因为贡献的同步需要越来越多的努力。</p><p id="9674" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为一种复杂但可行的替代方案，业界提出了一种经过修改的面向服务的方法，通常称为<strong class="je hv">微服务</strong>。团队将大型应用程序分成围绕不同业务功能构建的“垂直部分”:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/4562d0c05e4e64db6a80c4ffb2519dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*F_QRoGDOqU7aLM5S.png"/></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Multiple components of a microservice-based application</figcaption></figure><p id="2319" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，每个团队都拥有一个完整的垂直领域——从公共通信合同，甚至ui，一直到数据存储。强烈反对显式共享数据库。服务通过文档化和版本化的公共契约相互交流。</p><p id="b5e9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果拆分的边界选择得很好——这是最棘手的部分——合同会随着时间的推移保持稳定，并且足够薄以避免过多的闲聊。这给了每个团队足够的自主权，以他们最好的速度进行创新，并做出独立的技术决策。</p><p id="00db" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">微服务的一个弊端就是部署模式的改变。这些服务现在被部署到通过网络连接的不同服务器上:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/cf7bdef92e558471d3412c2cfc718860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/0*tjUKelljpLOouIAi.png"/></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Challenges of communication between distributed components</figcaption></figure><p id="a288" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">网络从根本上来说是不可靠的:它们大部分时间都工作得很好，但是当它们出现故障时，就会以各种不可预测和最不可取的方式出现故障。有一些书籍是以分布式系统架构为主题的。TL；大卫:这很难。</p><p id="643d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">许多微服务的新采用者倾向于忽略这种复杂性。HTTP(S)上的REST是连接微服务的主要方式。像任何其他同步通信协议一样，它使系统变得脆弱。</p><p id="e117" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">考虑当一个服务变得暂时不健康时会发生什么:可能它的数据库离线，或者它正在努力跟上请求负载，或者正在部署服务的新版本。对有问题的服务的所有请求开始失败——或者更糟——变得非常慢。从属服务等待响应，因此会阻塞所有自己的传入请求。错误会非常迅速地向上游传播，导致到处都是级联故障:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div class="fe ff md"><img src="../Images/ada428487c5271f1bb3bb2e0fb3fba5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*4upARdPiUuYv8JGu.png"/></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Error in one component causes cascading failures</figcaption></figure><p id="cc5c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">应用程序已关闭。每个人都尖叫着开始指责战争。</p><h1 id="c5ae" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">事件驱动的应用</h1><p id="8d36" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">虽然HTTP通信的级联故障可以通过断路器和适度降级等模式来缓解，但更好的解决方案是切换到异步通信方式作为默认方式。某种持久排队服务被用作中介。</p><p id="5b97" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基于在服务间发送事件的应用架构风格被称为<strong class="je hv">事件驱动</strong>。当一个服务做了一些有用的事情时，它会发布一个事件——一个关于其业务领域发生的事实的记录。另一个服务监听发布的事件，并根据这些事实执行自己的职责:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff me"><img src="../Images/be34c99e05106461cc21c12199b7f16e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0TpJcHKaM7wVK3Tl.png"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Communication in event-driven applications</figcaption></figure><p id="de3a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">产生事件的服务可能不了解消费者。随着时间的推移，可以引入新的事件订阅者。这在理论上比在实践中更有效，但是服务之间的耦合更少。</p><p id="a84c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更重要的是，如果一个服务关闭，其他服务不会立即着火。上游服务不断发布事件，这些事件在队列中累积，但可以安全地存储几个小时或几天。下游服务可能没有为这个特定的流做任何有用的事情，但是它可以保持健康。</p><p id="0b18" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，另一个潜在的问题伴随着松散耦合而来:低内聚。正如Martin Fowler在他的文章<a class="ae ka" href="https://martinfowler.com/articles/201701-event-driven.html" rel="noopener ugc nofollow" target="_blank">中注意到的，“事件驱动”是什么意思</a>:</p><blockquote class="mf"><p id="4d89" class="mg mh hu bd mi mj mk ml mm mn mo jz ek translated"><em class="mp">用事件通知很容易制造出良好解耦的系统，而不会意识到你忽略了更大规模的流程。</em></p></blockquote><p id="c552" class="pw-post-body-paragraph jc jd hu je b jf mq jh ji jj mr jl jm jn ms jp jq jr mt jt ju jv mu jx jy jz hn dt translated">鉴于许多组件发布和订阅大量事件类型，很容易只见树木不见森林。事件的组合通常构成按时间执行的渐进工作流。工作流不仅仅是其各个部分的总和，理解高层流程对于控制系统行为至关重要。</p><p id="4180" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">保持这个想法一分钟；我们过会儿将回到它。现在该说话了<em class="mv">云</em>。</p><h1 id="2ba3" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">云</h1><p id="3a98" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">公共云的诞生改变了我们设计应用的方式。它使许多事情变得更加简单:在几分钟而不是几个月内提供新资源，根据需求灵活扩展，以及全球范围的弹性和灾难恢复。</p><p id="8149" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这让其他事情变得更加复杂。下面是全球Azure网络的图片:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mw"><img src="../Images/0f33ffb24a48f62df0d3aec2e3ecf951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qR3hLIp9f_DxZk3E.png"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Azure locations with network connections</figcaption></figure><p id="2f9b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将应用程序部署到不止一个地理位置是有充分理由的:除其他外，通过靠近客户来减少网络延迟，以及通过地理冗余来实现弹性。公共云是最终的分布式系统。正如你所记得的，分布式系统是很难的。</p><p id="eed3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有更多。每个云提供商都有几十个托管服务，这是祸也是福。专业化服务非常适合为常见的复杂问题提供现成的解决方案。另一方面，每种服务在一致性、弹性和容错方面都有不同的属性。</p><p id="76c7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我看来，在这一点上，开发人员必须接受公共云，并在其上应用分布式系统设计。如果你同意，有一个很好的方法可以接近它。</p><h1 id="351f" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">无服务器</h1><p id="b610" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">略带挑衅意味的术语<strong class="je hv">无服务器</strong>用于描述不需要供应虚拟机、实例、工作人员或任何其他固定容量来运行定制应用的云服务。资源以动态、透明的方式分配，成本基于其实际消耗，而不是基于预先购买的容量。</p><p id="9587" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">无服务器更多的是关于系统的操作和经济属性，而不是技术本身。服务器确实存在，但它们是别人的事。您不需要管理无服务器应用的正常运行时间，而是由云提供商来管理。</p><p id="d47a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最重要的是，你要为你使用的东西付费，类似于电力等其他商品资源的消耗。你可以从电力公司购买能源，而不是购买发电机来为你的房子供电。您会失去一些控制(例如，无法选择电压)，但这在大多数情况下是没问题的。最大的好处是不需要购买和维护硬件。</p><p id="bbdd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">无服务器计算做同样的事情:它在按使用付费的基础上提供标准服务。</p><p id="c498" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们更具体地谈论像Azure Functions这样的功能即服务产品，它们提供了在云中运行小块代码的标准模型。你压缩代码或二进制文件，然后发送到Azure微软负责运行它所需的所有硬件和软件。基础架构会根据需求自动扩展或缩减，您需要为应用程序消耗的每个请求、CPU时间和内存付费。没有使用-没有账单。</p><p id="8513" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，总有“但是”。FaaS服务带有应用程序必须遵循的自以为是的开发模型:</p><ul class=""><li id="02cc" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated"><strong class="je hv">事件驱动</strong>:对于每个无服务器的函数，你必须定义一个特定的触发器——导致它运行的事件类型，可以是HTTP端点，也可以是队列消息；</li><li id="06a7" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><strong class="je hv">短命</strong>:功能最多只能运行几分钟，最好是几秒钟或者更短；</li><li id="465e" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><strong class="je hv">无状态</strong>:由于您无法控制何时何地提供或取消提供功能实例，因此无法在请求之间的流程中可靠地存储数据；必须利用外部存储器。</li></ul><p id="810d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">坦率地说，大多数现有的应用程序并不适合这种模式。如果你幸运地开发了一个新的应用程序(或者它的一个新模块)，你的状态会更好。</p><p id="faf5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">许多无服务器应用程序的设计可能看起来有点类似于这个来自<a class="ae ka" href="https://www.serverless360.com/blog/building-reactive-solution-with-azure-event-grid" rel="noopener ugc nofollow" target="_blank">无服务器360博客</a>的例子:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mx"><img src="../Images/856ea0a8e71ff223c63a16f78e93b42e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IYkIaSucLIoykh9H.png"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Sample application utilizing “serviceful” serverless architecture</figcaption></figure><p id="6c3b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个应用程序中有9个托管Azure服务协同工作。它们中的大多数都有独特的用途，但服务都是用Azure函数粘合在一起的。一个图像被上传到Blob存储，一个Azure函数调用Vision API来识别车牌并将结果发送到事件网格，另一个Azure函数将该事件放入Cosmos DB，等等。</p><p id="a562" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种风格的云应用有时被称为<strong class="je hv"> Serviceful </strong>，以强调由无服务器功能“粘合”在一起的托管服务的大量使用。</p><p id="6845" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在没有任何托管服务的情况下创建一个类似的应用程序将是一项非常困难的任务，如果该应用程序必须大规模运行，情况就更是如此。此外，在自助服务的世界里，没有办法保持现收现付的定价模式。</p><p id="e0a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上图所示的应用程序仍然非常简单。企业应用程序中的流程通常要复杂得多。</p><p id="cd20" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还记得马丁·福勒关于忽视大规模流动的引用吗？对于微服务来说是这样，但对于云功能的“纳米服务”来说更是如此。</p><p id="c9ab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我想深入一点，举几个相关问题的例子。</p><h1 id="8577" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">无服务器组合的挑战</h1><p id="08e2" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">在本文的其余部分，我将定义一个假想的业务应用程序，用于预订软件会议的行程。为了参加会议，我需要购买会议本身的门票，购买机票，并在酒店预订房间。</p><p id="f251" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个场景中，创建三个Azure函数是有意义的，每个函数负责预订过程的一个步骤。由于我们更喜欢消息传递，每个函数都发出一个事件，下一个函数可以监听该事件:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff me"><img src="../Images/dfee9cb0ab90d3303cf147bb548873dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OXQeZYtX2BkcUOgH.png"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Conference booking application</figcaption></figure><p id="8ae4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种方法是可行的，但是也存在问题。</p><h2 id="77ce" class="my kq hu bd kr mz na nb kv nc nd ne kz jn nf ng ld jr nh ni lh jv nj nk ll nl dt translated">灵活排序</h2><p id="8cfa" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">由于我们需要按顺序执行整个预订过程，Azure函数通过配置一个函数的输出以匹配下游函数的事件源而一个接一个地连接起来。</p><p id="a6d2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上图中，函数的顺序是硬定义的。如果我们要交换预订航班和预订酒店的顺序，这将需要更改代码——至少是输入/输出连接定义，但也可能是函数的参数类型。</p><p id="382e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这种情况下，函数<em class="mv">真的</em>解耦了吗？</p><h2 id="2740" class="my kq hu bd kr mz na nb kv nc nd ne kz jn nf ng ld jr nh ni lh jv nj nk ll nl dt translated">错误处理</h2><p id="dfe4" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">如果预订航班功能变得不正常，可能是由于第三方航班预订服务中断，会发生什么情况？嗯，这就是我们使用异步消息传递的原因:在函数执行失败后，消息返回到队列，并被另一个执行再次拾取。</p><p id="09fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，对于大多数事件源，这种重试几乎会立即发生。这可能不是我们想要的:指数后退政策可能是一个更聪明的想法。此时，重试逻辑变为<strong class="je hv">状态</strong>:下一次尝试应该“知道”先前尝试的历史，以决定重试时间。</p><p id="6f5d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有更高级的错误处理模式。如果执行失败不是间歇性的，我们可以决定取消整个过程，并对已经完成的步骤运行补偿操作。</p><p id="9cf4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种情况的一个例子是回退动作:如果航班是不可能的(例如，对于这个起点-目的地组合没有路线)，则流程可以改为选择预订火车:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div class="fe ff nm"><img src="../Images/93cca3c9a45fe6ef734d486788ded017.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/0*LHk9MNdE3hxdsvn9.png"/></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Fallback after 3 consecutive failures</figcaption></figure><p id="578f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用无状态函数实现这个场景并不容易。我们可以等到消息进入死信队列，然后从那里路由它，但是这很脆弱，不够有表现力。</p><h2 id="7471" class="my kq hu bd kr mz na nb kv nc nd ne kz jn nf ng ld jr nh ni lh jv nj nk ll nl dt translated">平行动作</h2><p id="71f7" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">有时，业务流程不一定是连续的。在我们的预订场景中，我们先预订航班再预订酒店可能没有区别，反之亦然。可能需要并行运行这些操作。</p><p id="eca7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过事件总线的发布-订阅功能，动作的并行执行变得很容易:两个函数应该订阅同一个事件，并独立地对其进行操作。</p><p id="1900" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们需要协调并行操作的结果时，问题就来了，例如，为了费用报告的目的计算最终价格:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nn"><img src="../Images/603a2cb2b9b9370b6a070710999b20d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ttYZoECU_Qorq5EH.png"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Fan-out / fan-in pattern</figcaption></figure><p id="c849" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">没有办法将Report Expenses块实现为一个Azure函数:函数不能被两个事件触发，更不用说关联两个与<em class="mv">相关的</em>事件了。</p><p id="8cb5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该解决方案可能包括两个函数，每个事件一个，以及它们之间的共享存储，以将关于第一个完成的预订的信息传递给最后一个完成的预订。所有这些连接都必须在自定义代码中实现。如果需要并行运行两个以上的函数，复杂性就会增加。</p><p id="0242" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，不要忘记边缘案例。如果其中一个功能失效了怎么办？当读写共享存储时，如何确保没有竞争情况？</p><h2 id="277e" class="my kq hu bd kr mz na nb kv nc nd ne kz jn nf ng ld jr nh ni lh jv nj nk ll nl dt translated">失踪的管弦乐手</h2><p id="3775" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">所有这些例子都给了我们一个提示，我们需要一个额外的工具来将低级的单一用途的独立功能组织成高级的工作流。</p><p id="57f5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样的工具可以被称为<strong class="je hv"> Orchestrator </strong>，因为它的唯一使命是将工作委托给无状态的动作，同时维护流程的全局和历史。</p><p id="432f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Azure Durable Functions旨在提供这样一个工具。</p><h1 id="82a8" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">Azure持久功能介绍</h1><h2 id="4eb8" class="my kq hu bd kr mz na nb kv nc nd ne kz jn nf ng ld jr nh ni lh jv nj nk ll nl dt translated">Azure函数</h2><p id="6d55" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">Azure Functions是微软的无服务器计算服务。函数是事件驱动的:每个函数定义一个<strong class="je hv">触发器</strong>——事件源的确切定义，例如，存储队列的名称。</p><p id="2e43" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Azure功能可以用<a class="ae ka" href="https://docs.microsoft.com/en-us/azure/azure-functions/supported-languages" rel="noopener ugc nofollow" target="_blank">几种语言</a>编程。用C#实现的带有<a class="ae ka" href="https://docs.microsoft.com/azure/azure-functions/functions-bindings-storage-queue" rel="noopener ugc nofollow" target="_blank">存储队列触发器</a>的基本函数如下所示:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="no np l"/></div></figure><p id="273c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh nq nr ns nt b">FunctionName</code>属性将C#静态方法公开为一个名为<code class="eh nq nr ns nt b">MyFirstFunction</code>的Azure函数。<code class="eh nq nr ns nt b">QueueTrigger</code>属性定义了要监听的存储队列的名称。函数体记录关于传入消息的信息。</p><h2 id="ffc3" class="my kq hu bd kr mz na nb kv nc nd ne kz jn nf ng ld jr nh ni lh jv nj nk ll nl dt translated">持久功能</h2><p id="3763" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated"><a class="ae ka" href="https://docs.microsoft.com/azure/azure-functions/durable/durable-functions-overview" rel="noopener ugc nofollow" target="_blank">持久功能</a>是一个将工作流编排抽象引入Azure功能的库。它引入了许多习惯用法和工具来定义有状态的、可能长期运行的操作，并在幕后管理许多可靠的通信和状态管理机制。</p><p id="ac10" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该库记录了Azure存储服务中所有操作的历史，实现了对故障的持久性和弹性。</p><p id="6d0a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">耐久功能<a class="ae ka" href="https://github.com/Azure/azure-functions-durable-extension" rel="noopener ugc nofollow" target="_blank">开源</a>，微软接受外部贡献，社区相当活跃。</p><p id="1df6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">目前，您可以用3种编程语言编写持久函数:C#、F#和Javascript (Node.js)。我所有的例子都是用C#写的。对于Javascript，检查<a class="ae ka" href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/quickstart-js-vscode" rel="noopener ugc nofollow" target="_blank">这个快速入门</a>和<a class="ae ka" href="https://github.com/Azure/azure-functions-durable-extension/tree/master/samples/javascript" rel="noopener ugc nofollow" target="_blank">这些示例</a>。关于F#请参见<a class="ae ka" href="https://github.com/Azure/azure-functions-durable-extension/tree/master/samples/fsharp" rel="noopener ugc nofollow" target="_blank">示例</a>、<a class="ae ka" href="https://github.com/mikhailshilkov/DurableFunctions.FSharp" rel="noopener ugc nofollow" target="_blank">特定于F#的库</a>和我的文章<a class="ae ka" href="https://hackernoon.com/a-fairy-tale-of-f-and-durable-functions-975ccc4d46b8" rel="noopener ugc nofollow" target="_blank">F #和持久函数的童话</a>。</p><p id="8e44" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">工作流构建功能是通过引入另外两种类型的触发器来实现的:活动函数和编制器函数。</p><h2 id="9776" class="my kq hu bd kr mz na nb kv nc nd ne kz jn nf ng ld jr nh ni lh jv nj nk ll nl dt translated">活动功能</h2><p id="51b7" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">活动功能是简单的无状态、单一用途的构建块，只完成一项任务，不知道更大的工作流。引入了一个新的触发器类型<code class="eh nq nr ns nt b">ActivityTrigger</code>，以将功能公开为工作流步骤，如下所述。</p><p id="0c57" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是一个用C#实现的简单活动函数:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="no np l"/></div></figure><p id="fe34" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它有一个公共的<code class="eh nq nr ns nt b">FunctionName</code>属性，将C#静态方法公开为一个名为<code class="eh nq nr ns nt b">BookConference</code>的Azure函数。这个名称很重要，因为它用于从orchestrators调用活动。</p><p id="8647" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh nq nr ns nt b">ActivityTrigger</code>属性定义了触发器类型，并指向输入参数<code class="eh nq nr ns nt b">conference</code>，活动希望每次调用都能得到这个参数。</p><p id="ab01" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该函数可以返回任何可序列化类型的结果；我的示例函数返回一个名为<code class="eh nq nr ns nt b">ConfTicket</code>的简单属性包。</p><p id="c377" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">活动函数几乎可以做任何事情:调用其他服务，从数据库加载数据和将数据保存到数据库，以及使用任何。网络图书馆。</p><h2 id="ebd5" class="my kq hu bd kr mz na nb kv nc nd ne kz jn nf ng ld jr nh ni lh jv nj nk ll nl dt translated">Orchestrator函数</h2><p id="ef7f" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">Orchestrator函数是持久函数引入的一个独特概念。它的唯一目的是管理几个活动功能之间的执行流和数据流。</p><p id="1ec3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">其最基本的形式是将多个独立的活动链接成一个单一的顺序工作流。</p><p id="5281" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们从一个例子开始，这个例子一个接一个地预订会议票、航班路线和酒店房间:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div class="fe ff nu"><img src="../Images/c11b056dbd4f378b3ae703a1e55e4e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-jkfa0D_3tgFmSFT.png"/></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">3 steps of a workflow executed in sequence</figcaption></figure><p id="0c7e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个工作流的实现是由另一个C# Azure函数定义的，这次是用<code class="eh nq nr ns nt b">OrchestrationTrigger</code>:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="no np l"/></div></figure><p id="64b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同样，属性用于描述Azure运行时的功能。</p><p id="407d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">唯一的输入参数的类型为<code class="eh nq nr ns nt b">DurableOrchestrationContext</code>。这个上下文是支持编排操作的工具。</p><p id="0b4c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">特别是，<code class="eh nq nr ns nt b">CallActivityAsync</code>方法被使用了三次，一个接一个地调用三个活动。对于任何使用基于<code class="eh nq nr ns nt b">Task</code>的API的C#代码来说，方法体看起来都非常典型。然而，行为完全不同。我们来看看实现细节。</p><h1 id="6758" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">在幕后</h1><p id="5331" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">让我们浏览一下上面顺序工作流的一次执行的生命周期。</p><p id="49b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当orchestrator开始运行时，第一个<code class="eh nq nr ns nt b">CallActivityAsync</code>调用是预订会议票。这里实际发生的是一个队列消息从orchestrator发送到activity函数。</p><p id="bba1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">队列消息触发相应的活动函数。它完成它的工作(订票)并返回结果。activity函数序列化结果，并将其作为队列消息发送回orchestrator:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff me"><img src="../Images/4bab9b0d9fee37978795f9149087eaae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*phZ_vofCXaaaAfUf.png"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Messaging between the orchestrator and the activity</figcaption></figure><p id="4e15" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当消息到达时，orchestrator再次被触发，可以继续执行第二个活动。循环往复——消息被发送到预订航班活动，它被触发，完成它的工作，然后将消息发送回编排器。同样的消息流发生在第三次调用中。</p><h2 id="ec61" class="my kq hu bd kr mz na nb kv nc nd ne kz jn nf ng ld jr nh ni lh jv nj nk ll nl dt translated">停止-恢复行为</h2><p id="f197" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">如前所述，消息传递旨在及时分离发送方和接收方。对于上面场景中的每条消息，都不期望立即得到响应。</p><p id="ff9a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在C#级别，当执行<code class="eh nq nr ns nt b">await</code>操作符时，代码不会阻塞整个orchestrator的执行。相反，它只是退出:orchestrator停止活动，其当前步骤完成。</p><p id="ed0d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每当活动返回消息时，orchestrator代码就会重新启动。它总是从第一行开始。是的，这意味着同一行被执行多次:直到发送给orchestrator的消息数。</p><p id="4e42" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，orchestrator将其过去执行的历史存储在Azure存储中，因此第一行的第二次传递的效果是不同的:它不是向活动发送消息，而是已经知道该活动的结果，因此<code class="eh nq nr ns nt b">await</code>返回该结果并将其分配给<code class="eh nq nr ns nt b">conference</code>变量。</p><p id="66ca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于这些“重放”，编排器的实现必须是确定性的:不要使用<code class="eh nq nr ns nt b">DateTime.Now</code>、随机数或多线程操作；更多详情<a class="ae ka" href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-checkpointing-and-replay#orchestrator-code-constraints" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><h2 id="f4ee" class="my kq hu bd kr mz na nb kv nc nd ne kz jn nf ng ld jr nh ni lh jv nj nk ll nl dt translated">活动采购</h2><p id="de1c" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">Azure函数是无状态的，而工作流需要一个状态来跟踪它们的进度。每当执行工作流的新动作发生时，框架会自动在表存储中记录一个事件。</p><p id="7cc7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每当orchestrator因为新消息从其活动到达而重新开始执行时，它就从存储中加载这个特定执行的完整历史。持久上下文使用此历史来决定是调用活动还是返回先前存储的结果。</p><p id="4beb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将状态更改的完整历史存储为只附加事件存储的模式称为事件源。事件存储提供了几个好处:</p><ul class=""><li id="84cc" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated"><strong class="je hv">持久性</strong> —如果运行编排的主机出现故障，历史记录将保留在永久存储器中，并由重新开始编排的新主机加载；</li><li id="85d1" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><strong class="je hv">可扩展性</strong> —仅附加写入快速且易于分布在多个存储服务器上；</li><li id="6fce" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><strong class="je hv">可观察性</strong> —不会丢失任何历史记录，因此即使在工作流程完成后也可以直接进行检查和分析。</li></ul><p id="9671" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是在我们的连续工作流程中记录的值得注意的事件:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nn"><img src="../Images/12f5c58f5482fe369443a9740bad30cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HxbVY79xYM5yL8-7.png"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Log of events in the course of orchestrator progression</figcaption></figure><h2 id="e66e" class="my kq hu bd kr mz na nb kv nc nd ne kz jn nf ng ld jr nh ni lh jv nj nk ll nl dt translated">演员表</h2><p id="c93a" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">基于无服务器消费的计划上的Azure功能按执行+执行持续时间计费。</p><p id="69df" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">持久编制器的停止-重放行为导致单个工作流“实例”多次执行相同的编制器功能。这也意味着要为几次短暂的执行付出代价。</p><p id="4d68" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，与阻塞对活动的同步调用的潜在成本相比，总费用通常要低得多。每次100毫秒的5次执行的价格明显低于30秒的1次执行的成本。</p><p id="6af7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">顺便说一下，每月的第一个百万次执行是免费的，所以很多情况下Azure Functions服务不会产生任何费用。</p><p id="32fa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个需要记住的成本是Azure存储。后台使用的队列和表格向最终客户收费。根据我的经验，对于低负载到中等负载的应用程序，这个费用接近于零。</p><p id="7aa3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当心你的编排器中无意的永恒循环或不确定的递归扇出。如果你让它们失去控制，它们会变得很贵。</p><h1 id="194c" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">错误处理和重试</h1><p id="0f1e" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">当工作流中间某处发生错误时会发生什么？例如，第三方航班预订服务可能无法处理该请求:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div class="fe ff nv"><img src="../Images/b4f00d7f41396fbc74540be0b9d9fbf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/0*_ALxqiDdJlcwNzhw.png"/></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">One activity is unhealthy</figcaption></figure><p id="2699" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种情况是持久函数所期望的。activity函数不会无声无息地失败，而是将包含错误信息的消息发送回orchestrator。</p><p id="8336" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">orchestrator反序列化错误详细信息，并在重放时从相应的调用中抛出一个. NET异常。开发人员可以自由地在调用周围放置一个<code class="eh nq nr ns nt b">try .. catch</code>块并处理异常:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="no np l"/></div></figure><p id="4bf1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的代码是预订另一个旅程的“备用计划”。另一个典型的模式是运行一个补偿活动来取消任何先前操作的影响(在我们的例子中是取消会议预订),并使系统保持干净的状态。</p><p id="11a5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通常，错误可能是暂时的，因此暂停后重试失败的操作可能是有意义的。持久函数提供了一个专用的API，这是一个非常常见的场景:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="no np l"/></div></figure><p id="c515" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的代码指示库</p><ul class=""><li id="580b" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">最多重试5次</li><li id="b611" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">在第一次重试前等待1分钟</li><li id="be6e" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">在每次后续重试之前，将延迟增加2倍(1分钟、2分钟、4分钟等。)</li></ul><p id="f3f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">重要的一点是，orchestrator在等待重试时不会阻塞。呼叫失败后，将在<a class="ae ka" href="https://hackernoon.com/tagged/future" rel="noopener ugc nofollow" target="_blank">未来</a>时刻安排一条消息，以重新运行编排器并重试呼叫。</p><h1 id="242b" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">副指挥</h1><p id="93ce" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">业务流程可能由许多步骤组成。为了使编排器的代码易于管理，持久函数允许嵌套编排器。“父”编制器可以通过<code class="eh nq nr ns nt b">context.CallSubOrchestratorAsync</code>方法调用子编制器:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="no np l"/></div></figure><p id="c8fd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的代码预定了两个会议，一个接一个。</p><h1 id="cbf6" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">扇出/扇入</h1><p id="7622" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">如果我们想并行运行多个活动呢？</p><p id="8732" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，在上面的例子中，我们可能希望预订两个会议，但是预订顺序可能无关紧要。尽管如此，当两个预订都完成后，我们希望将结果结合起来，为财务部门生成一个费用报告:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div class="fe ff nw"><img src="../Images/4285ad3fb8f5d8df476df2b9fdf79cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/0*mz-N-Bvummi_uyYz.png"/></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Parallel calls followed by a final step</figcaption></figure><p id="684f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个场景中，<code class="eh nq nr ns nt b">BookTrip</code> orchestrator接受一个带有会议名称的输入参数，并返回费用信息。<code class="eh nq nr ns nt b">ReportExpenses</code>需要接收两项费用的总和。</p><p id="4da9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个目标可以通过调度两个任务(即发送两个消息)而不用分别等待它们来容易地实现。我们使用熟悉的<code class="eh nq nr ns nt b">Task.WhenAll</code>方法来等待两者并合并结果:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="no np l"/></div></figure><p id="acda" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">记住，等待<code class="eh nq nr ns nt b">WhenAll</code>方法不会同步阻塞orchestrator。它第一次退出，然后在收到来自活动的回复消息时重新启动两次。第一次重启再次退出，只有第二次重启才能通过<code class="eh nq nr ns nt b">await</code>。</p><p id="c669" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh nq nr ns nt b">Task.WhenAll</code>返回结果数组(每个输入任务一个结果)，然后传递给报告活动。</p><p id="9686" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">并行化的另一个例子是向数百个收件人发送电子邮件的工作流。对于普通的队列触发函数来说，这样的扇出并不难:只需发送数百条消息。然而，如果工作流程的下一步需要，合并结果是相当具有挑战性的。</p><p id="e928" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于耐用的orchestrator来说很简单:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="no np l"/></div></figure><p id="a7f5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在活动之间往返数百次可能会导致orchestrator的多次重放。作为一种优化，如果多个活动功能几乎同时完成，orchestrator可以在内部成批处理几个消息，并且每批只重新启动orchestrator功能一次。</p><h1 id="f9bb" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">其他概念</h1><p id="276b" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">持久函数支持更多的模式。下面是一个快速列表，可以让你了解一些情况:</p><ul class=""><li id="0952" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">等待集合中的第<em class="mv">个</em>完成任务(而不是他们中的<em class="mv">个</em>)使用<code class="eh nq nr ns nt b">Task.WhenAny</code>方法。适用于超时或竞争动作等情况。</li><li id="7b83" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">暂停工作流一段时间或直到截止日期。</li><li id="83c7" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">等待外部事件，例如，将人工交互引入工作流。</li><li id="5ed6" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">运行循环工作流，此时流程重复，直到满足特定条件。</li></ul><p id="82c4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">进一步的解释和代码示例在<a class="ae ka" href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-overview" rel="noopener ugc nofollow" target="_blank">文档</a>中。</p><h1 id="8a73" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">结论</h1><p id="0b45" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">我坚信，由于快速的开发流程和适当的计费模式，利用广泛的托管云服务的无服务器应用程序对许多公司都非常有益。</p><p id="728a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">无服务器技术还很年轻；需要出现更多的高级架构模式来实现大型业务系统的可表达和可组合的实现。</p><p id="95c4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Azure Durable Functions给出了一些可能的答案。它将顺序RPC风格代码的清晰性和可读性与事件驱动架构的强大功能和弹性结合在一起。</p><p id="72ad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关于持久功能的文档非常好，有大量的例子和操作指南。了解它，在您的真实生活场景中尝试它，并让我知道您的意见——我对无服务器的未来感到兴奋！</p><h1 id="aaae" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">感谢</h1><p id="6250" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">非常感谢<a class="ae ka" href="https://twitter.com/kashimizMSFT" rel="noopener ugc nofollow" target="_blank">凯蒂·清水</a>、<a class="ae ka" href="https://twitter.com/cgillum" rel="noopener ugc nofollow" target="_blank">克里斯·吉勒姆</a>、<a class="ae ka" href="https://twitter.com/efleming18" rel="noopener ugc nofollow" target="_blank">埃里克·弗莱明</a>、<a class="ae ka" href="https://twitter.com/KevinJonesD" rel="noopener ugc nofollow" target="_blank">KJ·琼斯</a>、<a class="ae ka" href="https://twitter.com/William_DotNet" rel="noopener ugc nofollow" target="_blank">威廉·利本伯格</a>、<a class="ae ka" href="https://twitter.com/ATosato86" rel="noopener ugc nofollow" target="_blank">安德里亚·托萨托</a>审阅本文草稿并提出宝贵的意见和建议。围绕Azure函数和持久函数的社区棒极了！</p></div><div class="ab cl nx ny hc nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="hn ho hp hq hr"><p id="2d75" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mv">最初发表于</em><a class="ae ka" href="https://mikhail.io/2018/12/making-sense-of-azure-durable-functions/" rel="noopener ugc nofollow" target="_blank"><em class="mv">Mikhail . io</em></a><em class="mv">。</em></p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="oe np l"/></div></figure></div></div>    
</body>
</html>