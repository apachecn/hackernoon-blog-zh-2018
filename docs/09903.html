<html>
<head>
<title>ActiveRecord on MySQL— Iterating over large tables with conditions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MySQL上的ActiveRecord使用条件迭代大型表</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/activerecord-on-mysql-iterating-over-large-tables-with-conditions-453bd8761c8b?source=collection_archive---------3-----------------------#2018-12-09">https://medium.com/hackernoon/activerecord-on-mysql-iterating-over-large-tables-with-conditions-453bd8761c8b?source=collection_archive---------3-----------------------#2018-12-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="ea76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本文中，我将展示在一个包含数百万条记录的MySQL数据库表中迭代记录的两种方法之间的性能差异。在大容量分析系统中，包含数百万条记录的表非常常见，迭代整个表或这些表的子集经常是必要的，无论是执行计算、运行迁移还是对记录创建并行后台作业。在<a class="ae jp" href="https://www.airpr.com/" rel="noopener ugc nofollow" target="_blank"> AirPR </a>，我们有许多包含数亿条记录的数据库表，编写高效的迭代代码变得非常重要，因为好的和不太好的方法之间往往存在数量级的差异。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="62c4" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated"><strong class="ak">找到每个方法</strong></h1><p id="ac74" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">ActiveRecord本身提供的标准方法是<code class="eh la lb lc ld b">find_each</code>方法。</p><p id="ef24" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">出于本练习的目的，我创建了一个<code class="eh la lb lc ld b">employees</code>表，向其中添加了大约500万行数据。</p><figure class="lf lg lh li fq lj fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff le"><img src="../Images/60a658d68f363fa886ad2246ff55bc3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZVxd0g85DK_AiHSym6CtNA.png"/></div></div></figure><p id="17ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有一个包含以下各列的<code class="eh la lb lc ld b">salaries </code>表，它存储了不同时间范围内那些雇员的工资。该表包含大约300万条记录。</p><figure class="lf lg lh li fq lj fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff lq"><img src="../Images/0777567c3b649205fc394fd82bde848b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-IIf_gz9hMiTybaEi3ZSXw.png"/></div></div></figure><p id="10ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们使用<code class="eh la lb lc ld b">find_each</code>来测量遍历这个表的性能</p><pre class="lf lg lh li fq lr ld ls lt aw lu dt"><span id="7414" class="lv jy hu ld b fv lw lx l ly lz">DEFAULT_BATCH_SIZE = 1000</span><span id="2423" class="lv jy hu ld b fv ma lx l ly lz">time = Benchmark.realtime do<br/>  Employee.select(:emp_no, :first_name, :last_name).<br/>           find_each(batch_size: DEFAULT_BATCH_SIZE) do |employee|<br/>  end<br/>end</span><span id="de96" class="lv jy hu ld b fv ma lx l ly lz">=&gt; 100.6963519999990</span></pre><p id="40b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">ActiveRecord生成的底层查询如下所示:</p><pre class="lf lg lh li fq lr ld ls lt aw lu dt"><span id="04e3" class="lv jy hu ld b fv lw lx l ly lz">Employee Load (2.1ms)  SELECT  `employees`.`emp_no`, `employees`.`first_name`, `employees`.`last_name` FROM `employees`  ORDER BY `employees`.`emp_no` ASC LIMIT 1000<br/>  Employee Load (1.9ms)  SELECT  `employees`.`emp_no`, `employees`.`first_name`, `employees`.`last_name` FROM `employees` WHERE (`employees`.`emp_no` &gt; 11000)  ORDER BY `employees`.`emp_no` ASC LIMIT 1000<br/>  Employee Load (1.8ms)  SELECT  `employees`.`emp_no`, `employees`.`first_name`, `employees`.`last_name` FROM `employees` WHERE (`employees`.`emp_no` &gt; 12000)  ORDER BY `employees`.`emp_no` ASC LIMIT 1000<br/><br/>...</span><span id="5005" class="lv jy hu ld b fv ma lx l ly lz">Employee Load (1.3ms)  SELECT  `employees`.`emp_no`, `employees`.`first_name`, `employees`.`last_name` FROM `employees` WHERE (`employees`.`emp_no` &gt; 5127997)  ORDER BY `employees`.`emp_no` ASC LIMIT 1000</span></pre><p id="2e7c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意ActiveRecord是如何跟踪上一次迭代中的<code class="eh la lb lc ld b">id</code>,并在下一次迭代的where条件中使用它的。这称为基于值的分页，通常是分页的首选方法(优于其他方法，如基于偏移量的分页)。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="bb71" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">ID迭代器方法</h1><p id="bd9a" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">我建议我们现在尝试一种不同的迭代技术:</p><pre class="lf lg lh li fq lr ld ls lt aw lu dt"><span id="ed27" class="lv jy hu ld b fv lw lx l ly lz">time = Benchmark.realtime do<br/>  first_id = Employee.first.id<br/>  last_id = Employee.last.id<br/>  (first_id..last_id).step(DEFAULT_BATCH_SIZE).each do |value|</span><span id="02ba" class="lv jy hu ld b fv ma lx l ly lz">    Employee.where('employees.emp_no &gt;= ?', value).<br/>         where('employees.emp_no &lt; ?', value + DEFAULT_BATCH_SIZE).<br/>         order('employees.emp_no ASC').<br/>         select(:emp_no, :first_name, :last_name).each do |employee|<br/>    end</span><span id="c611" class="lv jy hu ld b fv ma lx l ly lz">  end<br/>end</span><span id="523b" class="lv jy hu ld b fv ma lx l ly lz">=&gt; 101.34066200000234</span></pre><p id="3801" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个方法中，我们使用主键上的<code class="eh la lb lc ld b">where</code>条件将总行数分成若干批，以遍历表中的所有记录。请注意，这两种方法的性能几乎是一样的。下面是基本查询的外观:</p><pre class="lf lg lh li fq lr ld ls lt aw lu dt"><span id="32ee" class="lv jy hu ld b fv lw lx l ly lz">Employee Load (1.1ms)  SELECT  `employees`.* FROM `employees`  ORDER BY `employees`.`emp_no` ASC LIMIT 1<br/>  Employee Load (1.1ms)  SELECT  `employees`.* FROM `employees`  ORDER BY `employees`.`emp_no` DESC LIMIT 1<br/>  Employee Load (1.5ms)  SELECT `employees`.`emp_no`, `employees`.`first_name`, `employees`.`last_name` FROM `employees` WHERE (employees.emp_no &gt; 10001) AND (employees.emp_no &lt;= 11001)<br/>  Employee Load (1.9ms)  SELECT `employees`.`emp_no`, `employees`.`first_name`, `employees`.`last_name` FROM `employees` WHERE (employees.emp_no &gt; 11001) AND (employees.emp_no &lt;= 12001)</span><span id="aec9" class="lv jy hu ld b fv ma lx l ly lz">...</span><span id="4f9d" class="lv jy hu ld b fv ma lx l ly lz">Employee Load (1.8ms)  SELECT `employees`.`emp_no`, `employees`.`first_name`, `employees`.`last_name` FROM `employees` WHERE (employees.emp_no &gt;= 5128001) AND (employees.emp_no &lt; 5129001)</span></pre><p id="1208" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果id是有序的，这种方法效果最好，因为在这种情况下，迭代不必迭代&amp;跳过许多缺失的记录。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="14e5" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">使用连接进行迭代</h1><p id="f672" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">现在，让我们比较一下当我们给查询增加一些复杂性时这两种方法的性能。</p><p id="3f4c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个新的场景中，比方说，我们想要遍历在公司任职期间任何时候工资都在80，000以上的所有员工。<code class="eh la lb lc ld b">find_each</code>方法看起来像这样:</p><pre class="lf lg lh li fq lr ld ls lt aw lu dt"><span id="6d6c" class="lv jy hu ld b fv lw lx l ly lz">time = Benchmark.realtime do<br/>  Employee.select(:emp_no, :first_name, :last_name).<br/>            joins(:salaries).<br/>            where('salary &gt; 80000').<br/>            find_each(batch_size: DEFAULT_BATCH_SIZE) do |employee|<br/>  end<br/>end</span><span id="bc61" class="lv jy hu ld b fv ma lx l ly lz">=&gt; 1181.770457000006</span></pre><p id="473a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一方面，用于执行相同操作的id迭代器方法导致了一个数量级的性能提升。</p><pre class="lf lg lh li fq lr ld ls lt aw lu dt"><span id="468d" class="lv jy hu ld b fv lw lx l ly lz">time = Benchmark.realtime do</span><span id="0cbd" class="lv jy hu ld b fv ma lx l ly lz">first_id = Employee.first.id<br/>  last_id = Employee.last.id</span><span id="571f" class="lv jy hu ld b fv ma lx l ly lz">(first_id..last_id).step(DEFAULT_BATCH_SIZE).each do |value|<br/>    Employee.where('employees.emp_no &gt;= ?', value).<br/>         where('employees.emp_no &lt; ?', value + DEFAULT_BATCH_SIZE).<br/>         joins(:salaries).<br/>         where('salary &gt; 80000').   <br/>         order('employees.emp_no ASC').      <br/>         select(:emp_no, :first_name, :last_name).each do |employee|<br/>    end<br/>  end</span><span id="33ea" class="lv jy hu ld b fv ma lx l ly lz">end</span><span id="7338" class="lv jy hu ld b fv ma lx l ly lz">=&gt; 72.75677799998084</span></pre><p id="2c23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上述结果表明，使用<code class="eh la lb lc ld b">find_each</code>方法会导致更差的performance⁴.ID迭代器方法比naive <code class="eh la lb lc ld b">find_each</code>大约快15倍。当您检查由这两种方法产生的查询时，原因就变得很清楚了。</p><p id="5a4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh la lb lc ld b">find_each</code>方法进行这种类型的查询:</p><pre class="lf lg lh li fq lr ld ls lt aw lu dt"><span id="2af9" class="lv jy hu ld b fv lw lx l ly lz">SELECT  `employees`.`emp_no`, `employees`.`first_name`, `employees`.`last_name` FROM `employees` INNER JOIN `salaries` ON `salaries`.`emp_no` = `employees`.`emp_no` WHERE (salary &gt; 80000)  ORDER BY `employees`.`emp_no` ASC LIMIT 1000</span></pre><p id="4de0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对该查询的解释揭示了以下内容:</p><pre class="lf lg lh li fq lr ld ls lt aw lu dt"><span id="375f" class="lv jy hu ld b fv lw lx l ly lz">1 SIMPLE salaries ALL salary,emp_no NULL NULL NULL 2837536 <strong class="ld hv">Using where; Using temporary; Using filesort</strong><br/>1 SIMPLE employees eq_ref PRIMARY PRIMARY 4 employees.salaries.emp_no 1 Using index</span></pre><p id="028a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这表明salary上的索引和emp_no上的索引都没有用于筛选sales表。</p><p id="9a0f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">id迭代器方法进行这种类型的查询:</p><pre class="lf lg lh li fq lr ld ls lt aw lu dt"><span id="1cbf" class="lv jy hu ld b fv lw lx l ly lz">SELECT <!-- -->`employees`.`emp_no`, `employees`.`first_name`, `employees`.`last_name`<!-- --> FROM `employees` INNER JOIN `salaries` ON `salaries`.`emp_no` = `employees`.`emp_no` WHERE (employees.emp_no &gt;= 5128001) AND (employees.emp_no &lt; 5129001) AND (salary &gt; 80000)</span></pre><p id="4649" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对该查询的解释表明，查询优化器使用sales表中emp_no的索引:</p><pre class="lf lg lh li fq lr ld ls lt aw lu dt"><span id="a008" class="lv jy hu ld b fv lw lx l ly lz">1 SIMPLE salaries range salary,emp_no emp_no 4 NULL 1 <strong class="ld hv">Using index condition; Using where</strong><br/>1 SIMPLE employees eq_ref PRIMARY PRIMARY 4 employees.salaries.emp_no 1 Using index</span></pre><p id="19da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这揭示了为什么<code class="eh la lb lc ld b">find_each</code>方法比迭代器方法慢得多。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="ef51" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="cbf8" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">这里的教训是始终使用解释来理解MySQL查询优化器实际做什么，以便您可以创建最佳的queries⁵.基于对解释结果的分析，可以决定对大型表上的迭代需要采用哪种方法。</p><ul class=""><li id="b816" class="mb mc hu it b iu iv iy iz jc md jg me jk mf jo mg mh mi mj dt translated">大型表上的连接通常会导致性能下降，所以最好避免使用。只有在通过对其中一个表使用基于索引的条件而大大缩小了结果集的范围时，才尝试使用联接。</li><li id="3571" class="mb mc hu it b iu mk iy ml jc mm jg mn jk mo jo mg mh mi mj dt translated">一般情况下，尽量充分利用索引进行查询。使用导致MySQL查询优化器选择使用表中可用索引的查询。向表中添加索引，这可能有助于加快查询速度，同时了解写性能degradation⁶.方面的权衡</li><li id="d077" class="mb mc hu it b iu mk iy ml jc mm jg mn jk mo jo mg mh mi mj dt translated">避免运行select *，而是只选择操作所需的列。这将减少需要发送的数据量，尤其是当表中有许多文本列时。</li><li id="4531" class="mb mc hu it b iu mk iy ml jc mm jg mn jk mo jo mg mh mi mj dt translated">查询优化器可能会根据各种因素采用不同的路径，同样的查询在具有较大资源的服务器上可能会采用不同的路径，因为，比方说，一个索引可能适合内存。这将导致性能的巨大差异。在这些情况下，最好假设最坏的情况，并编写不依赖于在内存中保存大型索引的查询。</li><li id="1b18" class="mb mc hu it b iu mk iy ml jc mm jg mn jk mo jo mg mh mi mj dt translated">查看ActiveRecord生成的查询的最简单方法是打开调试日志记录。建议在开发中打开它，这样您可以尽早发现性能问题。<br/> <code class="eh la lb lc ld b">ActiveRecord::Base.logger = Logger.new(STDOUT)</code></li><li id="6d9d" class="mb mc hu it b iu mk iy ml jc mm jg mn jk mo jo mg mh mi mj dt translated">或者，您可以在一个<code class="eh la lb lc ld b">ActiveRecord::Relation</code>上使用<code class="eh la lb lc ld b">to_sql</code>来预先查看它将进行什么查询。<br/>T7】</li></ul></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="fdcf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我从<a class="ae jp" href="https://github.com/datacharmer/test_db" rel="noopener ugc nofollow" target="_blank">这个</a>样本数据集开始，删除了除了<code class="eh la lb lc ld b">employees</code>和<code class="eh la lb lc ld b">salaries</code>表之外的所有内容。然后我复制了<code class="eh la lb lc ld b">employees</code>表中的记录，达到5百万行。</p><p id="f6b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://blog.novatec-gmbh.de/art-pagination-offset-vs-value-based-paging/" rel="noopener ugc nofollow" target="_blank">这个</a>链接很好地比较了基于值的分页和基于偏移量的分页。</p><p id="8515" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果主键的<code class="eh la lb lc ld b">AUTO_INCREMENT</code>选项打开，记录自动按递增顺序排列。</p><p id="2583" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">⁴在较大的表上，性能下降得更多。当您达到几百万行时，理解底层查询变得更加重要，因为这可能导致<a class="ae jp" rel="noopener" href="/squad-engineering/blazingly-fast-querying-on-huge-tables-by-avoiding-joins-5be0fca2f523">100倍或1000倍的差异</a>。</p><p id="5a9e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">⁵花时间阅读(并掌握)了关于解释输出格式的MySQL官方文档,因此很清楚什么是好的，什么是不好的。</p><p id="bc49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">⁶ <a class="ae jp" href="https://logicalread.com/impact-of-adding-mysql-indexes-mc12/#.W_rzeJNKi_s" rel="noopener ugc nofollow" target="_blank">这个链接</a>很好地描述了创建索引对性能的影响。重要的是要明白，在有很多索引的表上写会比较慢，所以要明智地使用它们。</p></div></div>    
</body>
</html>