<html>
<head>
<title>TensorFlow.js — Real-Time Object Detection in 10 Lines of Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TensorFlow.js —用10行代码实现实时物体检测</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/tensorflow-js-real-time-object-detection-in-10-lines-of-code-baf15dfb95b2?source=collection_archive---------0-----------------------#2018-12-10">https://medium.com/hackernoon/tensorflow-js-real-time-object-detection-in-10-lines-of-code-baf15dfb95b2?source=collection_archive---------0-----------------------#2018-12-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ff01e54d8bb13f1275f7bf08aed4fd69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ptBWjaV6FgVPgOYd5UZVg.png"/></div></div></figure><p id="aa18" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我的上一篇文章中，我向你展示了如何在浏览器中进行图像分类。</p><p id="a819" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">图像分类可以是一个非常有用的工具，它可以让我们了解图像中有什么。然而，有时我们想要更多。这可能有点违反直觉，但仅仅因为机器学习模型可以说出图像中的内容，并不意味着它可以告诉我们它在图像中的位置。我们需要一个不同的架构。</p><p id="9d89" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是物体检测发挥作用的地方。</p><p id="6d9e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对象检测提供了计算场景中有多少对象、跟踪运动和简单定位对象位置的能力。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kb"><img src="../Images/4511c62d8a4563701165c971fcff5f36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y40V8ZZ9T_XI-eGQulwIRQ.png"/></div></div></figure><p id="4104" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本教程结束时，我们将拥有一个全功能的实时对象检测web应用程序，它将通过我们的网络摄像头跟踪对象。</p><h1 id="a2c3" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">检测物体</h1><p id="21c1" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">为了进行对象检测预测，我们需要做的就是导入TensorFlow模型，<code class="eh lj lk ll lm b"><a class="ae ka" href="https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd" rel="noopener ugc nofollow" target="_blank">coco-ssd</a></code>，它可以用像NPM这样的包管理器安装，或者简单地导入到一个<code class="eh lj lk ll lm b">&lt;script&gt;</code>标签中。然后，我们可以加载模型，并做出预测。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><blockquote class="lp lq lr"><p id="31cb" class="jc jd ls je b jf jg jh ji jj jk jl jm lt jo jp jq lu js jt ju lv jw jx jy jz hn dt translated"><strong class="je hv">注意:</strong>加载模型可能需要几秒钟。最好加载模型一次，并保存对它的引用。</p></blockquote><p id="80dc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们传递给检测函数的图像只是对html <code class="eh lj lk ll lm b">&lt;img&gt;</code>标签的引用:</p><pre class="kc kd ke kf fq lw lm lx ly aw lz dt"><span id="33b2" class="ma kh hu lm b fv mb mc l md me">&lt;img id="image" src="image_url"&gt;</span></pre><p id="168a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们得到我们的预测之后，我们需要一种方法把它显示到屏幕上。我们的预测响应将是一个包围盒及其置信度得分的列表。它应该是这样的:</p><pre class="kc kd ke kf fq lw lm lx ly aw lz dt"><span id="c5a0" class="ma kh hu lm b fv mb mc l md me">[{<br/>  bbox: [x, y, width, height],<br/>  class: "cat",<br/>  score: 0.8380282521247864<br/>}]</span></pre><p id="57d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了绘制边界框，我们将利用一个<code class="eh lj lk ll lm b">&lt;canvas&gt;</code>元素:</p><pre class="kc kd ke kf fq lw lm lx ly aw lz dt"><span id="88b9" class="ma kh hu lm b fv mb mc l md me">&lt;canvas id="canvas"&gt;</span></pre><p id="dd5a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">canvas元素允许我们使用strokeRect函数，它与我们的预测结果完美地对应起来:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><h1 id="b893" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">简单的检测演示</h1><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="mf lo l"/></div></figure><h1 id="6d61" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">来自网络摄像头的流</h1><p id="4ae0" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">在网络摄像头流上运行实时检测几乎与从<code class="eh lj lk ll lm b">&lt;img&gt;</code>标签更改为<code class="eh lj lk ll lm b">&lt;video&gt;</code>标签一样简单…唯一的例外是启动网络摄像头的巨大代码块:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="6dc7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，我们可以将视频元素传递给模型进行检测。然而，这一次我们将调用<code class="eh lj lk ll lm b">requestAnimationFrame</code>，它将尽可能快地在无限循环中反复调用我们的检测函数，当它跟不上时跳过帧。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><h1 id="25fc" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">实时检测演示</h1><div class="mg mh fm fo mi mj"><a href="https://z364noozrm.codesandbox.io/" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab ej"><div class="ml ab mm cl cj mn"><h2 class="bd hv fv z el mo eo ep mp er et ht dt translated">TensorFlow.js实时对象检测演示</h2><div class="mq l"><p class="bd b gc z el mo eo ep mp er et ek translated">z364noozrm.codesandbox.io</p></div></div></div></a></div><blockquote class="lp lq lr"><p id="e047" class="jc jd ls je b jf jg jh ji jj jk jl jm lt jo jp jq lu js jt ju lv jw jx jy jz hn dt translated"><strong class="je hv">注意:</strong>必须使用谷歌Chrome或支持网络摄像头流媒体的浏览器(非Safari)。</p></blockquote><p id="246e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">完整代码链接:<a class="ae ka" href="https://codesandbox.io/s/z364noozrm" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/z364noozrm</a>。</p><h1 id="5385" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">最后的想法</h1><p id="3bf4" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">我在使用TensorFlow.js的过程中得到了很多乐趣。他们让机器学习变得极其简单，最大限度地减少了麻烦。一个类似的项目可能要花我几天时间，但这只花了我几个小时。我想我的下一个项目将是尝试训练我自己的一些模型🎉</p></div><div class="ab cl mr ms hc mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hn ho hp hq hr"><p id="47d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢阅读！如果你有任何问题，请随时联系bourdakos1@gmail.com，通过<a class="ae ka" href="https://www.linkedin.com/in/nicholasbourdakos" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我，或者通过<a class="ae ka" rel="noopener" href="/@bourdakos1"> Medium </a>和<a class="ae ka" href="https://twitter.com/bourdakos1" rel="noopener ugc nofollow" target="_blank"> Twitter </a>关注我。</p><p id="f27b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你觉得这篇文章很有帮助，给它一些掌声会很有意义👏并分享出来帮别人找！并欢迎在下方发表评论。</p></div></div>    
</body>
</html>