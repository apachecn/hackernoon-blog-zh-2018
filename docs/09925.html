<html>
<head>
<title>Piecing Together GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">拼凑图表</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/piecing-together-graphql-ca6739cd8205?source=collection_archive---------11-----------------------#2018-12-10">https://medium.com/hackernoon/piecing-together-graphql-ca6739cd8205?source=collection_archive---------11-----------------------#2018-12-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/2d982bb891ade0b9ca243ea47d4a00d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yy8ArmrJ2z4djg5cyzj1fg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/hbhKpR12KaE?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">simon peel</a> on <a class="ae jg" href="https://unsplash.com/t/experimental?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3f25" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">GraphQL的概念从数据存储跨越到客户端。一路上发生了什么？<a class="ae jg" href="https://hackernoon.com/tagged/graphql" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>世界中的工具已经走过了漫长的道路，构建应用程序比以往任何时候都更容易。通过逐步完成每个组件，您将从整体上对GraphQL有更好的理解。</p><p id="0d88" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">按照这个教程，克隆这个<a class="ae jg" href="https://github.com/captDaylight/fullstack-prisma-apollo" rel="noopener ugc nofollow" target="_blank">全栈例子</a>。这是一个使用会话来认证用户的基本应用程序，是一个久经考验的持久用户认证的安全选项。</p><h1 id="181f" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">我们的堆栈</h1><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ld"><img src="../Images/19c812b88718f6c3781572f124681056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5xS-WDmfv70pjBizkS8HrQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Image from <a class="ae jg" href="https://www.howtographql.com" rel="noopener ugc nofollow" target="_blank">https://www.howtographql.com</a></figcaption></figure><p id="c020" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">从左到右看上面的图像，第一个表示我们的客户端应用程序构建在<a class="ae jg" href="https://github.com/apollographql/apollo-client" rel="noopener ugc nofollow" target="_blank"><strong class="jj hv">【Apollo】</strong></a>(我们的GraphQL数据缓存)和<a class="ae jg" href="https://github.com/facebook/react" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv"> React </strong> </a>上。我正在使用<a class="ae jg" href="https://github.com/parcel-bundler/parcel" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv">包</strong> </a> <strong class="jj hv"> </strong>来构建客户端包。</p><p id="4f79" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">接下来，“GraphQL服务器”将是<a class="ae jg" href="https://github.com/prisma/graphql-yoga" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv"> graphql-yoga </strong> </a>，一个基于<a class="ae jg" href="https://github.com/expressjs/express" rel="noopener ugc nofollow" target="_blank"> Express </a>的服务器，它与Apollo接口，并为我们提供了许多明智的默认设置。</p><p id="cc1d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="https://github.com/prisma/prisma" rel="noopener ugc nofollow" target="_blank"> <strong class="jj hv"> Prisma </strong> </a>将站在服务器和数据库之间作为我们的数据层，类似于一个ORM，用于向我们的数据库写入数据和从我们的数据库访问数据。Prisma是开源的，支持所有主要的<a class="ae jg" href="https://www.prisma.io/features/databases/" rel="noopener ugc nofollow" target="_blank">数据库</a>(图片右侧的pancake堆栈)。</p><h2 id="688e" class="li kg hu bd kh lj lk ll kl lm ln lo kp js lp lq kt jw lr ls kx ka lt lu lb lv dt translated">设置</h2><p id="28b3" class="pw-post-body-paragraph jh ji hu jj b jk lw jm jn jo lx jq jr js ly ju jv jw lz jy jz ka ma kc kd ke hn dt translated">从安装一些全局包开始。</p><pre class="le lf lg lh fq mb mc md me aw mf dt"><span id="452f" class="li kg hu mc b fv mg mh l mi mj">yarn global add prisma graphql-cli nodemon</span></pre><p id="4925" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们的项目文件夹中创建一个<code class="eh mk ml mm mc b">.env</code>文件，我们将在部署Prisma后填充DB_URL变量:</p><pre class="le lf lg lh fq mb mc md me aw mf dt"><span id="bab3" class="li kg hu mc b fv mg mh l mi mj">APP_SECRET=mysecret123<br/>DB_URL=</span></pre><p id="0c28" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">接下来，创建一个<a class="ae jg" href="https://app.prisma.io/signup" rel="noopener ugc nofollow" target="_blank"> Prisma帐户</a>，然后使用<code class="eh mk ml mm mc b">prisma login</code>登录Prisma CLI，这样您就可以为您的项目启动免费的开发服务器。别担心，Prisma可以随时移动到你选择的硬件上，不会把你锁在里面。</p><p id="9687" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将生成我们的用户模型，并将它们部署到我们的测试数据库中。在<code class="eh mk ml mm mc b">/database</code>中，您会看到我们有一个型号，<code class="eh mk ml mm mc b">User</code>。当我们部署时，Prisma将基于这个模式创建绑定。我们项目根中的<code class="eh mk ml mm mc b">.graphqlconfig.yml</code>将向Prisma解释我们希望如何部署我们的设置。现在，运行:</p><pre class="le lf lg lh fq mb mc md me aw mf dt"><span id="1147" class="li kg hu mc b fv mg mh l mi mj">prisma deploy database</span></pre><p id="d96d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">选择“<em class="mn">演示服务器”</em>，选择有意义的区域，输入类似“<em class="mn">full stack”</em>的名称，并将stage设置为“<em class="mn">dev”</em>。Prisma会生成一个类似<code class="eh mk ml mm mc b"><a class="ae jg" href="https://us1.prisma.sh/myusername-2acca9a/my-project/dev." rel="noopener ugc nofollow" target="_blank">https://us1.prisma.sh/<em class="mn">myusername-12345</em>/fullstack/dev</a></code>的端点，放入你的<code class="eh mk ml mm mc b">.env</code>。</p><p id="bb15" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后一件事，Prisma会把你的<code class="eh mk ml mm mc b">database/prisma.yml</code>注释掉:</p><pre class="le lf lg lh fq mb mc md me aw mf dt"><span id="fdfe" class="li kg hu mc b fv mg mh l mi mj"><em class="mn">#endpoint: ${env:DB_URL}</em><br/>endpoint: <a class="ae jg" href="https://us1.prisma.sh/myusername-2acca9a/my-project/dev." rel="noopener ugc nofollow" target="_blank">https://us1.prisma.sh/myusername-12345/fullstack/dev</a></span><span id="cec6" class="li kg hu mc b fv mo mh l mi mj">...</span></pre><p id="d299" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以切换回:</p><pre class="le lf lg lh fq mb mc md me aw mf dt"><span id="d499" class="li kg hu mc b fv mg mh l mi mj">endpoint: ${env:DB_URL}</span><span id="ae02" class="li kg hu mc b fv mo mh l mi mj">...</span></pre><h1 id="b413" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">它将如何工作</h1><p id="ddc1" class="pw-post-body-paragraph jh ji hu jj b jk lw jm jn jo lx jq jr js ly ju jv jw lz jy jz ka ma kc kd ke hn dt translated">用<code class="eh mk ml mm mc b">yarn install</code>或<code class="eh mk ml mm mc b">npm install</code>安装完依赖项后，用<code class="eh mk ml mm mc b">npm run dev</code>启动本地服务器，并导航到<code class="eh mk ml mm mc b">localhost:1234</code>。<code class="eh mk ml mm mc b">dev</code>命令将同时运行我们的服务器和前端构建。</p><h2 id="913f" class="li kg hu bd kh lj lk ll kl lm ln lo kp js lp lq kt jw lr ls kx ka lt lu lb lv dt translated">试验</h2><p id="d865" class="pw-post-body-paragraph jh ji hu jj b jk lw jm jn jo lx jq jr js ly ju jv jw lz jy jz ka ma kc kd ke hn dt translated">注册并登录！成功创建用户后，它会将您带到仪表板。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/6ec386855a64e61321a6e784aefb445c.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*hTL4qreCBRPOQ_1jgG3zKw.gif"/></div></figure></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><p id="30e5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦您登录，受保护的路由将不允许认证用户访问<code class="eh mk ml mm mc b">/signup</code>或<code class="eh mk ml mm mc b">/login</code>路由。一旦注销，就不能去<code class="eh mk ml mm mc b">/dashboard</code>。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/a39d1697ed3c417afbc177b60d0c31fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*frOuSMAJv3DhXsQzcSnmOA.gif"/></div></figure></div><div class="ab cl mq mr hc ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hn ho hp hq hr"><p id="d158" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">登录时尝试刷新。在页面加载时，应用程序将请求检查用户的身份验证状态。如果通过身份验证，该页面将获取用户的数据。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/fc978baea4d74ea32f11849b179b2da3.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*gip6YhKQvNVcW6TxcJdSpA.gif"/></div></figure><h1 id="026a" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">后端</h1><p id="73b3" class="pw-post-body-paragraph jh ji hu jj b jk lw jm jn jo lx jq jr js ly ju jv jw lz jy jz ka ma kc kd ke hn dt translated">打开<code class="eh mk ml mm mc b">/src/index.js</code>你会看到用<code class="eh mk ml mm mc b">GraphQLServer</code>实例化的<code class="eh mk ml mm mc b">graphql-yoga</code>服务器。这需要一些论据:</p><p id="7f6d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是我们的GraphQL模式。在该文件中，您会看到我们已经列出了将由解析器处理的查询和变异。</p><p id="9836" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">解析器</strong>:这些是完成登录、获取用户等工作的方法。它们的输入和返回值必须与我们的typeDef的<code class="eh mk ml mm mc b">schema.graphql</code>中定义的相匹配。</p><p id="e65d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">上下文:</strong>这需要一个函数，我们将使用它来设置数据库，使其指向我们的Prisma设置。从<code class="eh mk ml mm mc b">prisma deploy</code>传入生成的typeDefs，从<code class="eh mk ml mm mc b">.env</code>传入端点和秘密。</p><p id="1db6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如上所述，<code class="eh mk ml mm mc b">graphql-yoga</code>是基于Express的，所以我们可以使用像<code class="eh mk ml mm mc b">express-session</code>这样的通用包来处理我们的会话。</p><p id="accc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们定义了我们的会话实现之后，我们用CORS设置启动服务器，允许我们在<code class="eh mk ml mm mc b">localhost:1234</code>(通过包)上的前端获取我们的会话cookies。</p><h1 id="2d2e" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">客户端</h1><p id="b7df" class="pw-post-body-paragraph jh ji hu jj b jk lw jm jn jo lx jq jr js ly ju jv jw lz jy jz ka ma kc kd ke hn dt translated">我们的前端是一个与包裹捆绑在一起的准系统React应用程序。从<code class="eh mk ml mm mc b">client/index.jsx</code>开始，我们设置<code class="eh mk ml mm mc b">ApolloClient</code>连接到运行在端口<code class="eh mk ml mm mc b">4000</code>上的服务器，并将客户端分配给我们的<code class="eh mk ml mm mc b">ApolloProvider</code>。</p><p id="f8c9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<code class="eh mk ml mm mc b">Header</code>组件中，您会看到我们正在调用<code class="eh mk ml mm mc b">GET_AUTH_STATUS</code>查询，该查询检查后端是否有会话。它将决定是否显示<em class="mn">登录/注册</em>链接或<em class="mn">注销</em>。</p><p id="187a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<code class="eh mk ml mm mc b">index.jsx</code>中，您将看到我们的<code class="eh mk ml mm mc b">Dashboard</code>和授权路由的受保护路由。我创建了一个特殊的route组件，<code class="eh mk ml mm mc b">ProtectedRoute</code>，它调用<code class="eh mk ml mm mc b">GET_AUTH_STATUS</code>来决定是否显示相应的组件。即使我们在几个不同的地方调用我们的身份验证状态查询，当你在开发者工具中打开“<a class="ae jg" href="https://hackernoon.com/tagged/network" rel="noopener ugc nofollow" target="_blank">网络</a>”时，你会看到它只被请求一次。这是因为Apollo Cache自动处理不同组件<a class="ae jg" href="https://www.apollographql.com/docs/react/advanced/caching.html#automatic-updates" rel="noopener ugc nofollow" target="_blank">之间的数据</a>。</p><p id="f845" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh mk ml mm mc b">Auth</code>组件处理我们的注册和登录变化。成功登录或注册后，我们需要更新我们的<code class="eh mk ml mm mc b">GET_AUTH_STATUS</code>,因为<code class="eh mk ml mm mc b">LOGIN</code>和<code class="eh mk ml mm mc b">SIGNUP</code>突变只返回用户对象。我们将只手动更新状态，而不是再次请求身份验证状态:</p><pre class="le lf lg lh fq mb mc md me aw mf dt"><span id="b1b5" class="li kg hu mc b fv mg mh l mi mj">&lt;Mutation<br/>  mutation={isSignup ? SIGNUP : LOGIN}<br/>  variables={isSignup ? { email, name, password } : { email, password }}<br/><strong class="mc hv">  update={(cache) =&gt; {<br/>    cache.writeQuery({<br/>      query: GET_AUTH_STATUS,<br/>      data: {<br/>        isLoggedIn: {<br/>          status: true,<br/>          __typename: 'AuthStatus',<br/>        },<br/>      },<br/>    });<br/>  }}</strong><br/>&gt;</span></pre><h1 id="6c4a" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">包裹</h1><p id="f0e0" class="pw-post-body-paragraph jh ji hu jj b jk lw jm jn jo lx jq jr js ly ju jv jw lz jy jz ka ma kc kd ke hn dt translated">如果您一直是旁观者，现在是深入GraphQL的好时机。GraphQL生态系统在出现的几年里已经走过了漫长的道路。堆栈中的每一层都已经足够成熟，从上到下构建一个应用程序相对简单。</p><p id="4d76" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此外，人们的兴趣也在增加。Javascript 最近的“<a class="ae jg" href="https://2018.stateofjs.com/data-layer/overview/" rel="noopener ugc nofollow" target="_blank">状态”反映了这种情绪，我们只会在未来看到更多。</a></p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mx"><img src="../Images/23c33d6e522a97069e64c02bd39f5b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9jS5XCPzVAvWdRKiz_D0Yw.png"/></div></div></figure><p id="ce8f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mn">为什么不将jwt存储在本地存储或cookies中？</em>嗯，<a class="ae jg" href="https://www.rdegges.com/2018/please-stop-using-local-storage/" rel="noopener ugc nofollow" target="_blank">这些</a> <a class="ae jg" href="http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/" rel="noopener ugc nofollow" target="_blank">文章</a>能比我解释得更好，但足以说使用服务器端会话来保存敏感数据更安全(也更容易)。</p><p id="8b05" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">同样，这里有一个到示例<a class="ae jg" href="https://github.com/captDaylight/fullstack-prisma-apollo" rel="noopener ugc nofollow" target="_blank">存储库</a>的链接。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="my mz l"/></div></figure></div></div>    
</body>
</html>