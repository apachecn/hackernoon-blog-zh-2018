<html>
<head>
<title>Static and Dynamic Libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">静态和动态库</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/static-and-dynamic-libraries-fe5d23daffe3?source=collection_archive---------12-----------------------#2018-12-11">https://medium.com/hackernoon/static-and-dynamic-libraries-fe5d23daffe3?source=collection_archive---------12-----------------------#2018-12-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/9d5dee6959a9f45190b5de4ec3f5d3a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*m4sizblMQxAnZKMa.jpg"/></div></div></figure><div class=""/><p id="da8b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我认为静态库和动态库是混淆的。让我们探索一下为什么我们要首先经历创建一个库的麻烦。</p><p id="29ec" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，假设在代码中重用任何函数都是非法的。这意味着每当你想执行一个操作时，你每次都必须为它重写相同的函数。幸运的是，这不是我们的现实，因为我们能够重用我们已经编写的函数。</p><p id="e5dc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们想要重用一个函数时，通常不会花时间去创建整个库，但是库允许我们存储我们知道以后会用到的代码。</p><p id="0b7b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，如果我们向一个库中添加10个函数，我们可以将该库包含在我们编写的下一个源代码文件中，并且可以访问这10个函数中的每一个。</p><p id="eef9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里我们将讨论两种不同类型的库——静态库和动态库。</p><p id="a093" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在静态库中，链接器包括源代码使用的库函数的目标代码。这意味着，如果您在源代码中创建了一个名为mylib.a的静态库，然后调用mylib.a中定义的五个函数，这些函数的实现将被翻译成目标代码，然后由链接器包含在最终的可执行文件中。</p><p id="c3bc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">静态库比动态库更不容易被破坏。这是因为库的可执行代码一旦被创建和使用，在可执行文件中是安全的。此外，由于函数已经编译成目标代码并包含在可执行文件中，所以在静态库中多次调用同一个函数会快得多。</p><p id="13bd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">静态库的两个缺点是可执行文件的大小和编译。因为静态库使用的函数的实际目标代码包含在最终的可执行文件中，所以静态库使可执行文件更长。此外，对包含在静态库中的函数的实现所做的任何更改，在用新函数重新编译静态库之前都不会反映出来。</p><p id="7e58" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们如何创建一个静态库？</p><p id="a791" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们用所有的*创建一个静态库。我们当前目录中的c文件。首先，我们需要将C文件编译成目标代码。我们可以通过以下方式做到这一点:</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div class="fe ff ka"><img src="../Images/4088533dea9553277f0f5af744df6785.png" data-original-src="https://miro.medium.com/v2/resize:fit:222/format:webp/1*d0aAnvlhRgG1eQbnGtUrPw.png"/></div></figure><p id="05fa" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们需要创建静态库并向其中添加文件。我们可以使用以下命令来实现:</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div class="fe ff kf"><img src="../Images/af1b2c95ea46d4fbed85c409b931dd24.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*jU9EqIdRkm5mxMYzW1MY9Q.png"/></div></figure><p id="8573" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们将所有东西都添加到我们的标准库中之后，需要对库进行索引。可以通过运行命令ranlib libexample.a来索引库。索引库很重要，因为它可以在调用库时加快链接过程。</p><p id="2754" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以通过运行命令nm libstatic.a来查看我们最近生成的索引。具体来说，默认情况下，nm命令将向我们显示符号的虚拟地址、符号的名称以及关于符号类型的信息。如果符号是小写的，那么它是局部的，如果它是大写的，那么它是外部的。</p><p id="7ef3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了使用这个静态库，我们将创建一个程序——让我们称之为my_program.c，它使用我们刚刚创建的库中的函数。要使用库函数，我们需要告诉编译器去哪里找。我们可以运行命令:</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div class="fe ff kg"><img src="../Images/5acff3e9af7e92cd712317fc4487d109.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*S4spfZUotP9YzYKQRhdRbQ.png"/></div></figure><p id="5e55" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们来看看动态库。让我们想象一个熟悉的场景，我们有一个从mylib.so库中调用函数的源代码文件(注意文件扩展名的不同。在linux上，静态库应该以“.”结尾。a“而动态库应该以”。所以”)。在动态库中，链接器将简单地包含我们试图在可执行文件中使用的函数的开始地址，而不是将函数实现编译成目标代码并包含在可执行文件中。这消除了由静态库引起的大小问题，因为最终的可执行文件将只包括地址而不是整个函数实现。</p><p id="ac92" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，您不需要每次更改函数时都重新编译动态库，因为可执行文件有一个指向函数的指针，而不是目标代码。</p><p id="46c5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们如何创建一个动态库？</p><p id="6c0a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们用所有的*创建一个动态库。我们当前目录中的c文件。首先，我们需要将C文件编译成目标代码，并使它们与位置无关。我们可以通过以下方式做到这一点:</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div class="fe ff kh"><img src="../Images/784c3c414cd249e56372968e2ae4f4d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:352/format:webp/1*7QhSJYsc8MlRf2yB1oI4PQ.png"/></div></figure><p id="13a0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们需要创建动态库并向其中添加文件。我们可以使用以下命令来实现:</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div class="fe ff ki"><img src="../Images/b4c3657bdc2d5c26af20d0628a4cd69c.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*Cg4EZeWpdfzQZsg6G3lc_w.png"/></div></figure><p id="7381" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦我们将文件添加到动态库中，我们需要验证我们创建的共享库包含所有必要的依赖项。我们可以通过运行以下命令进行检查:</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff kj"><img src="../Images/9e399f2059aca52a681144ae4407bfaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vc7p8gAN5xTfPKPG8ynPfw.png"/></div></div><figcaption class="kk kl fg fe ff km kn bd b be z ek">“not found” will be displayed if your program is missing dependencies</figcaption></figure><p id="6e41" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">程序需要知道在哪里寻找库文件。因此，我们必须将动态库的位置添加到环境LD_LIBRARY_PATH中。我们可以使用下面的命令来完成这项工作:</p><pre class="kb kc kd ke fq ko kp kq kr aw ks dt"><span id="ea10" class="kt ku if kp b fv kv kw l kx ky">export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH</span></pre><p id="45dc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了使用这个动态库(liball.so ),我们将创建一个程序——让我们称之为my_program.c。然后我们需要像编译静态库一样编译程序:</p><p id="b255" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">gcc -lliball -L. my_program.c -o程序。</p><figure class="kb kc kd ke fq hw fe ff paragraph-image"><div class="fe ff kz"><img src="../Images/36e69ac21f36d37d968c3b9fd9b4848f.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*ecxTKnx4tW-3srPSsizgiw.png"/></div></figure><p id="2f0e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在创建了这个新的共享库之后，我们可以使用ldconfig命令创建必要的链接和缓存(供运行时链接器使用，<em class="la"> ld.so </em>)到/etc/ld.so.conf目录。</p><p id="8975" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，当决定下一个项目是使用静态库还是动态库时，要记住权衡。如果你需要节省空间——你可能应该使用动态库，如果你需要东西执行得更快——你可能应该使用静态库。</p></div></div>    
</body>
</html>