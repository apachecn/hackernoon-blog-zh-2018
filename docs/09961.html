<html>
<head>
<title>Rendering a Sidebar or Breadcrumbs with React Router v4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React Router v4呈现侧栏或面包屑</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/rendering-a-sidebar-or-breadcrumbs-with-react-router-v4-94365f6a53ed?source=collection_archive---------19-----------------------#2018-12-11">https://medium.com/hackernoon/rendering-a-sidebar-or-breadcrumbs-with-react-router-v4-94365f6a53ed?source=collection_archive---------19-----------------------#2018-12-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/de583ef9f8f32c0b8dcab1d57b400444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EcvkY4Q06MfSdPqArF4aEA.jpeg"/></div></div></figure><p id="fc43" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当使用React Router构建应用程序时，您通常会希望实现侧边栏或面包屑导航条。在本文中，您将通过分解React Router文档中的侧栏示例，了解React Router是如何做到这一点的。</p><figure class="ka kb kc kd fq iv"><div class="bz el l di"><div class="ke kf l"/></div></figure><p id="a539" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个常见的UI模式是在你的应用程序中有一个侧边栏或面包屑导航条。因为React Router允许您在每页上呈现和匹配多个<code class="eh kg kh ki kj b">Route</code>,所以实现这种模式非常简单。这篇文章的目的是展示如何通过呈现多个<code class="eh kg kh ki kj b">Route</code>来基于路径(比如侧边栏)在页面的不同部分呈现不同的组件。</p><p id="162e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们要做的第一件事，也是这篇文章的真正秘密，是创建一个routes数组。数组中的每一项都将包含关于特定路线的所有信息，以及应该呈现哪个组件。</p><pre class="ka kb kc kd fq kk kj kl km aw kn dt"><span id="a6ae" class="ko kp hu kj b fv kq kr l ks kt">const routes = [<br/>  { path: '/',<br/>    exact: true,<br/>    sidebar: () =&gt; &lt;div&gt;home!&lt;/div&gt;,<br/>    main: () =&gt; &lt;h2&gt;Home&lt;/h2&gt;<br/>  },<br/>  { path: '/bubblegum',<br/>    sidebar: () =&gt; &lt;div&gt;bubblegum!&lt;/div&gt;,<br/>    main: () =&gt; &lt;h2&gt;Bubblegum&lt;/h2&gt;<br/>  },<br/>  { path: '/shoelaces',<br/>    sidebar: () =&gt; &lt;div&gt;shoelaces!&lt;/div&gt;,<br/>    main: () =&gt; &lt;h2&gt;Shoelaces&lt;/h2&gt;<br/>  }<br/>]</span></pre><p id="5596" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，因为我们已经抽象出了到这个数组的路径，每当我们想要渲染任何<code class="eh kg kh ki kj b">Route</code>时，我们可以映射它并指定应该渲染哪个组件(<code class="eh kg kh ki kj b">main</code>或<code class="eh kg kh ki kj b">sidebar</code>)。为了展示如何做到这一点，让我们首先为我们的应用程序构建一个基本框架。</p><pre class="ka kb kc kd fq kk kj kl km aw kn dt"><span id="c154" class="ko kp hu kj b fv kq kr l ks kt">import React from 'react'<br/>import {<br/>  BrowserRouter as Router,<br/>  Route,<br/>  Link,<br/>} from 'react-router-dom'</span><span id="6a18" class="ko kp hu kj b fv ku kr l ks kt">const routes = [<br/>  { path: '/',<br/>    exact: true,<br/>    sidebar: () =&gt; &lt;div&gt;home!&lt;/div&gt;,<br/>    main: () =&gt; &lt;h2&gt;Home&lt;/h2&gt;<br/>  },<br/>  { path: '/bubblegum',<br/>    sidebar: () =&gt; &lt;div&gt;bubblegum!&lt;/div&gt;,<br/>    main: () =&gt; &lt;h2&gt;Bubblegum&lt;/h2&gt;<br/>  },<br/>  { path: '/shoelaces',<br/>    sidebar: () =&gt; &lt;div&gt;shoelaces!&lt;/div&gt;,<br/>    main: () =&gt; &lt;h2&gt;Shoelaces&lt;/h2&gt;<br/>  }<br/>]</span><span id="3c62" class="ko kp hu kj b fv ku kr l ks kt">class App extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;Router&gt;<br/>        &lt;div style={{ display: 'flex' }}&gt;<br/>          &lt;div style={{<br/>            padding: '10px',<br/>            width: '40%',<br/>            background: '#f0f0f0'<br/>          }}&gt;<br/>            &lt;ul style={{ listStyleType: 'none', padding: 0 }}&gt;<br/>              &lt;li&gt;&lt;Link to="/"&gt;Home&lt;/Link&gt;&lt;/li&gt;<br/>              &lt;li&gt;&lt;Link to="/bubblegum"&gt;Bubblegum&lt;/Link&gt;&lt;/li&gt;<br/>              &lt;li&gt;&lt;Link to="/shoelaces"&gt;Shoelaces&lt;/Link&gt;&lt;/li&gt;<br/>            &lt;/ul&gt;</span><span id="79c3" class="ko kp hu kj b fv ku kr l ks kt">          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>      &lt;/Router&gt;<br/>    )<br/>  }<br/>}</span><span id="a427" class="ko kp hu kj b fv ku kr l ks kt">export default App</span></pre><p id="9c7f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请记住，这里的目标是根据路径在应用程序的不同位置呈现多个组件。我们已经有了我们的<code class="eh kg kh ki kj b">routes</code>数组，所以无论我们想在哪里渲染一些<code class="eh kg kh ki kj b">Route</code>我们都可以映射它。首先，让我们添加一些<code class="eh kg kh ki kj b">Route</code>到侧边栏(在我们的导航里面)。</p><pre class="ka kb kc kd fq kk kj kl km aw kn dt"><span id="10f3" class="ko kp hu kj b fv kq kr l ks kt">render() {<br/>  return (<br/>    &lt;Router&gt;<br/>      &lt;div style={{ display: 'flex' }}&gt;<br/>        &lt;div style={{<br/>          padding: '10px',<br/>          width: '40%',<br/>          background: '#f0f0f0'<br/>        }}&gt;<br/>          &lt;ul style={{ listStyleType: 'none', padding: 0 }}&gt;<br/>            &lt;li&gt;&lt;Link to="/"&gt;Home&lt;/Link&gt;&lt;/li&gt;<br/>            &lt;li&gt;&lt;Link to="/bubblegum"&gt;Bubblegum&lt;/Link&gt;&lt;/li&gt;<br/>            &lt;li&gt;&lt;Link to="/shoelaces"&gt;Shoelaces&lt;/Link&gt;&lt;/li&gt;<br/>          &lt;/ul&gt;<br/>          {routes.map((route) =&gt; (<br/>            &lt;Route<br/>              key={route.path}<br/>              path={route.path}<br/>              exact={route.exact}<br/>              component={route.sidebar}<br/>            /&gt;<br/>          ))}<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/Router&gt;<br/>  )<br/>}</span></pre><p id="6280" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最值得注意的是，我们已经将<code class="eh kg kh ki kj b">route.sidebar</code>转换为<code class="eh kg kh ki kj b">Route</code>的<code class="eh kg kh ki kj b">component</code>道具。这是这个例子的关键，显示了我们之前创建的<code class="eh kg kh ki kj b">routes</code>数组的重要性。现在，只要位置与<code class="eh kg kh ki kj b">path</code>匹配，侧边栏组件就会被呈现。然而，我们并不想就此止步。当位置与路径匹配时，我们还希望在应用程序的主体中呈现一个组件。为此，我们将再次映射<code class="eh kg kh ki kj b">routes</code>，但不是通过<code class="eh kg kh ki kj b">component</code> <code class="eh kg kh ki kj b">route.sidebar</code>，而是通过<code class="eh kg kh ki kj b">route.main</code>。</p><pre class="ka kb kc kd fq kk kj kl km aw kn dt"><span id="61ac" class="ko kp hu kj b fv kq kr l ks kt">render() {<br/>  return (<br/>    &lt;Router&gt;<br/>      &lt;div style={{ display: 'flex' }}&gt;<br/>        &lt;div style={{<br/>          padding: '10px',<br/>          width: '40%',<br/>          background: '#f0f0f0'<br/>        }}&gt;<br/>          &lt;ul style={{ listStyleType: 'none', padding: 0 }}&gt;<br/>            &lt;li&gt;&lt;Link to="/"&gt;Home&lt;/Link&gt;&lt;/li&gt;<br/>            &lt;li&gt;&lt;Link to="/bubblegum"&gt;Bubblegum&lt;/Link&gt;&lt;/li&gt;<br/>            &lt;li&gt;&lt;Link to="/shoelaces"&gt;Shoelaces&lt;/Link&gt;&lt;/li&gt;<br/>          &lt;/ul&gt;<br/>          {routes.map((route) =&gt; (<br/>            &lt;Route<br/>              key={route.path}<br/>              path={route.path}<br/>              exact={route.exact}<br/>              component={route.sidebar}<br/>            /&gt;<br/>          ))}<br/>        &lt;/div&gt;</span><span id="a912" class="ko kp hu kj b fv ku kr l ks kt">        &lt;div style={{ flex: 1, padding: '10px' }}&gt;<br/>          {routes.map((route) =&gt; (<br/>            &lt;Route<br/>              key={route.path}<br/>              path={route.path}<br/>              exact={route.exact}<br/>              component={route.main}<br/>            /&gt;<br/>          ))}<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/Router&gt;<br/>  )<br/>}</span></pre><p id="5986" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">🕺.现在，因为React Router允许我们在一个页面上呈现和匹配多个<code class="eh kg kh ki kj b">Route</code>，并且因为我们将我们的路由抽象为一个数组，所以每当位置匹配<code class="eh kg kh ki kj b">Route</code> s <code class="eh kg kh ki kj b">path</code>时，我们可以在页面的不同部分呈现不同的组件。</p></div><div class="ab cl kv kw hc kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hn ho hp hq hr"><p id="a1db" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lc">最初发表于</em><a class="ae ld" href="https://tylermcginnis.com/react-router-sidebar-breadcrumbs/" rel="noopener ugc nofollow" target="_blank"><em class="lc"/></a><em class="lc">作为他们</em> <a class="ae ld" href="https://tylermcginnis.com/courses/react-router/" rel="noopener ugc nofollow" target="_blank"> <em class="lc"> React路由器</em> </a> <em class="lc">课程的一部分。</em></p></div></div>    
</body>
</html>