<html>
<head>
<title>Implementing a WebSocket server with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node.js实现WebSocket服务器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/implementing-a-websocket-server-with-node-js-d9b78ec5ffa8?source=collection_archive---------0-----------------------#2018-12-12">https://medium.com/hackernoon/implementing-a-websocket-server-with-node-js-d9b78ec5ffa8?source=collection_archive---------0-----------------------#2018-12-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/4a442260713a6a6167a0080320b33ebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKGr93u3QnEYhH8ws3iLvQ.png"/></div></div></figure><p id="f6da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本文中，我们将看到如何使用Node.js实现WebSocket服务器。</p><p id="eed0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们开始之前——如果你不熟悉作为传输协议的WebSockets，<a class="ae ka" href="https://ably.com/topic/websockets" rel="noopener ugc nofollow" target="_blank">这里有一篇精彩的文章，你应该读一读</a>。你可以通过另一篇关于<a class="ae ka" href="https://ably.com/topic/long-polling" rel="noopener ugc nofollow" target="_blank">长时间投票</a>的伟大文章来进一步学习。</p><p id="a15c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为此，我将使用Node.js(在撰写本文时，我的机器上已经安装了10.7版本)。</p><p id="5a44" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您的服务器可能正在运行Go，。NET，Java，或者别的什么。每种环境中的实现都将根据可用的HTTP服务器库而有所不同。</p><p id="a416" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽管实际的概念是相当一致的。它们都遵循相同的标准规范来解释和构造HTTP请求和响应，以及解析和生成使用<a class="ae ka" href="https://www.ably.io/topic/websockets" rel="noopener ugc nofollow" target="_blank"> WebSocket </a>成帧协议的数据。</p><p id="c7ca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不过现在，我假设您至少对Node.js有所了解。</p><p id="8642" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注意:</strong>如果你一生中从未接触过Node.js，你应该查阅几个<a class="ae ka" href="https://www.youtube.com/watch?v=w-7RQ46RgxU&amp;list=PL4cUxeGkcC9gcy9lrvMJ75z9maRw4byYp" rel="noopener ugc nofollow" target="_blank"> Node.js教程</a>来获得一个在你的机器上运行的简单Node.js服务器。您还应该了解如何使用NPM安装包，因为随着我们的继续，我假设您至少对这些有一点熟悉。</p><p id="a1b9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在构建一个<a class="ae ka" href="https://ably.com/topic/websockets" rel="noopener ugc nofollow" target="_blank"> WebSocket </a>服务器时，有很多事情需要考虑，这里的意图只是演示一个起点。</p><p id="ee96" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">诸如可伸缩性、性能、连接恢复、不同边缘情况的健壮处理、大型消息(例如10kb+)的处理等主题超出了本教程的范围。</p><p id="d919" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在客户端，除了使用现代浏览器默认内置的<code class="eh kb kc kd ke b">WebSocket</code>类之外，您实际上不需要做任何特殊的事情。一个可能的例外是，如果您在浏览器环境之外实现定制的东西，比如某种定制的移动硬件。</p><p id="974e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是在服务器上，除非您使用已经安装的WebSocket服务器库，否则您需要自己处理HTTP连接WebSocket升级握手。</p><p id="d60d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，您需要读取通过HTTP套接字连接接收的原始二进制数据，并根据WebSocket帧协议规范对其进行转换。这在RFC 6455 的第5节<a class="ae ka" href="https://tools.ietf.org/html/rfc6455#section-5" rel="noopener ugc nofollow" target="_blank">中有所概述。</a></p><p id="7ae9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，服务器需要根据相同的规范构造自己的消息，并通过开放套接字连接将它们发送回客户机。</p><h1 id="8442" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">设置您的项目环境</h1><p id="b28f" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">在一个新文件夹中，确保你已经准备好了一个<code class="eh kb kc kd ke b">package.json</code>文件，然后是<code class="eh kb kc kd ke b">npm install node-static</code>。这将有助于我们快速提供您的客户端文件。</p><p id="2205" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">创建以下文件:</p><h2 id="3b92" class="li kg hu bd kh lj lk ll kl lm ln lo kp jn lp lq kt jr lr ls kx jv lt lu lb lv dt translated">1.server.js:</h2><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="c64b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">node-static</code>库是一种便利，它负责处理响应静态HTML和JavaScript文件请求的复杂过程，这些文件将在浏览器的客户端运行。</p><h2 id="d166" class="li kg hu bd kh lj lk ll kl lm ln lo kp jn lp lq kt jr lr ls kx jv lt lu lb lv dt translated">2.client.js:</h2><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="0fcf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面只是一个存根，所以你知道你的客户端脚本实际上已经正确加载。我们将在下面继续实现时填写它。</p><h2 id="5990" class="li kg hu bd kh lj lk ll kl lm ln lo kp jn lp lq kt jr lr ls kx jv lt lu lb lv dt translated">3.index.html:</h2><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="986a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以上是前端的基本HTML框架。</p><p id="6060" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，从终端/控制台运行:</p><pre class="lw lx ly lz fq mc ke md me aw mf dt"><span id="9021" class="li kg hu ke b fv mg mh l mi mj">node server.js</span></pre><p id="08f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您应该看到:</p><pre class="lw lx ly lz fq mc ke md me aw mf dt"><span id="6086" class="li kg hu ke b fv mg mh l mi mj">Server running at <a class="ae ka" href="http://localhost:3210" rel="noopener ugc nofollow" target="_blank">http://localhost:3210</a></span></pre><p id="18c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">打开浏览器，加载<code class="eh kb kc kd ke b">index.html</code>文件。从浏览器的开发工具中，你应该可以看到<code class="eh kb kc kd ke b">client.js</code>脚本的控制台输出，如下所示:</p><pre class="lw lx ly lz fq mc ke md me aw mf dt"><span id="59e6" class="li kg hu ke b fv mg mh l mi mj">WebSocket client script will run here.</span></pre><h1 id="eb5c" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">开始使用HTTP</h1><p id="4411" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">在定义WebSocket标准时，早期的考虑之一是确保它与web“配合良好”。</p><p id="6e71" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这意味着要认识到网络通常是使用URL来寻址的，而不是IP地址和端口号。WebSocket连接应该能够与用于任何其他类型的web请求的相同的基于HTTP的初始握手发生。</p><h2 id="a395" class="li kg hu bd kh lj lk ll kl lm ln lo kp jn lp lq kt jr lr ls kx jv lt lu lb lv dt translated">下面是一个简单的HTTP GET请求中发生的情况</h2><p id="a8e3" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">假设有一个HTML页面托管在<a class="ae ka" href="http://www.example.com/index.html" rel="noopener ugc nofollow" target="_blank"><em class="mk">http://www.example.com/index.html</em></a>。</p><p id="9017" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">无需深入了解HTTP协议本身，只需知道请求必须以所谓的<a class="ae ka" href="https://tools.ietf.org/html/rfc2616#section-5.1" rel="noopener ugc nofollow" target="_blank">请求行</a>开始就足够了。</p><p id="f287" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来是一系列的键值对标题行。每一个都告诉服务器在报头数据之后的后续请求有效负载中会有什么，以及在它能够理解的响应类型方面，它可以从客户端得到什么。</p><p id="ef53" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请求中的第一个标记是HTTP方法。这将告诉服务器客户端针对所引用的URL正在尝试的操作类型。当客户机简单地请求服务器交付一个由指定URL引用的资源副本时，使用<code class="eh kb kc kd ke b">GET</code>方法。</p><p id="d572" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">根据HTTP RFC格式化的请求头的基本示例如下所示:</p><pre class="lw lx ly lz fq mc ke md me aw mf dt"><span id="62f4" class="li kg hu ke b fv mg mh l mi mj">GET /index.html HTTP/1.1<br/>Host: <a class="ae ka" href="http://www.example.com/" rel="noopener ugc nofollow" target="_blank">www.example.com</a></span></pre><p id="c073" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接收到请求报头后，服务器格式化以<a class="ae ka" href="https://tools.ietf.org/html/rfc2616#section-6.1" rel="noopener ugc nofollow" target="_blank">状态行</a>开始的响应报头。接下来是一组键-值头对，它们向客户机提供来自服务器的交互信息，这些信息与服务器正在响应的请求有关。</p><p id="e47f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">状态行告诉客户端HTTP状态代码(如果没有问题，通常是<code class="eh kb kc kd ke b">200</code>)。它还提供了一个简短的“原因”文本描述来解释状态代码。</p><p id="ca73" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来出现的是键-值头对，随后是所请求的实际数据(除非状态代码表明请求由于某种原因无法实现)。</p><pre class="lw lx ly lz fq mc ke md me aw mf dt"><span id="a6f3" class="li kg hu ke b fv mg mh l mi mj">HTTP/1.1 200 OK<br/>Date: Wed, 1 Aug 2018 16:03:29 GMT<br/>Content-Length: 291<br/>Content-Type: text/html<br/>(additional headers…)</span><span id="d6da" class="li kg hu ke b fv ml mh l mi mj">(response payload continues here…)</span></pre><p id="1206" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可能会问，这和<a class="ae ka" href="https://ably.com/topic/websockets" rel="noopener ugc nofollow" target="_blank"> WebSockets </a>有什么关系？</p><p id="ee4c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当发出HTTP请求并接收响应时，实际的双向网络通信发生在活动的TCP/IP套接字上。</p><p id="eb62" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">浏览器中请求的web URL通过全球DNS系统映射到一个IP地址，HTTP请求的默认端口是80。</p><p id="4c2c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这意味着即使在浏览器中输入了一个web URL，实际的通信也是通过TCP/IP进行的，使用的是类似于<code class="eh kb kc kd ke b">123.11.85.9:80</code>的IP地址和端口组合。</p><p id="e465" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">WebSockets也构建在TCP栈之上。这意味着我们需要的只是一种方法，让客户端和服务器同意保持套接字连接打开，并将其用于正在进行的通信。</p><p id="d3c4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果他们这样做了，那么他们就没有技术上的理由不能继续使用套接字来传输任何类型的任意数据。唯一的要求是它们都同意如何解释发送和接收的二进制数据。</p><p id="751f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了开始将HTTP TCP套接字重新用于<a class="ae ka" href="https://ably.com/topic/websockets" rel="noopener ugc nofollow" target="_blank"> WebSocket </a>通信，客户端可以包含一个专门为此类用例发明的标准请求头:</p><pre class="lw lx ly lz fq mc ke md me aw mf dt"><span id="ab2c" class="li kg hu ke b fv mg mh l mi mj">GET /index.html HTTP/1.1<br/>Host: <a class="ae ka" href="http://www.example.com/" rel="noopener ugc nofollow" target="_blank">www.example.com</a><br/>Connection: Upgrade<br/>Upgrade: websocket</span></pre><p id="b37a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">Connection</code>报头告诉服务器，客户端希望协商改变套接字的使用方式。伴随的值<code class="eh kb kc kd ke b">Upgrade</code>表示当前通过TCP使用的传输协议应该改变。</p><p id="5268" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">既然服务器知道客户机想要升级当前通过活动TCP套接字使用的协议，服务器就知道寻找相应的<code class="eh kb kc kd ke b">Upgrade</code>报头。这将告诉它客户端希望在连接的剩余生命周期中使用哪个传输协议。</p><p id="e66c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦服务器看到<code class="eh kb kc kd ke b">Upgrade</code>头的值<code class="eh kb kc kd ke b">websocket</code>，它就知道WebSocket握手过程已经开始。</p><p id="98e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">握手过程(以及其他一切)在<a class="ae ka" href="https://tools.ietf.org/html/rfc6455" rel="noopener ugc nofollow" target="_blank"> RFC 6455 </a>中有详细描述，如果你想更详细地了解这个主题的话。</p><p id="ab67" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更新server.js代码，使其能够响应HTTP升级请求:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="7ff2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Node.js完成了解析从客户端接收的HTTP请求的大部分繁重工作，正如您在上面的代码中看到的。</p><p id="d873" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们所需要做的就是监听<code class="eh kb kc kd ke b">upgrade</code>事件，然后检查<code class="eh kb kc kd ke b">Upgrade</code>报头是否试图切换到<a class="ae ka" href="https://ably.com/topic/websockets" rel="noopener ugc nofollow" target="_blank"> WebSocket </a>连接，而不是其他意外的事情。</p><p id="9764" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦我们完成了这些，我们就可以完成握手，然后继续发送和接收<a class="ae ka" href="https://ably.com/topic/websockets" rel="noopener ugc nofollow" target="_blank"> WebSocket </a>帧数据。</p><p id="80c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">RFC 的第<a class="ae ka" href="https://tools.ietf.org/html/rfc6455#section-4" rel="noopener ugc nofollow" target="_blank">部分概述了握手的详细细节。</a></p><h1 id="141c" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">避免有趣的事情</h1><p id="542d" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">除了上面描述的以外，WebSocket握手的第一部分包括证明这实际上是一个正确的WebSocket升级握手。证明流程没有被某种中间欺骗劫持是很重要的——要么被客户端劫持，要么被位于中间的代理服务器劫持。</p><p id="ac05" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当启动对WebSocket连接的升级时，客户端必须包含一个具有该客户端唯一值的<code class="eh kb kc kd ke b">Sec-WebSocket-Key</code>头。这里有一个例子:</p><pre class="lw lx ly lz fq mc ke md me aw mf dt"><span id="f58a" class="li kg hu ke b fv mg mh l mi mj">Sec-WebSocket-Key: BOq0IliaPZlnbMHEBYtdjmKIL38=</span></pre><p id="aab6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果使用现代浏览器中提供的<code class="eh kb kc kd ke b">WebSocket</code>类，以上是自动完成的。您只需要在服务器端寻找它并产生一个响应。</p><p id="527e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">响应时，服务器必须将特殊的GUID值<code class="eh kb kc kd ke b">258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>附加到键上，并生成结果字符串的阿沙-1散列。然后，它将此作为base-64编码的值包含在响应中的<code class="eh kb kc kd ke b">Sec-WebSocket-Accept</code>头中:</p><pre class="lw lx ly lz fq mc ke md me aw mf dt"><span id="6831" class="li kg hu ke b fv mg mh l mi mj">Sec-WebSocket-Accept: 5fXT1W3UfPusBQv/h6c4hnwTJzk=</span></pre><p id="5d5d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Node.js WebSocket服务器中，我们可以编写一个函数来生成这个值，如下所示:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="6fb5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后我们只需要调用这个函数，将<code class="eh kb kc kd ke b">Sec-WebSocket-Key</code>头的值作为参数传递，并在发送响应时将函数返回值设置为<code class="eh kb kc kd ke b">Sec-WebSocket-Accept</code>头的值。</p><p id="8e30" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要完成握手，请将适当的HTTP响应头写入客户端套接字。简单的回答应该是这样的:</p><pre class="lw lx ly lz fq mc ke md me aw mf dt"><span id="a52a" class="li kg hu ke b fv mg mh l mi mj">HTTP/1.1 101 Web Socket Protocol Handshake<br/>Upgrade: WebSocket<br/>Connection: Upgrade<br/>Sec-WebSocket-Accept: m9raz0Lr21hfqAitCxWigVwhppA=</span></pre><p id="e4ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">像这样更新您的<code class="eh kb kc kd ke b">server.js</code>脚本:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="afb1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这一点上，我们实际上还没有完全完成握手——还有几件事情需要考虑。</p><h1 id="02f9" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">子协议——就共享方言达成一致</h1><p id="692c" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">客户端和服务器通常需要就如何格式化、解释和组织数据本身达成一致的兼容策略。这既存在于给定的消息中，也随着时间的推移从一个消息到下一个消息。</p><p id="c3da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是子协议(前面提到的)的用武之地。</p><p id="bbab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果客户机知道它可以处理一个或多个特定的应用程序级协议(如WAMP、MQTT等)。)，它可以在发出初始HTTP请求时包含它所理解的协议列表。</p><p id="e035" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果是这样，则要求服务器要么选择这些协议中的一个并将其包含在响应报头中，要么握手失败并终止连接。</p><p id="c8ca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">子协议请求标题示例:</p><pre class="lw lx ly lz fq mc ke md me aw mf dt"><span id="d231" class="li kg hu ke b fv mg mh l mi mj">Sec-WebSocket-Protocol: mqtt, wamp</span></pre><p id="c2b8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">服务器在响应中发出的对等标头示例:</p><pre class="lw lx ly lz fq mc ke md me aw mf dt"><span id="c191" class="li kg hu ke b fv mg mh l mi mj">Sec-WebSocket-Protocol: wamp</span></pre><p id="09a6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，服务器必须从客户端提供的列表中选择一个协议。选择多个将意味着服务器无法可靠地解释后续WebSocket消息中的数据。</p><p id="24bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个例子是，如果服务器选择了<code class="eh kb kc kd ke b">json-ld</code>和<code class="eh kb kc kd ke b">json-schema</code>。两者都是基于JSON标准的数据格式。会有许多边缘情况，其中一个可能被解释为另一个，导致处理数据时出现意外错误。</p><p id="855a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然不可否认的不是消息传递协议本身，但是这个例子仍然适用。</p><p id="4b9b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当客户机和服务器都实现为从一开始就使用一个公共的消息传递协议时，可以在初始请求中省略<code class="eh kb kc kd ke b">Sec-WebSocket-Protocol</code>头。在这种情况下，服务器可以忽略这一步。</p><p id="2edd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当没有转发来保证一旦建立了WebSocket连接，客户机和服务器就能相互理解时，子协议协商是最有用的。</p><p id="040f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通用协议的标准化名称<a class="ae ka" href="https://tools.ietf.org/html/rfc6455#section-11.5" rel="noopener ugc nofollow" target="_blank">应在<a class="ae ka" href="https://www.iana.org/assignments/websocket/websocket.xml" rel="noopener ugc nofollow" target="_blank"> IANA注册中心注册</a>用于WebSocket子协议名称</a>。在撰写本文时，已经有36个名字被注册。其中包括<code class="eh kb kc kd ke b">soap</code>、<code class="eh kb kc kd ke b">xmpp</code>、<code class="eh kb kc kd ke b">wamp</code>、<code class="eh kb kc kd ke b">mqtt</code>等。</p><p id="304f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注册中心是将子协议名称映射到其解释的唯一来源。然而，唯一严格的要求是客户机和服务器就它们相互选择的子协议的实际含义达成一致。它是否出现在IANA注册表中并不重要。</p><p id="fded" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为握手中子协议的演示，让客户机和服务器在通信时都同意使用JSON格式的数据。</p><p id="9094" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如上所述，没有人强迫客户端和服务器只使用一个官方的子协议，或者子协议是一个真正的端到端消息传递协议。</p><p id="ada2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">出于以一致的方式格式化客户端和服务器消息的目的，简单地同意将<code class="eh kb kc kd ke b">json</code>作为子协议是完全有效的。这就是我们在这里要做的。作为起点，我们将把它添加到服务器代码中:</p><p id="f726" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">紧接在<code class="eh kb kc kd ke b">const responseHeaders = [ ... ];</code>语句之后:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="7a26" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注意:</strong>如果客户端请求使用子协议，但没有提供服务器能够支持的任何子协议，服务器必须发送失败响应并关闭连接。在这个实现中，我们不会为此费心。但是如果你想更进一步的话，你就需要这么做。</p><h2 id="3c00" class="li kg hu bd kh lj lk ll kl lm ln lo kp jn lp lq kt jr lr ls kx jv lt lu lb lv dt translated"><strong class="ak"> WebSocket扩展</strong></h2><p id="f30c" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">还有一个头，用于定义数据有效载荷编码和成帧方式的扩展。在撰写本文时，只存在一种标准化的扩展类型。它提供了一种web socket——相当于消息中的gzip压缩。</p><p id="7024" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">扩展可能发挥作用的另一个例子是多路复用——使用单个套接字来交错多个并发的通信流。</p><p id="ca33" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">WebSocket扩展是一个高级主题，超出了本文的范围。现在，只要知道它们是什么，以及它们是如何融入画面的就足够了。</p><h1 id="14c1" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">客户端:在浏览器中使用WebSockets</h1><p id="2c7b" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">在继续服务器实现之前，让我们先来看看客户端。毕竟，在没有客户机启动的情况下，测试服务器代码有点困难。</p><p id="bba4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">WebSocket API是在WHATWG HTML生活标准中定义的，实际上非常容易使用。首先，构造一个<code class="eh kb kc kd ke b">WebSocket</code>对象:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="3b28" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意在通常使用<code class="eh kb kc kd ke b">http</code>方案的地方使用了<code class="eh kb kc kd ke b">ws</code>。也可以选择在通常使用<code class="eh kb kc kd ke b">https</code>的地方使用<code class="eh kb kc kd ke b">wss</code>。这些协议是和<code class="eh kb kc kd ke b">WebSocket</code>规范一起引入的。它们被设计用来表示一个HTTP连接，该连接包含一个升级连接以使用WebSockets的请求。</p><p id="05f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">创建<code class="eh kb kc kd ke b">WebSocket</code>对象本身不会做很多事情。连接是异步建立的，因此在发送任何消息之前，您需要侦听握手的完成:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="0f23" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了从服务器接收消息，需要另一个事件侦听器:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="5e1e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有<code class="eh kb kc kd ke b">error</code>和<code class="eh kb kc kd ke b">close</code>事件。当连接终止时，WebSockets不会自动恢复。这是您需要自己实现的事情，也是为什么有许多客户端库存在的部分原因。</p><p id="e30e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然<code class="eh kb kc kd ke b">WebSocket</code>类简单易用，但它实际上只是一个基本的构建块。对不同子协议或附加功能的支持，如<a class="ae ka" href="https://ably.com/pub-sub-messaging" rel="noopener ugc nofollow" target="_blank">消息通道</a>必须单独实现。</p><h1 id="c155" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">自己试一试</h1><p id="9cf1" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">为了方便起见，测试<a class="ae ka" href="https://ably.com/pub-sub-messaging" rel="noopener ugc nofollow" target="_blank"> WebSockets </a>的公共echo服务器由<a class="ae ka" href="http://websocket.org/" rel="noopener ugc nofollow" target="_blank">websocket.org</a>托管。在您的浏览器中尝试以下代码。回显服务器接收您发送的任何消息，并将消息数据回显到发出消息的WebSocket。</p><p id="57e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在您的<code class="eh kb kc kd ke b">client.js</code>脚本中输入以下内容并运行它，注意开发人员控制台:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="1922" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你应该看到“你好！”消息发送到echo服务器，然后在<code class="eh kb kc kd ke b">message</code>处理程序中接收回来:</p><pre class="lw lx ly lz fq mc ke md me aw mf dt"><span id="a76c" class="li kg hu ke b fv mg mh l mi mj">Sending: Hello!<br/>Received: Hello!</span></pre><p id="b2e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">完成后，修改代码，准备与您自己的WebSocket服务器进行通信:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="74c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，我在<code class="eh kb kc kd ke b">WebSocket</code>构造期间添加了一个额外的参数——一组将通过<code class="eh kb kc kd ke b">Sec-WebSocket-Protocol</code>请求头发送的子协议。</p><p id="9e5b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">与前面提供的服务器代码一样，服务器将从列表中选择<code class="eh kb kc kd ke b">json</code>，并将其包含在初始握手响应中。如果服务器没有选择指定的子协议之一，浏览器实现的WebSocket API将自动使连接失败。</p><p id="fdac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在实现过程中，尝试让服务器选择一个子协议，该子协议与在初始请求过程中从客户端接收到的不一致。客户端应该抛出一个错误并立即终止连接。</p><p id="d96e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的代码是我们将要使用的整个客户端脚本！您可以添加任何其他内容，但是该实现的其余部分将在服务器端进行。</p><h1 id="05fc" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">生成和解析WebSocket消息帧</h1><p id="4065" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">一旦握手响应被发送到客户机，我们就可以开始在客户机和服务器之间发送和接收消息。快速浏览一下RFC 的<a class="ae ka" href="https://tools.ietf.org/html/rfc6455#section-5" rel="noopener ugc nofollow" target="_blank">第5部分，了解一下所涉及的内容。</a></p><p id="d341" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">WebSocket消息在称为“帧”的包中传递。这些消息以消息头开始，以“有效载荷”——该帧的消息数据——结束。</p><p id="a0be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">大型消息可能会将数据分割成几个帧。在这种情况下，你需要记录你目前收到的信息，并在所有信息到达后将它们拼凑起来。</p><h1 id="a760" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">Node.js套接字缓冲区与WebSocket消息帧的对齐</h1><p id="cbb4" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">Node.js套接字数据(<a class="ae ka" href="https://nodejs.org/api/net.html#net_class_net_socket" rel="noopener ugc nofollow" target="_blank">我说的是这里的</a> <code class="eh kb kc kd ke b"><a class="ae ka" href="https://nodejs.org/api/net.html#net_class_net_socket" rel="noopener ugc nofollow" target="_blank">net.Socket</a></code>，不是WebSockets)是以缓冲块的形式接收的。这些是分开的，不考虑你的WebSocket框架从哪里开始或结束！</p><p id="5e8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这意味着，如果您的服务器正在接收被分割成多个WebSocket帧的大量消息，或者快速连续地接收大量消息，则不能保证Node.js套接字接收的每个数据缓冲区都将与构成给定帧的字节数据的开始和结束对齐。</p><p id="6560" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，在解析套接字接收的每个缓冲区时，需要跟踪一帧的结束位置和下一帧的开始位置。您需要确保已经接收了一个帧的所有字节的数据，然后才能安全地使用该帧的数据。</p><p id="490f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一帧可能在下一帧开始的同一个缓冲器的中途结束。也有可能一个帧被分割成几个缓冲器，这些缓冲器将被连续接收。</p><p id="3afc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下图夸大了这个问题。在大多数情况下，帧往往适合一个缓冲区。由于数据到达的方式，您经常会发现一个帧的开始和结束与套接字缓冲区的开始和结束一致。但是这并不是在所有情况下都可以依赖的，必须在实现过程中加以考虑。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/991e4a8442bfc26746bddcc88b4240b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zThLEh0mZwA6rG4q.png"/></div></figure><p id="e7aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这可能需要一些工作才能做好。</p><p id="0442" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于下面的基本实现，我跳过了任何处理大消息或跨多个框架拆分的消息的代码。</p><p id="b950" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样做需要跨多个帧的多个数据缓冲器的协调。这将使更多关于Node.js套接字而不是WebSockets的逻辑变得过于复杂。我在这里的目的是演示解析WebSocket帧以实现客户机和服务器之间的双向通信所需的一些底层工作。</p><h1 id="bea7" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">实现解析器</h1><p id="1c42" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">首先，用下面的代码更新<code class="eh kb kc kd ke b">server.js</code>代码:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="a2ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将从实现<code class="eh kb kc kd ke b">parseMessage</code>函数开始。</p><p id="adb6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">RFC实际上相当容易理解。帧中的字节序列<a class="ae ka" href="https://tools.ietf.org/html/rfc6455#section-5.2" rel="noopener ugc nofollow" target="_blank">使用下图在RFC </a>中进行布局:</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/9bb2cf39c5ade73d377c9acb2a3dfc9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/0*Y8skLxHH5Xl1COnd.png"/></div></figure><p id="4e6d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们来分解一下。有两种主要类型的帧:消息帧和控制帧。</p><p id="1623" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">消息帧携带消息数据(“有效载荷”)。控制帧用于其他目的，例如发送ping或pong，表示连接即将关闭，等等。</p><p id="2c07" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">WebSocket帧由一个标头组成，后跟消息有效负载(如果适用)。报头总是以两个字节(或16位)开始。</p><p id="beec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于消息帧，第一位告诉我们这是否是当前消息的最后一帧。如果您的消息帧很小(&lt; 126字节)，这个值将始终为<code class="eh kb kc kd ke b">1</code>。</p><p id="db87" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来是三个保留位(我们通常可以忽略它们)，然后是四个“操作码”位，它告诉我们这是哪种帧。</p><p id="b575" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">之后，有一个单独的位告诉我们消息有效负载是否被“屏蔽”(稍后将详细介绍)，然后是七个位表示有效负载中的字节数。</p><p id="b582" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不过7位并不算多，所以如果长度是126，那么我们可以预期实际有效载荷长度会多出两个字节(16位)。或者，如果长度是127，而不是两个字节，那么将有额外的八个字节来将长度存储为64位整数。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/0f620ad265722205ad4152e2c7b52202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/0*702ULBzGPiOXHaVl.png"/></div></figure><h1 id="101c" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">操作码:消息帧与控制帧</h1><p id="7fee" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">根据RFC:</p><pre class="lw lx ly lz fq mc ke md me aw mf dt"><span id="d958" class="li kg hu ke b fv mg mh l mi mj">Opcode: 4 bits</span><span id="edaa" class="li kg hu ke b fv ml mh l mi mj">Defines the interpretation of the “Payload data”. If an unknown<br/>opcode is received, the receiving endpoint MUST <em class="mk">Fail the<br/>WebSocket Connection</em>. The following values are defined.</span><span id="7517" class="li kg hu ke b fv ml mh l mi mj">%x0 denotes a continuation frame</span><span id="e655" class="li kg hu ke b fv ml mh l mi mj">%x1 denotes a text frame</span><span id="8ab1" class="li kg hu ke b fv ml mh l mi mj">%x2 denotes a binary frame</span><span id="89af" class="li kg hu ke b fv ml mh l mi mj">%x3–7 are reserved for further non-control frames</span><span id="b721" class="li kg hu ke b fv ml mh l mi mj">%x8 denotes a connection close</span><span id="7b8f" class="li kg hu ke b fv ml mh l mi mj">%x9 denotes a ping</span><span id="ee4e" class="li kg hu ke b fv ml mh l mi mj">%xA denotes a pong</span><span id="3ecf" class="li kg hu ke b fv ml mh l mi mj">%xB-F are reserved for further control frames</span></pre><p id="ab31" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要点:</p><ul class=""><li id="d2be" class="mp mq hu je b jf jg jj jk jn mr jr ms jv mt jz mu mv mw mx dt translated">当消息被分成多个帧时，使用连续帧。我们的实现只处理小消息，所以我们暂时不处理这种情况。但是如果您自己决定这样做，请记住，当您遇到一个连续帧时，这意味着操作码与序列中的初始消息帧相同，直到最后一个帧结束。您可以通过消息头的第一位来识别这一点。</li><li id="ca80" class="mp mq hu je b jf my jj mz jn na jr nb jv nc jz mu mv mw mx dt translated">我们一般只关心消息的文本帧和二进制帧。在我们的例子中，我们将只支持文本框架。您可以对图像、音频等使用二进制帧。</li><li id="a567" class="mp mq hu je b jf my jj mz jn na jr nb jv nc jz mu mv mw mx dt translated">您确实需要支持<code class="eh kb kc kd ke b">0x8</code>—“关闭”操作码——否则您不会知道客户端已经断开连接。</li></ul><p id="831e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们来实现它:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><h1 id="6b04" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">蒙版框架</h1><p id="2698" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">客户端发送的帧可能会被“屏蔽”(当客户端是浏览器时，情况总是如此)。这意味着浏览器将包括一个特殊的四字节“屏蔽密钥”，它必须与消息有效负载中的每个连续的四字节序列进行异或运算。结果将是实际数据。</p><p id="4887" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">屏蔽是一种确保消息帧保持完整性的机制，不会受到第三方(如中间代理服务器)的干扰。</p><p id="05e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果初始报头的第二个字节以设置为<code class="eh kb kc kd ke b">1</code>的第一个位开始，那么屏蔽键将占用有效载荷长度之后的四个字节(包括扩展有效载荷长度，如果存在的话)。</p><p id="fed8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先从缓冲区读取屏蔽键:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="5a26" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，从缓冲区读取数据:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="63b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kb kc kd ke b">data</code>缓冲区现在应该保存客户端发送的数据，这意味着我们所要做的就是将缓冲区解码成一个字符串:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><h1 id="7117" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">为响应消息构造帧缓冲器</h1><p id="ec66" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">根据RFC的说法，如果你能够成功地完成上述所有工作，那么响应应该是相当微不足道的——特别是因为服务器<em class="mk">发送的消息不应该被屏蔽</em>。</p><p id="0181" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了节省时间，实现如下:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><h1 id="dab1" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">将响应发送回客户端</h1><p id="6be2" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">您应该已经有了本文前面的代码，但是为了更好地总结，我将在这里重复一遍:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="e166" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此时，您可以从命令行运行您的服务器，然后在端口<code class="eh kb kc kd ke b">3210</code>上打开您的浏览器到<code class="eh kb kc kd ke b">localhost</code>。使用浏览器的开发工具，您将看到浏览器发送一条消息，服务器做出相应的响应。</p><p id="295a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请记住，我的实现还远未完成。也不是特别有效率。已经有许多现有的<a class="ae ka" href="https://ably.com/topic/websockets#some-of-the-open-source-web-socket-libraries-you-can-use-right-now" rel="noopener ugc nofollow" target="_blank"> WebSocket服务器实现</a>。</p><h1 id="1d56" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">继续前进——你可能会考虑的其他事情</h1><p id="df6d" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">WebSocket服务器的原始实现实际上只是这个过程的第一步。如果你想更进一步，以下是你需要考虑的一些事情:</p><ul class=""><li id="11ff" class="mp mq hu je b jf jg jj jk jn mr jr ms jv mt jz mu mv mw mx dt translated">你将支持什么样的框架扩展，比如每条消息压缩？</li><li id="64b6" class="mp mq hu je b jf my jj mz jn na jr nb jv nc jz mu mv mw mx dt translated">您的目标是什么程度的客户机互操作性？</li><li id="1592" class="mp mq hu je b jf my jj mz jn na jr nb jv nc jz mu mv mw mx dt translated">邮件的接收顺序是否与发送顺序相同？如果不是，如何防止这将您的应用程序置于无效状态？</li><li id="09f2" class="mp mq hu je b jf my jj mz jn na jr nb jv nc jz mu mv mw mx dt translated">你需要信息传递的保证吗？如果是这样，你能为此实施什么策略？</li><li id="9a11" class="mp mq hu je b jf my jj mz jn na jr nb jv nc jz mu mv mw mx dt translated">您的服务器上有多少个活动连接？</li><li id="cecb" class="mp mq hu je b jf my jj mz jn na jr nb jv nc jz mu mv mw mx dt translated">是否有任何连接占用了服务器的所有资源？</li><li id="6e5c" class="mp mq hu je b jf my jj mz jn na jr nb jv nc jz mu mv mw mx dt translated">是否有任何连接是空闲的，并且理想情况下应该被丢弃？</li><li id="9ac9" class="mp mq hu je b jf my jj mz jn na jr nb jv nc jz mu mv mw mx dt translated">平均连接寿命有多长？</li><li id="72b6" class="mp mq hu je b jf my jj mz jn na jr nb jv nc jz mu mv mw mx dt translated">连接是否被过早/意外地丢弃，如果是，如何保留诊断数据来解释原因？</li><li id="3d8d" class="mp mq hu je b jf my jj mz jn na jr nb jv nc jz mu mv mw mx dt translated">您是否经历过短暂的连接高峰，如果是，对您的服务器性能有什么影响？</li><li id="5748" class="mp mq hu je b jf my jj mz jn na jr nb jv nc jz mu mv mw mx dt translated">总体使用了多少带宽，它对您的预算有何影响？</li><li id="34aa" class="mp mq hu je b jf my jj mz jn na jr nb jv nc jz mu mv mw mx dt translated">您的服务器容量是否接近极限，如果不是，多久会达到极限？</li><li id="778c" class="mp mq hu je b jf my jj mz jn na jr nb jv nc jz mu mv mw mx dt translated">如果需要，您将如何自动添加额外的服务器容量？</li></ul><p id="2779" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">考虑可用的消息传递协议，如MQTT、WAMP等。，以及它们是否能为其中一些问题提供解决方案。考虑一下现有的库和框架，以及它们提供的除了简单、基本的WebSocket连接管理之外的附加特性。</p><p id="0766" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如需进一步阅读，您可以查看<a class="ae ka" href="https://ably.com/topic/websockets-nodejs" rel="noopener ugc nofollow" target="_blank">使用Node.js和WebSockets构建实时应用程序:客户端考虑事项</a>。</p><p id="ff64" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您特别需要扩展，但人力或专业知识有限，无法有效实现，那么可以考虑利用已经为您解决了这些问题的<a class="ae ka" href="https://ably.com/" rel="noopener ugc nofollow" target="_blank">基于云的实时消息解决方案</a>。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><a href="http://twitter.com/Srushtika"><div class="fe ff nd"><img src="../Images/01acb620ce6171e95f766d2926030752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQG-Z_HDGICkSdv51suwKg.jpeg"/></div></a><figcaption class="ne nf fg fe ff ng nh bd b be z ek">Srushtika is a Developer Advocate for Ably Realtime</figcaption></figure><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="ni mb l"/></div></figure></div></div>    
</body>
</html>