<html>
<head>
<title>A crash course on Serverless with AWS — Running Node.js 11 on Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS无服务器速成班—在Lambda上运行Node.js 11</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-crash-course-on-serverless-with-aws-running-node-js-11-on-lambda-6ac676841d8a?source=collection_archive---------10-----------------------#2018-12-12">https://medium.com/hackernoon/a-crash-course-on-serverless-with-aws-running-node-js-11-on-lambda-6ac676841d8a?source=collection_archive---------10-----------------------#2018-12-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/9af8284e7795fd96c4c282a555e81118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCZ99sB9Pm0Q3SU4CsaSuw.jpeg"/></div></div></figure><p id="8d13" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">相当令人兴奋的标题，不是吗？当我听说AWS正在为<a class="ae ka" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>增加对<a class="ae ka" href="https://aws.amazon.com/about-aws/whats-new/2018/11/aws-lambda-now-supports-custom-runtimes-and-layers/" rel="noopener ugc nofollow" target="_blank">定制运行时和层</a>的支持时，我兴奋不已。这意味着您现在可以构建自己的定制工件，使您能够在函数之间共享和管理公共代码。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff kb"><img src="../Images/03d16dd056bd8adf4783f161e5f19b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/1*_pGj3DixmBImxcAl_HWWdA.gif"/></div></figure><p id="d5e0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我不会说我听到公告就晕了。但是，我做到了。不要告诉任何人。</p><h1 id="d056" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">我们要做什么？</h1><p id="04da" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">本文将向您展示如何将一个定制的Node.js 11运行时连接到AWS Lambda。我们将用一个示例函数创建一个简单的无服务器项目，并添加一个使我们能够运行Node.js 11运行时的层。</p><h1 id="6f0c" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">它是如何工作的</h1><p id="c7da" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">要使用一个<a class="ae ka" href="https://docs.aws.amazon.com/lambda/latest/dg/runtimes-custom.html" rel="noopener ugc nofollow" target="_blank">定制运行时</a>，您必须指定在部署您的函数时提供一个。当函数被调用时，AWS Lambda将引导您的运行时代码，并通过运行时API与之通信，以执行函数代码。</p><p id="94ac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关于自定义运行时，这就足够了。什么是<a class="ae ka" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html" rel="noopener ugc nofollow" target="_blank"> AWS Lambda层</a>？它们是一种新型的工件，可以包含任意代码和数据。它可以同时被多个函数引用。太棒了。您的函数通常共享公共依赖项，如SDK、预建模块、库和框架。这里的踢球者，现在你也可以分享运行时！</p><p id="e8b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过使用AWS Lambda层，您可以管理跨多个功能使用的组件。允许更好的代码重用和更多的干代码。</p><p id="e75b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用它们很简单，你把公共代码放在一个zip文件中，然后把它作为一个层上传到AWS Lambda。您还可以将它作为CloudFormation模板上传，然后配置您的函数来使用它。图层内容将可用于您的功能代码。但是这是另一个教程的主题。</p><p id="e1ea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们开始使用自定义Node.js v11运行时吧！</p><h1 id="c902" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">配置项目</h1><p id="f458" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">我假设你已经对<a class="ae ka" href="https://serverless.com/framework/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>有了基本的了解。我也希望你有一个AWS帐户设置。如果你没有，<a class="ae ka" href="https://hackernoon.com/a-crash-course-on-serverless-with-node-js-632b37d58b44" rel="noopener ugc nofollow" target="_blank">请看看这个</a>。</p><p id="72c8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="lj">注</em> </strong> <em class="lj">:将无服务器框架升级到v1.34.0或更高版本，以支持分层</em></p><h2 id="7c17" class="lk kh hu bd ki ll lm ln km lo lp lq kq jn lr ls ku jr lt lu ky jv lv lw lc lx dt translated">1.创建服务</h2><p id="c8cb" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">一如既往，我们需要一个新的服务来保存我们所有的代码。</p><pre class="kc kd ke kf fq ly lz ma mb aw mc dt"><span id="4482" class="lk kh hu lz b fv md me l mf mg">$ sls create -t aws-nodejs -p node11 &amp;&amp; cd node11</span></pre><p id="f2c4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">运行这个命令后，您会发现自己在<code class="eh mh mi mj lz b">node11</code>目录中，旁边有一个很好的样板文件，可以开始构建您的函数。下一步是打开<code class="eh mh mi mj lz b">serverless.yml</code>并添加我们的层。</p><h1 id="e743" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">2.将Node11层添加到<code class="eh mh mi mj lz b">serverless.yml</code></h1><p id="9689" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">有许多预置层可供选择。幸运的是，无服务器社区非常棒！我们将继续获取<a class="ae ka" href="https://github.com/lambci/node-custom-lambda" rel="noopener ugc nofollow" target="_blank">自定义Node.js运行时</a>。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mk"><img src="../Images/2dc9162edd3e4f02b50a60e9d597f662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dUqJqqOZbRNENp_e.png"/></div></div></figure><p id="3e3e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以选择任何一个，但我会选择<code class="eh mh mi mj lz b">v11</code>。现在打开<code class="eh mh mi mj lz b">serverless.yml</code>，删除所有内容并粘贴进来。</p><pre class="kc kd ke kf fq ly lz ma mb aw mc dt"><span id="8745" class="lk kh hu lz b fv md me l mf mg">service: node11<br/><br/>provider:<br/>  name: aws<br/>  runtime: provided # set to provided<br/><br/>functions:<br/>  hello:<br/>    handler: handler.hello<br/>    events:<br/>      - http:<br/>          path: /<br/>          method: get<br/>    layers: # add layer<br/>      - arn:aws:lambda:us-east-1:553035198032:layer:nodejs11:3</span></pre><p id="0ea9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">添加ARN层就足够了，这个函数将获得运行时间。不要忘记添加<code class="eh mh mi mj lz b">runtime: provided</code>字段。</p><h1 id="0ce9" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">3.向<code class="eh mh mi mj lz b">handler.js</code>添加代码</h1><p id="3a7d" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">从这里开始，你会有宾至如归的感觉。你终于可以在AWS Lambda上写出血边Node.js代码了。我们等这一刻已经很久了。</p><p id="665e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">打开<code class="eh mh mi mj lz b">handler.js</code>并粘贴到下面的代码片段中。</p><pre class="kc kd ke kf fq ly lz ma mb aw mc dt"><span id="124b" class="lk kh hu lz b fv md me l mf mg">exports.hello = async (event, context) =&gt; {<br/>  console.log(`Hi from Node.js ${process.version} on Lambda!`)<br/>  return {<br/>    statusCode: 200,<br/>    body: JSON.stringify({ <br/>      message: `Hi from Node.js ${process.version} on Lambda!` <br/>    })<br/>  }<br/>}</span></pre><p id="90bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">相当简单的代码片段，但它证明了一个观点。确保我们正在运行<code class="eh mh mi mj lz b">Node.js v11.4.0</code>。</p><h1 id="2620" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">部署项目</h1><p id="d2d5" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">无服务器框架使部署变得快速而轻松。你需要做的就是运行一个命令。</p><pre class="kc kd ke kf fq ly lz ma mb aw mc dt"><span id="517d" class="lk kh hu lz b fv md me l mf mg">$ sls deploy</span></pre><p id="5471" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它将创建一个CloudFormation模板，提供资源并部署代码。全部在一个命令中。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ml"><img src="../Images/3e2cdc238048e37bc18179c0d6fe86c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zb8FK21lhNGPk_9r.png"/></div></div></figure><p id="8bb4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">部署进行得很顺利。用卷发点击网址，以确保它的工作。</p><pre class="kc kd ke kf fq ly lz ma mb aw mc dt"><span id="405b" class="lk kh hu lz b fv md me l mf mg">1 $ curl https://&lt;id&gt;.execute-api.us-east-1.amazonaws.com/dev/</span></pre><p id="33b9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你应该看到<code class="eh mh mi mj lz b">{"message":"Hi from Node.js v11.4.0 on Lambda!"}</code>得到回应。很好用！</p><h1 id="bebc" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">包扎</h1><p id="769e" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">随着AWS Lambda的最新改进、新的支持语言、新的运行时和层，它不仅仅是对主虚拟机和容器服务的支持服务。无服务器架构正在成为一股不可忽视的力量。我迫不及待地想看看它将把我们带向何方！</p><p id="2efb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://github.com/adnanrahic/sls-node11" rel="noopener ugc nofollow" target="_blank">这里是回购</a>如果你在跟随教程时卡住了，如果你想让更多人在GitHub上看到它，就给它一颗星。如果你想阅读我以前的一些无服务器思考，请前往<a class="ae ka" href="https://dev.to/adnanrahic" rel="noopener ugc nofollow" target="_blank">我的简介</a>或<a class="ae ka" href="https://upscri.be/b6f3d5/" rel="noopener ugc nofollow" target="_blank">加入我的无服务器时事通讯！</a></p><p id="34d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你需要一个<a class="ae ka" href="https://statsbot.co/cubejs/" rel="noopener ugc nofollow" target="_blank">无服务器分析框架</a>，请查看<a class="ae ka" href="https://statsbot.co/sign-up?cubejs=true" rel="noopener ugc nofollow" target="_blank"> Cube.js </a>。它是<a class="ae ka" href="https://github.com/statsbotco/cubejs-client" rel="noopener ugc nofollow" target="_blank">开源的，在GitHub上</a>。或者，如果您想了解更多关于无服务器架构的信息，可以在<a class="ae ka" href="https://statsbot.co/blog/" rel="noopener ugc nofollow" target="_blank"> Statsbot博客</a>上阅读更多与无服务器相关的文章。</p><p id="4ccf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">希望你们喜欢读它，就像我喜欢写它一样。如果你喜欢它，不要犹豫分享。别忘了给Statsbot博客一些爱。</p></div><div class="ab cl mm mn hc mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hn ho hp hq hr"><p id="134d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lj">原载于2018年12月12日</em><a class="ae ka" href="https://statsbot.co/blog/a-crash-course-on-serverless-with-aws-running-node11-on-lambda/" rel="noopener ugc nofollow" target="_blank"><em class="lj">statsbot.co</em></a><em class="lj">。</em></p></div></div>    
</body>
</html>