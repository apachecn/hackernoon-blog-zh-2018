<html>
<head>
<title>GraphQL Subscriptions vs. Live Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL订阅与实时查询</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/graphql-subscriptions-vs-live-queries-1578a8ac1e92?source=collection_archive---------3-----------------------#2018-12-13">https://medium.com/hackernoon/graphql-subscriptions-vs-live-queries-1578a8ac1e92?source=collection_archive---------3-----------------------#2018-12-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/89a72038b88333b2c5fa5a5fbf38a0aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rB1FJ2ZMoWg0wTVB"/></div></div></figure><p id="34b3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从GraphQL服务器获取实时数据有两种常见方式:订阅和实时查询。订阅看起来像这样:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="7ddf" class="kj kk hu kf b fv kl km l kn ko">subscription {<br/>  eventX {<br/>    <em class="kp">selection</em><br/>  }<br/>}</span></pre><p id="b6c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">实时查询如下所示:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="ce65" class="kj kk hu kf b fv kl km l kn ko">@live<br/>query {<br/>  <em class="kp">selection</em><br/>}</span></pre><p id="64cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kq" href="https://github.com/facebook/graphql/issues/284" rel="noopener ugc nofollow" target="_blank">订阅和直播查询有什么区别</a>？什么时候你会使用其中一个还是另一个？让我们从理论和实例上比较一下订阅和实时查询。</p><h1 id="8522" class="kr kk hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">类似</h1><h2 id="dab9" class="kj kk hu bd ks lo lp lq kw lr ls lt la jn lu lv le jr lw lx li jv ly lz lm ma dt translated">可预测的响应流:是</h2><p id="d129" class="pw-post-body-paragraph jc jd hu je b jf mb jh ji jj mc jl jm jn md jp jq jr me jt ju jv mf jx jy jz hn dt translated">两者都是请求/流操作，其中服务器以客户机请求文档指定的形式，用GraphQL响应流来响应客户机请求。一个警告:一些实时查询实现发送差异，而不是整个有效负载。</p><h2 id="d065" class="kj kk hu bd ks lo lp lq kw lr ls lt la jn lu lv le jr lw lx li jv ly lz lm ma dt translated">灵活的传输/协议:是</h2><p id="5516" class="pw-post-body-paragraph jc jd hu je b jf mb jh ji jj mc jl jm jn md jp jq jr me jt ju jv mf jx jy jz hn dt translated">两者都可以使用各种传输/协议组合。</p><p id="3241" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">示例传输:TCP、WebSocket、UDP、SSE、HTTP长轮询。</p><p id="c5d3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">示例协议:MQTT、Socket.io、Redis、AMQP、RSocket。</p><p id="85f8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们有意在<a class="ae kq" href="https://facebook.github.io/graphql/June2018/#sec-Subscription" rel="noopener ugc nofollow" target="_blank">规范</a>中保留这一点，因为传输不可避免地会因组织和用例而异。然而，特定的传输/协议组合不太可能只服务于一种操作而不服务于另一种操作。</p><h2 id="6b7b" class="kj kk hu bd ks lo lp lq kw lr ls lt la jn lu lv le jr lw lx li jv ly lz lm ma dt translated">有状态服务器和反应式基础设施:是</h2><p id="8e46" class="pw-post-body-paragraph jc jd hu je b jf mb jh ji jj mc jl jm jn md jp jq jr me jt ju jv mf jx jy jz hn dt translated">对于订阅，我们需要某种发布订阅系统。对于无法满足轮询需求的实时查询系统，我们需要反应式数据源(比如让您跟踪查询的数据库)，以及配套的编程模型(比如<a class="ae kq" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank"> Rx </a>)。在这两种情况下，服务器都需要存储每个操作执行请求，订阅底层的源流，并维护一个返回到客户端的长期连接的索引。简而言之，你需要某种实时网关。当客户端断开连接时，服务器还负责回收每个客户端的内存/连接。</p><h2 id="baec" class="kj kk hu bd ks lo lp lq kw lr ls lt la jn lu lv le jr lw lx li jv ly lz lm ma dt translated">保证，按顺序，恰好一次:否</h2><p id="5f61" class="pw-post-body-paragraph jc jd hu je b jf mb jh ji jj mc jl jm jn md jp jq jr me jt ju jv mf jx jy jz hn dt translated">这两种操作都不包括对非功能性网络交付能力的限制或保证，例如有保证的有序交付(尽管TCP在传输层提供这些)。例如，如果您通过UDP实现GraphQL响应流，并且响应负载在传输过程中被丢弃，则您是否选择重新发送被丢弃的负载与操作类型无关。</p><h2 id="554b" class="kj kk hu bd ks lo lp lq kw lr ls lt la jn lu lv le jr lw lx li jv ly lz lm ma dt translated">缓冲、节流:否</h2><p id="ac28" class="pw-post-body-paragraph jc jd hu je b jf mb jh ji jj mc jl jm jn md jp jq jr me jt ju jv mf jx jy jz hn dt translated">任何长期存在的连接都容易受到破坏。对于像聊天记录这样的用例，断开连接后重新同步客户端和服务器之间的状态是很重要的。有时，这可以通过检测服务器上的断开连接，在客户端重新联机时缓冲有效负载并重放它们来实现。其他时候，服务器可能会向客户端发送过多的数据；客户端和服务器可能同意某种流量控制协议。</p><p id="7977" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这两个公共特性可以独立于操作类型被支持或忽略，甚至在操作类型中也是如此。例如，假设您有两个订阅:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="f758" class="kj kk hu kf b fv kl km l kn ko">subscription a { <br/>  superImportantMessage {<br/>    message<br/>  }<br/>}</span><span id="3738" class="kj kk hu kf b fv mg km l kn ko">subscription b { <br/>  poke {<br/>    poke<br/>  }<br/>}</span></pre><p id="a748" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">服务器可能支持其中一个订阅的脱机缓冲，但不支持另一个订阅。这是完全有效的，而不是我们应该在规范中锁定的东西。</p><h1 id="d5ba" class="kr kk hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">差异</h1><h2 id="9cd6" class="kj kk hu bd ks lo lp lq kw lr ls lt la jn lu lv le jr lw lx li jv ly lz lm ma dt translated">“按需”直播</h2><p id="3e98" class="pw-post-body-paragraph jc jd hu je b jf mb jh ji jj mc jl jm jn md jp jq jr me jt ju jv mf jx jy jz hn dt translated">通过添加指定的live指令，可以将普通查询转换为实时查询。相反，您可以忽略live指令，将live查询视为普通查询。例如，如果WebSocket服务器不可用，可以通过HTTP查询。相反，订阅操作不能被轮询，也不能在实时和请求/响应模式之间切换。个人认为这就是活查询的超能力。</p><h2 id="3316" class="kj kk hu bd ks lo lp lq kw lr ls lt la jn lu lv le jr lw lx li jv ly lz lm ma dt translated">规格</h2><p id="2df1" class="pw-post-body-paragraph jc jd hu je b jf mb jh ji jj mc jl jm jn md jp jq jr me jt ju jv mf jx jy jz hn dt translated">订阅是GraphQL操作，在<a class="ae kq" href="https://facebook.github.io/graphql/June2018/#sec-Subscription" rel="noopener ugc nofollow" target="_blank">规范</a>中定义。规范中没有正式定义实时查询。相反，它们是由查询操作的特殊指令指定的。特定的指令可以随实现而变化，例如:@live、@fb_live、@live_query。</p><h2 id="c3e5" class="kj kk hu bd ks lo lp lq kw lr ls lt la jn lu lv le jr lw lx li jv ly lz lm ma dt translated">声明和客户合同</h2><p id="d3c6" class="pw-post-body-paragraph jc jd hu je b jf mb jh ji jj mc jl jm jn md jp jq jr me jt ju jv mf jx jy jz hn dt translated"><a class="ae kq" href="https://youtu.be/BSw05rJaCpA?t=579" rel="noopener ugc nofollow" target="_blank">订阅观察事件，直播查询观察数据</a>。客户端可以使用订阅操作关键字来指示订阅操作:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="95d3" class="kj kk hu kf b fv kl km l kn ko">subscription {<br/>  eventX {<br/>    <em class="kp">selection</em><br/>  }<br/>}</span></pre><p id="5546" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们执行上面的操作时，我们告诉服务器，“每当eventX发生时，执行<em class="kp">选择</em>并将结果发送给我”。</p><p id="8d40" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要执行实时查询，客户端需要包含一个在客户端和服务器之间预先协商好的指令，比如“@live”。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="cca3" class="kj kk hu kf b fv kl km l kn ko">@live<br/>query {<br/>  <em class="kp">selection</em><br/>}</span></pre><p id="63ad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们执行上面的操作时，我们告诉服务器，“立即评估[选择]，然后每当[选择] <em class="kp">将产生不同的响应</em>时，就给我发送一个新的有效负载”。换句话说，实时查询响应流应该类似于对长期查询的无限快速和廉价的轮询，同时丢弃重复的响应。</p><h2 id="ac9c" class="kj kk hu bd ks lo lp lq kw lr ls lt la jn lu lv le jr lw lx li jv ly lz lm ma dt translated">规模成熟</h2><p id="4be2" class="pw-post-body-paragraph jc jd hu je b jf mb jh ji jj mc jl jm jn md jp jq jr me jt ju jv mf jx jy jz hn dt translated">脸书从2015年开始在内部开发GraphQL订阅<a class="ae kq" href="https://graphql.org/blog/subscriptions-in-graphql-and-relay/" rel="noopener ugc nofollow" target="_blank">，并使用它来支持全球范围的功能，如实时评论和流媒体反应。对实时查询的支持是后来才出现的，据我所知，还没有达到订阅的规模。在脸书之外的成熟组织中，例如，</a><a class="ae kq" href="https://aws.amazon.com/appsync" rel="noopener ugc nofollow" target="_blank"> AppSync </a>，Apollo和Prisma，他们在大规模操作订阅方面似乎比实时查询更有经验。当然，这可能会随着时间的推移而改变。</p><h2 id="c9a9" class="kj kk hu bd ks lo lp lq kw lr ls lt la jn lu lv le jr lw lx li jv ly lz lm ma dt translated">服务支持</h2><p id="7bbf" class="pw-post-body-paragraph jc jd hu je b jf mb jh ji jj mc jl jm jn md jp jq jr me jt ju jv mf jx jy jz hn dt translated">有很多支持GraphQL订阅的库和服务，比如前面提到的<a class="ae kq" href="https://aws.amazon.com/appsync" rel="noopener ugc nofollow" target="_blank"> AWS AppSync </a>。<a class="ae kq" href="https://hasura.io/" rel="noopener ugc nofollow" target="_blank"> Hasura </a>支持订阅和实时查询，Apollo客户端可以通过其内置的<a class="ae kq" href="https://www.apollographql.com/docs/react/essentials/queries.html#refetching" rel="noopener ugc nofollow" target="_blank">轮询特性</a>近似实时查询的行为。</p><h1 id="41d7" class="kr kk hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">今天和明天的实时查询</h1><p id="af76" class="pw-post-body-paragraph jc jd hu je b jf mb jh ji jj mc jl jm jn md jp jq jr me jt ju jv mf jx jy jz hn dt translated">您在生产中使用实时查询吗？你愿意吗？我们应该在规范中添加实时查询吗？如果是的话，我们应该说他们什么？</p></div></div>    
</body>
</html>