<html>
<head>
<title>C From a COBOL Perspective</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从COBOL的角度来看</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/c-from-a-cobol-perspective-444dc30554d6?source=collection_archive---------4-----------------------#2018-12-13">https://medium.com/hackernoon/c-from-a-cobol-perspective-444dc30554d6?source=collection_archive---------4-----------------------#2018-12-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="98dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我最初是在1986年为一本印刷杂志写的这篇文章。我当时23岁，已经做了四年COBOL，最初是在穿孔卡片上。我开始听说C语言，并自学了它，将一点COBOL语言重写为C语言(注意，C语言是COBOL语言的可怕替代品)，我写这篇文章是为了让其他COBOL程序员了解C语言。大约10年前，我在一篇博客文章中更新了介绍，但在过去的两周里，我与半打不了解COBOL语言的人分享了这篇文章。 简单地说，我可以向他们描述COBOL记录结构，我觉得这是非常强大的，在大多数现代语言中也没有表现出来。 这是我目前正在设计的一种新语言，所以请享受这种来自过去的爆炸，并了解你的祖父母在“过去的日子”做什么。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff jp"><img src="../Images/272af4dab93694f9af93022939922671.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/0*dmgIp8JwxcLVENXR.jpg"/></div></figure><p id="0ebf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">年轻的程序员很难相信，世界上至少65%的代码仍然是用COBOL编写的，每年有50亿行新代码被编写出来。COBOL应用程序每天处理的数据是Google的200倍。他们甚至不再在学校里教这个了，这是一个遗憾，因为COBOL是一种非常棒的商业语言，比现有的任何语言都好，除了Python。这是因为它具有健壮的记录结构、干净的字符串变量和条件逻辑。虽然本文主要是为了让COBOL程序员理解C，但是您可以很容易地颠倒这些例子。在某个时候，旧的COBOL代码将不得不被重写或维护，一个原因是它仍然存在，并且需要很少的手握，因为COBOL是多么稳定和干净。</p><p id="bc35" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请记住，C和COBOL来自完全不同的根源，这使得比较非常困难。</p><p id="1631" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">预处理器</strong></p><p id="786f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">COBOL为我们提供了几个共享先前定义的记录布局和变量声明的选项。最简单直接的是$INCLUDE 'filename '。这将获取一个文件，并在编译时将其复制到源文件中。如果您不担心修改任何语句，这就很好，类似于Python中的“导入”或C/c++/等中的“包含”。</p><p id="687d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更通用的选择是使用COBEDIT并维护一个COPYLIB。使用COPY命令从COPYLIB中检索成员的优点是可以进行动态文本替换。因此，如果您想要两次定义您的客户主数据集，一次为数据集，一次为文件，您可以在COPYLIB中设置一个前缀，您可以在编译时使用命令更改它；</p><p id="cbb3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">COPY textname REPLACING ==pseudo-text-1== BY ==pseudo-text-2==.</code></p><p id="6772" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从而消除了在COPYLIB中维护两个不同定义的需要。</p><p id="8546" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然C有一个“include”语句，但它没有与COPY语句等价的语句。但是，通过使用' #if '，' #ifdef '，' #elif '和' #ifndef '命令，您可以控制在编译时包含哪些文件。比方说，你正在编写某种可移植的应用程序，你在不同的文件中定义了不同的文件I/O函数来适应不同的平台。您可以用下面的结构非常容易地控制它；</p><p id="67bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">#define SYS "Windows"<br/>#if SYS == "Windows"<br/>#include "windows.h"<br/>#elif SYS == "MacOS"<br/>#include "macos.h"<br/>#elif SYS == "Linux"<br/>#include "linux.h"<br/>#endif</code></p><p id="101b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有几个重要的东西需要学习；首先，#define命令实际上与COBOL中的$DEFINE几乎相同。它们都允许你定义和命名一个宏，这个宏会创建“内联”代码，所以如果代码稍微大一点的话，它会生成更高效的代码。然而，COBOL define语句可以是您想要的长度，而许多C编译器限制您只能使用包含#define语句的那一行。向C宏传递参数也更令人困惑，只是要确保用括号来保证优先顺序。</p><p id="c57c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，#define也可以像COBOL中的88级变量一样工作；</p><p id="9844" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">#define FALSE 0<br/>#define TRUE !FALSE</code></p><p id="639b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我可以说‘if FALSE ’,就像在COBOL中用88一样。这里的优点是我可以通过使用！(这意味着不是)在第二个#define语句中。这在COBOL中并没有真正的对等词。</p><p id="038b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">既然我已经解释了足够多的#define语句来帮助我们完成第一个例子，为什么不解释完这个例子呢？</p><p id="4f4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为我们已经定义SYS等于字符串HP3000，所以第一个#if语句将为真，文件hp3kio.h将在编译时复制到程序中。#elif是‘else if’的一种非常愚蠢的表达方式，只有汇编神知道他们为什么选择这样的缩写。因此，如果我们想编译我们的代码在VAX上运行，我们只需要更改#define行，然后如果我们正确地完成了初始设置，我们的代码将在VAX上运行。</p><p id="06ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">信不信由你，使用COBOL中鲜为人知和很少使用的编译器开关，你可以完成几乎同样的事情。通过使用以下命令，您可以实现类似的效果。</p><p id="f83e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">$SET X0=OFF<br/>$IF X0=OFF<br/>COPY WINDOWS<br/>$IF X0=ON<br/>COPY LINUX<br/>$IF</code></p><p id="baf4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">值得注意的是，虽然COBOL不区分大小写，但C是区分大小写的。所以myvar，MYVAR，和Myvar实际上是三个不同的东西。我见过的一个非正式的标准是，你所有的“常规”C代码都是小写的，你定义的任何宏，有时是函数，都是大写的，这样可以很快很容易地区分什么是C的一部分，什么是你的。这绝对不是个坏主意。</p><p id="6827" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们讨论入门时，最后一点要注意的是如何在代码中加入注释。在COBOL中，你在第7列放一个*号，然后输入你想要的任何内容，或者你可以使用每行的最后5个字符来输入有意义的内容。在C语言中，我们的注释必须用匹配的/* … */括起来，这可以出现在一行命令中，可以单独出现，也可以跨行出现。这里有几个例子；</p><p id="5c40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">/* here is my comment */<br/>/*<br/>here is another comment<br/>that spans multiple lines<br/>*/</code></p><p id="71f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">a = b；/*下面是一行命令的注释*/</p><p id="969d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">变量声明</strong></p><p id="8eb5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最明显的下一步是如何在C中定义变量。这是C在某些方面优于COBOL的地方，因为你可以定义全局和局部变量。这相当于在COBOL程序中有一个状态验证段落，在该段落的顶部声明了它需要的所有变量，然后当该段落返回到调用进程时，这些变量就消失了。想象一下，不再声明只使用过一次的全局变量。</p><p id="539e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">c与COBOL在定义变量的方式上有很大的不同。</p><pre class="jq jr js jt fq kb ka kc kd aw ke dt"><span id="4d62" class="kf kg hu ka b fv kh ki l kj kk">COBOL          C<br/>---------------------------------------------------------</span><span id="4177" class="kf kg hu ka b fv kl ki l kj kk">PIC S9(4) COMP short<br/>PIC S9(9) COMP long<br/>PIC 9          char</span></pre><p id="e762" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在C语言中声明简单整数的一个重要注意事项是，标准声明应该是“int my_counter”。现在，my_counter的长度将取决于声明它的机器的本机架构。因此，在16位系统上，说“int”将声明一个16位整数或PIC S9(4) COMP。问题是，如果您将代码转移到32位系统，那么声明将突然变成32位或PIC S9(9) COMP。我们通过将它们声明为16位的“短整型”或32位的“长整型”来解决这个问题。</p><p id="cbb4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的下一个变量类型是字符串或字符数组。c处理字符串的方式完全不同。因为一切都是单个字符，你必须定义一个字符数组，这也是你引用它的方式。这里有一个例子，告诉你如何用COBOL来做这件事，以及如果它像C语言一样工作，你必须如何用COBOL来做这件事；</p><p id="d455" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">char name[8]; /* a variable called name that is eight characters */<br/>01 NAME PIC X(08).</code></p><p id="7ead" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者是否像C语言那样定义</p><pre class="jq jr js jt fq kb ka kc kd aw ke dt"><span id="46e4" class="kf kg hu ka b fv kh ki l kj kk">01 NAME-ARRAY<br/>   05 NAME PIC X OCCURS 8 TIMES.</span></pre><p id="da8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上，C语言中的字符数组总是以空字符结束，所以如果你需要一个8字符的数组，你需要把它变成9个，以考虑到末尾的空字符。</p><p id="68b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在C #中，将字符数组初始化为空格的唯一方法是将单个字符移动到数组的每个元素中。这里有两种语言供你选择；</p><p id="e65c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">01 NAME PIC X(08) VALUE SPACES.</code></p><p id="b28d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者</p><p id="3e72" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">MOVE SPACES TO NAME.</code></p><p id="c96a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者</p><p id="59aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">INITIALIZE NAME.</code></p><p id="413c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">int I；<br/>char name[9]；<br/>for(I = 1；I&lt;= 9；i++)<br/>name[I]= " "；</p><p id="5199" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很恶心吧？后面我会解释C语句里所有没有意义的东西。c也区分字符和字符串。因为' char '类型实际上只声明了一个不需要空终止的字符，所以这两个声明是不同的；</p><p id="2171" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">char switch;<br/>char switch2[1];</code></p><p id="3278" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上，您需要将“switch2”变成一个由两个字符组成的数组，这样它才能像您所期望的那样工作，因为字符串上有空终止符。在C语言中用\0定义了一个空值，所有的字符串操作函数都依赖于空字符的正确位置，这样才能得到预期的输出。</p><p id="f225" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在C语言中，一个字符和一个字符串之间的区别需要一点时间来适应，例如，如果你想将我们的字符变量switch初始化为Y，你可以用单引号将它括起来。单引号表示它是一个单独的字符，而对于switch2，您将使用双引号”来括住字符串，即“Y”。保持这一点很重要，如果你不正确地使用它，一些编译器不会抱怨，你可能会得到一些不可预知的结果。</p><p id="b159" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们知道了如何在C中声明简单的变量，那么我们如何声明一个类似于COBOL中01变量声明的记录结构呢？在C语言中有一个被称为“struct”的东西就是为了这个目的而使用的，尽管它的实现有点奇怪。首先让我们用COBOL声明一个简单的布局，然后我用C做同样的事情；</p><pre class="jq jr js jt fq kb ka kc kd aw ke dt"><span id="dbb4" class="kf kg hu ka b fv kh ki l kj kk">01 CUST-MAST<br/>   03 CM-NUMBER  PIC X(06).<br/>   03 CM-NAME    PIC X(30).<br/>   03 CM-AMT-OWE PIC S9(9) COMP.<br/>   03 CM-YTD-BAL PIC S9(9) COMP OCCURS 12.<br/>   03 CM-PHONE   PIC X(10).</span><span id="3d28" class="kf kg hu ka b fv kl ki l kj kk">struct customer_master {<br/>       char cm_number[7];<br/>       char cm_name[31];<br/>       long cm_amt_owe;<br/>       long cm_ytd_bal[12];<br/>       char cm_phone[10];<br/>       };</span><span id="c256" class="kf kg hu ka b fv kl ki l kj kk">struct customer_master cust_mast;</span></pre><p id="052c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">“struct”谓词声明了您所关心的记录类型的模板，一旦声明了模板，您就可以声明一个属于该结构类型的变量。所以这一行:<code class="eh jx jy jz ka b">struct customer_master cust_mast</code>声明一个变量‘cust _ mast’是‘customer _ master’类型。然后，您可以通过指定变量名称dot member(即cust_mast.cm_name)来引用该结构的成员。如果您要将一个结构用于不同的目的，这将非常方便。这里的缺点是，如果不单独处理每个成员，就没有方便的方法来初始化结构内部的变量。COBOL有非常方便的INITIALIZE动词来做这件事，你可以用C写一个通用的初始化函数来达到同样的目的。如果不想重用，可以在声明的同时命名该结构。在}之后和之前；只需输入你想让它拥有的旧变量名。工作存储部分使用的最后一个常用动词是REDEFINES。C语言版本是“联合”动词。重定义对于处理字母或数字变量非常方便。由于字节引用是在COBOL-85中引入的，所以你很难再看到一个REDEFINE语句用于获取变量中的各种子字符串。现在让我们看看如何声明一个重定义和一个“联合”。</p><pre class="jq jr js jt fq kb ka kc kd aw ke dt"><span id="e04b" class="kf kg hu ka b fv kh ki l kj kk">01 CUST-MASTER<br/>   03 CM-DAYS-LATE PIC XXX.<br/>   03 CM-DL-REDEFINE REDEFINES CM-DAYS-LATE.<br/>      05 CM-DL-NUM PIC 999.</span><span id="fe08" class="kf kg hu ka b fv kl ki l kj kk">union redef {<br/>      char days_late[4];<br/>      int dl_num;<br/>      };</span><span id="eb47" class="kf kg hu ka b fv kl ki l kj kk">union redef days_late_test;</span></pre><p id="b00e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">联合的设置和使用与结构非常相似，您甚至可以将联合放在结构中，这也是您大多数时候想要使用它的地方。我们将“days_late”作为一个由4个字符组成的数组，因为我们必须记住考虑空字符。如果你愿意，你可以对工会做各种奇怪的事情，但这确实是我要谈的全部。</p><p id="b459" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想谈的另一种类型是枚举类型。通过使用“enum”关键字，我们可以创建一个新的“类型”并指定它可能具有的值。(实际上，‘enum’是类型‘int’，所以我们实际上是为一个现有的类型创建一个新的名称。)枚举类型的目的是帮助程序更具可读性，就像COBOL 88级别一样。语法类似于用于结构的语法；</p><p id="b6cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">enum ranges {min = 10, max = 100, mid = 55};<br/>enum ranges tester;<br/>tester = mid;<br/>if (tester &gt; min)</code></p><p id="8baa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">if语句将为真，因为tester的值为55。我建议，如果你想使用枚举类型，你应该比我刚才提到的更多地阅读它们。</p><p id="9ddb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于变量声明，我想说的最后一点是，与COBOL相比，C语言几乎没有应用编辑掩码的能力。这使得它对于编写报告以及广泛使用日期和美元编辑掩码的情况来说不是一种方便的语言。</p><p id="19c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">操作员</strong></p><p id="26b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们先来看一下c中=和==的区别，在COBOL中有几种方法可以将数据放入变量中。一种常见的方式是移动动词，在C语言中的对应形式是=。这是令人困惑的，因为如果你设置一个逻辑测试并使用=它将总是评估为真，因为等号右边的值将被分配给左边的变量。如果要比较值，就需要用==了。这里有一个简单的错误会导致各种各样的问题。如果在C语言中我说</p><p id="e2ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">if(my_int = 5)</code></p><p id="e38a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将会发生的是，变量“my_int”将被赋值为值5，并且由于赋值成功，因此它将返回一个非零值，该值将指示true。这将使“if”语句评估为真。所以这个“如果”陈述总是正确的。简单的错误，重大的影响，编译器不会抱怨，因为这是一个有效的语句。确保你很早就学会了=和==之间的区别，并且永远不要忘记。</p><p id="814f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的下一个布尔运算符是“AND”。COBOL使得比较IF语句中的多个值变得非常容易；</p><p id="fa84" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">IF (VAR1 = VAL1) AND (VAR2 = VAL2 OR VAL3) THEN</code></p><p id="4ea5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">' AND '的C表示为' &amp;&amp; '，' or '为' || '，而' NOT EQUAL '由'标识！='.</p><p id="a720" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些都不是特别难学，但在第一次学习语言时，它们不够直观。</p><p id="9742" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">举例来说，发挥你的创造力，你可以利用#define让操作者做你想做的任何事情；</p><p id="66bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">#define AND &amp;&amp;<br/>#define OR ||<br/>#define NOT !=<br/>#define EQUALS ==</code></p><p id="e0be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在这可能会激怒其他C程序员，但是如果它有助于你使你的代码更容易阅读和维护，谁会说它是错的呢？</p><p id="b096" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">赋值操作符</strong></p><p id="255d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于我已经讲过C中的=号如何等价于COBOL MOVE动词，我就不再讲了。然而，在C语言中使用=符号的另一种选择是使用字符串函数“strcpy”。这会将“字符串复制”到变量中。这是初始化字符数组并确保正确放置空值的好方法(strcpy将空值追加到所复制的字符串的末尾)，特别是如果您希望以后将数据追加到字符串中。C #中追加字符串的动词是“strcat”，表示“字符串连接”。在COBOL中，我们有“字符串”动词，它可以让你更好地控制变量的连接方式。“strcat”所做的只是将一个字符复制到另一个字符数组中，直到它遇到一个空值，从终止的空值开始。现在您可以明白为什么在正确的位置使用空值是如此重要了。</p><p id="db88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">C语言中有几个非常酷的增量运算符快捷方式，我非常喜欢。例如，在COBOL中，如果你想在一个循环中增加一个变量，你可以用几种方法；</p><p id="63b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">ADD 1 TO KOUNT<br/>COMPUTE KOUNT = KOUNT + 1<br/>ADD 1 TO KOUNT GIVING KOUNT<br/>PERFORM VARYING KOUNT FROM 1 BY 1 UNTIL KOUNT &gt;= MAX</code></p><p id="b53d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在C语言中，你可以这样说:</p><p id="dd03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">kount = kount + 1<br/>kount += 1<br/>kount ++<br/>for (kount = 1; kount &gt;= max; kount++)</code></p><p id="7744" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一个例子应该是显而易见的，在第二个例子中+=是第一个例子的快捷方式，它意味着将=符号左边的变量包含在右边的计算中。第三个示例意味着将值增加1。我们的前两个例子在加法中可能有任何值，但是第三个例子只是增加了1。最后一个示例与最后一个COBOL示例相同。有趣的是最后一个参数“kount++”，通过将++放在变量的右侧，我们说是在测试变量是否大于或等于“max”后增加变量。如果++放在左边，就像在' ++kount '中一样，它意味着在测试开始前递增。这与“测试前”或“测试后”的执行指令相同。——符号可用于以完全相同的方式递减，即=或–。</p><p id="3be4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">逻辑结构</strong></p><p id="352f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望这里的每个人都熟悉COBOL PERFORM语句。它的变化比我想的要多，但是它是唯一的循环结构，除非你使用GO TO。c提供了几种不同的循环控件，有；</p><p id="2f41" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">while<br/>do..while<br/>for</code></p><p id="c9aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，COBOL很好地将“while”和“for”循环的功能集成到了执行中。做什么..然而，while循环并不完全相同，您可以通过正确控制变量来模拟它。本质上,“while”和“do”的区别在于..“虽然”是在“做什么..“while”循环中，它将至少“执行”一次循环，因为测试直到循环执行一次后才开始。在while循环中，你的测试可能在第一次做的时候无效，所以你可能永远不会真正完成这个循环。</p><pre class="jq jr js jt fq kb ka kc kd aw ke dt"><span id="1ab0" class="kf kg hu ka b fv kh ki l kj kk">int i = 21;<br/>while(i++ &lt; 20) {<br/>      printf("%d\n",i);<br/>}<br/>/* the above line will display nothing since i is already greater than 20 */<br/>do<br/>{<br/>   printf("%d\n",i);<br/>} while(i++ &lt; 20);<br/>/* the above line will display 21 */</span></pre><p id="bbe6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们来谈谈“if”语句，这是一个说明字符串比较操作有多混乱的例子。在COBOL中，下面的语句非常简单</p><p id="56d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">IF STRING1 IS EQUAL TO STRING2 or IF STRING1 = STRING2</code></p><p id="8e66" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在c #中不能这样比较字符串。在“string.h”头文件中有一个函数可以比较两个字符串，但是，要得到相同的结果，它必须如下所示:</p><p id="9a5f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">if (!strncmp(string1,string2)) {</code></p><p id="151b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我解释一下，首先“strncmp”是一个字符串比较函数，如果string1小于string2，那么将返回一个小于零的值(有点像在COBOL中使用条件代码)。如果string1等于string2，则返回值0。如果string1大于string2，则返回一个大于零的值。问题是，如果在if语句中使用strncmp，并且字符串相等，则返回零，零表示IF语句为假，这就是我们在“strncmp”前面加上“！”的原因也就是说不是。这样做的最终结果是返回一个非零值，如果string1和string2相等，则IF语句也是如此。这也进一步说明了如何将逻辑表达式嵌入到“if”语句中。</p><p id="8fb9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">输入/输出</strong></p><p id="2286" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">幸运的是，c语言根本没有内置I/O功能。那么，如何实现任何类型的终端或文件I/O呢？幸运的是，在C编程的黑暗时代，有人编写了标准的I/O头文件。所以如果你想做任何I/O，你必须包括<stdio.h>。我将讨论stdio中包含的一些更基本的特性和功能。</stdio.h></p><p id="3b1c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">stdio中最常用的函数是“printf”和“scanf”。“printf”用于向STDLIST显示信息,“scanf”用于从STDIN读取信息。这两个函数都具有广泛的格式化功能。COBOL很好，因为您可以使用DISPLAY and ACCEPT来读取或写入几乎任何您想要的东西。然而，您不能在语句本身中进行类型转换或变量格式化，您必须首先在工作存储中声明一个格式化变量。虽然C很少甚至没有提供声明格式化变量的能力，但它确实给了你对格式化输出的广泛控制。一个简单的例子是显示一个有两个小数点的整数。</p><p id="0abc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">01 EDIT-INT PIC ZZ9.99<br/>01 MY-INT PIC S9(3)V99.<br/>MOVE MY-INT TO EDIT-INT.<br/>DISLAY EDIT-INT.</code></p><p id="dae6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">float my _ int<br/> printf("%3.2f\n "，my _ int)；</p><p id="0a16" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如你所看到的，用C格式化更简单，虽然不太直观。“printf”的工作方式是，它在第一个参数中接受一个文字和/或格式字符串，这是引号内的部分。然后用变量替换第二个参数。则\n意味着在该点发出新的一行。下面是一个嵌入文本的例子；</p><p id="4b67" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">printf("I have %d apples and %d oranges",count_apple, count_orange);</code></p><p id="64b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这会将“count_apple”替换为第一个参数，将“count_orange”替换为第二个参数。“printf”中有十几种不同的格式化程序。</p><p id="33a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">“printf”的另一个有趣的特性是它能够进行类型转换，对于这个例子，你需要知道%d意味着打印一个整数，而%c意味着打印一个字符；</p><p id="048e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">printf("%c %d\n", 'A', 'A');</code></p><p id="9e61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你认为这会产生什么结果？很可能您猜错了，您会看到“A 65”，因为通过为字母字符“A”指定%d，它会将其格式化为“A”的十进制ASCII代码，即65。</p><p id="1ca3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">像“printf()”一样，“scanf()”使用一个控制字符串，后跟一个参数列表。主要区别在于参数列表。Printf()使用变量名、常量和表达式。Scanf()使用指向变量的指针。幸运的是，我们不需要知道任何关于指针的知识就可以使用这个函数。只要记住这两条规则:</p><p id="2ae3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.如果你想读取一个基本变量类型的值，在变量名前加一个&amp;。<br/> 2。如果你想读取一个字符串变量，不要使用&amp;。</p><p id="a669" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是一个显示输出和提示输入的简短示例:</p><p id="eed5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">main()<br/>{<br/>int age;<br/>float assets;<br/>char pet[30];<br/>printf("enter your age, assets, and favorite pet.\n");<br/>scanf("%d %f", &amp;age, &amp;assets);<br/>scanf("%s", pet); /* no &amp; for char array */<br/>printf("%d $%.0f %s\n ", age, assets, pet);<br/>}</code></p><p id="d56b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你运行它，它看起来会像这样。</p><p id="787a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">输入您的年龄、资产和最喜欢的宠物。10507.32美元<br/> 32美元<br/> 10507.32美元<br/>10507美元【企鹅】</p><p id="321e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有趣的一点是，与COBOL接受动词不同，scanf()可以一次读入多个变量。printf()的最后一点是，以下两条语句的工作方式完全相同:</p><p id="251c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">printf("Enter your option ");<br/>DISPLAY "Enter your option " NO ADVANCING.</code></p><p id="302f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我前面提到的，C面向单个字符，而不是字符串。所以在stdio中有一整套函数是专门用来读写单个字符的。因为COBOL很少关心你用多大的数组来读或写，我不打算深入细节，只要记住这四个函数名；</p><p id="329a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">getchar<br/>putchar<br/>getc<br/>putc</code></p><p id="b6b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在展示一些小程序外壳之前，我将只介绍两个以上的COBOL动词比较。我最喜欢的两个动词是STRING和UNSTRING，它们用于连接变量和文字，并根据用户定义的标记解析字符串。总的来说，它们非常容易使用，然而它们的C语言对应物却不容易。我将浏览一下COBOL示例，然后用c语言展示完全相同的代码。</p><pre class="jq jr js jt fq kb ka kc kd aw ke dt"><span id="4566" class="kf kg hu ka b fv kh ki l kj kk">01 FULL-NAME.<br/>   03 FN-FILE    PIC X(08) VALUE "MYFILE".<br/>   03 FN-GROUP   PIC X(08) VALUE "MYGROUP".<br/>   03 FN-ACCOUNT PIC X(08) VALUE "MYACCT".<br/>01 WS-FULL-NAME  PIC X(26) VALUE SPACES.<br/>PROCEDURE DIVISION.<br/> A1000-START. DISPLAY FULL-NAME. <br/>* displays "MYFILE MYGROUP MYACCT" <br/> STRING FN-FILE DELIMITED BY SPACES <br/>        "." DELIMITED BY SIZE <br/>        FN-GROUP DELIMITED BY SPACES  <br/>        "." DELIMITED BY SIZE <br/>        FN-ACCT DELIMITED BY SPACES <br/>   INTO WS-FULL-NAME. DISPLAY WS-FULL-NAME. <br/>* displays "MYFILE.MYGROUP.MYACCT" <br/>MOVE SPACES TO FULL-NAME. <br/>UNSTRING WS-FULL-NAME DELIMITED BY "." <br/>    INTO FN-FILE FN-GROUP FN-ACCT. <br/>DISPLAY FULL-NAME. <br/>* displays "MYFILE MYGROUP MYACCT" </span><span id="0d3e" class="kf kg hu ka b fv kl ki l kj kk">#include &lt;stdio&gt; <br/>#include &lt;string&gt; <br/>main() <br/>{ <br/>char ws_full_name[27]; <br/>struct full_file_name { <br/>       char file[9]; <br/>       char group[9]; <br/>       char acct[9]; <br/>} fn; </span><span id="f56f" class="kf kg hu ka b fv kl ki l kj kk">strcpy(fn.file,"MYFILE"); <br/>strcpy(fn.group,"MYGROUP"); <br/>strcpy(fn.acct,"MYACCT"); <br/>strcpy(ws_full_name,fn_file); <br/>strcat(ws_full_name,"."); <br/>strcat(ws_full_name,fn_group); <br/>strcat(ws_full_name,"."); <br/>strcat(ws_full_name,fn_acct); <br/>printf("%s\n",ws_full_name); <br/>/* displays "MYFILE.MYGROUP.MYACCT" */</span></pre><p id="92db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你知道，我不认为我会展示相当于UNSTRING的东西，如果你刚刚开始使用c，这太令人困惑了，这个函数叫做“strtok ”,它要求你使用指向字符串的指针，因为我根本没有真正接触过指针，所以我不想混淆这个问题。但是请记住，你必须理解C语言中的指针是如何工作的，否则你将永远无法有效地使用这种语言。只是对指针的全面讨论超出了本文的范围。</p><p id="a85e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总之，在我们的C示例中，我们使用了“strcpy”命令将字符串复制到变量中。该函数还添加了空终止符，并从本质上初始化了我们的字符数组。使用“strcat”函数，将第二个参数中的字符串连接到第一个参数中指定的变量。它寻找空终止符，然后开始在上面写入字符串。</p><p id="3d3d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如你所见，在C中处理字符串比COBOL更困难，也更迂回。现在不要误会，我认为C对于某些事情来说是很棒的，只是如果你正在编写一个标准的商业类型的应用程序，那么很多这些事情都是不必要的。</p><p id="032b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">代码骷髅</strong></p><p id="aec5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好，那么用C语言写一个程序，你需要做些什么呢？如你所知，COBOL有四个必须使用的部分；</p><p id="37d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">IDENTIFICATION DIVISION<br/>ENVIRONMENT DIVISION<br/>DATA DIVISION<br/>PROCEDURE DIVISION</code></p><p id="f022" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每一个都有它自己的生活目的。在C语言中，一切都基于函数。正如你在我之前的例子中看到的，我在程序的顶部有' main()'。你可以把main()看成是过程划分。它是一个函数，就像你的C程序中的其他东西一样，而且它通常是你必须拥有的唯一函数。我说通常是因为如果你正在编写一系列要进入RBM的子程序，你不需要命名函数main()。</p><p id="ead9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以用C写经典的“Hello World”程序，这就是你需要做的全部。</p><p id="ea84" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jx jy jz ka b">#include &lt;stdio.h&gt;<br/>main();<br/>{<br/>printf("Hello World\n");<br/>}</code></p><p id="4f49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这比用COBOL编写的代码要少得多，但仍然比用BASIC要多。我在这里看到的问题是，仅仅为了一个printf()语句就必须包含stdio.h，这将导致您的程序对于如此琐碎的事情来说相当大。</p><p id="3fa7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">为可移植性或速度编码</strong></p><p id="6eb7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你会听到很多关于C语言的可移植性，以及你应该如何编写可移植性的代码。平台与平台之间有太多的变化，以至于为了可移植性而编码真的很乏味。我知道有很多工具包对此有所帮助，比如Qt，但我们在这里只是谈论原始代码。</p><p id="d5a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你编码利用你的CPU的原生架构，你将会看到速度的巨大提高和代码大小的减少。如果你使用语言的本地结构来为可移植性编码，你将会有一个更大、更慢的程序。如果你想两全其美，你需要编写自己的中间包含文件，允许你在不同的体系结构之间切换。</p><p id="7700" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">总结</strong></p><p id="8937" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么，从这一切中我能得出什么结论呢？在我告诉你之前，让我告诉你一封我读过的信，有人寄给了一本计算机语言杂志。这位先生对他们在杂志中加入COBOL感到愤怒，如果他们打算这样做，他们也可以加入RPG，因为这两种语言都不是真正的语言。他对真正语言的标准包括了一些你在C语言中能做而在COBOL语言中不能做的事情。比如使用指针和声明局部变量。那么，为什么这位先生如此热爱一种没有内置I/O功能的语言，并且把字符串作为字节数组来处理呢？</p><p id="0539" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一定是我见过的最愚蠢的声明之一。COBOL是商业应用程序中最流行的语言之一，虽然我不喜欢RPG，但IBM已经确保它拥有庞大的安装基础。所以我为什么要费神提这个呢？因为正如我在开场白中所说的，仍然有大量的COBOL存在，它可能正在管理你的薪水和投资，所以不要太快忽视它。</p></div></div>    
</body>
</html>