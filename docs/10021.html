<html>
<head>
<title>Building an animated sticky header with custom offset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建带有自定义偏移量的动画粘性标题</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-an-animated-sticky-header-with-custom-offset-6eb2b29d3eed?source=collection_archive---------7-----------------------#2018-12-13">https://medium.com/hackernoon/building-an-animated-sticky-header-with-custom-offset-6eb2b29d3eed?source=collection_archive---------7-----------------------#2018-12-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/5d9e104042278d87361fa1b8044e74ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sr8Acn6cL4VbrQ8PeDsGYw.jpeg"/></div></div></figure><p id="b94f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">粘性元素在整个网络中被广泛使用。随着<code class="eh ka kb kc kd b">position: sticky</code>属性的出现，我们可以不用JavaScript插件来创建粘性元素。但是如果没有一点JavaScript，用动画创建粘性元素是不可能实现的。</p><h1 id="a7a2" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">规格</h1><p id="c096" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">任务是构建一个粘滞标题，当用户滚动静态标题或在自定义偏移位置时出现。向下滚动时，静态标题应该保持在原来的位置，而粘性标题应该向下滚动。向上滚动时，粘性标题应该消失，静态标题应该向下滚动。请注意，静态标头和粘性标头的内容是不同的。</p><h1 id="75df" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">解决方案</h1><p id="7861" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">为了更容易理解规格，请看这支包含完整解决方案的笔:</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="ll lm l"/></div></figure><h1 id="0694" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">崩溃</h1><p id="a135" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">为了更好地理解这段代码是如何工作的，我们应该检查一下HTML结构。</p><h1 id="bc6d" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">超文本标记语言</h1><p id="ae2b" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">下面是HTML结构的简化预览:</p><pre class="lh li lj lk fq ln kd lo lp aw lq dt"><span id="d067" class="lr kf hu kd b fv ls lt l lu lv">&lt;main&gt;<br/>  &lt;header&gt;<br/>    &lt;div class="header header--alpha"&gt;<br/>      ...<br/>    &lt;/div&gt;<br/>    &lt;div class="header header--beta"&gt;<br/>      ...<br/>    &lt;/div&gt;<br/>  &lt;/header&gt;<br/>  &lt;div class="fake-header"&gt;&lt;/div&gt;<br/>  &lt;article&gt;<br/>    ... <br/>  &lt;/article&gt;<br/>&lt;/main&gt;</span></pre><p id="8ecc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh ka kb kc kd b">main</code>元素中，我们有<code class="eh ka kb kc kd b">header,</code> <code class="eh ka kb kc kd b">.fake-header</code>和<code class="eh ka kb kc kd b">article</code>元素。为了让<code class="eh ka kb kc kd b">position: sticky</code>工作，sticky元素应该在可滚动元素内部——在我们的例子中是<code class="eh ka kb kc kd b">main</code>元素。</p><p id="9526" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">标头包含两个元素:</p><ul class=""><li id="5a9e" class="lw lx hu je b jf jg jj jk jn ly jr lz jv ma jz mb mc md me dt translated"><code class="eh ka kb kc kd b">.header--alpha</code>，静态头，和</li><li id="a397" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated"><code class="eh ka kb kc kd b">.header--beta</code>，粘性表头。</li></ul><h1 id="647c" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">半铸钢ˌ钢性铸铁(Cast Semi-Steel)</h1><p id="6d4a" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">首先，让我们设计包装元素的样式。默认情况下，它应该具有相对位置，一旦达到偏移量，它就具有粘性。</p><pre class="lh li lj lk fq ln kd lo lp aw lq dt"><span id="e43a" class="lr kf hu kd b fv ls lt l lu lv">header {<br/>  top: 0;<br/>  position: relative;<br/>  overflow: hidden;<br/>}<br/><br/>header.sticky {<br/>  position: sticky;<br/>}</span></pre><p id="fd46" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">属性<code class="eh ka kb kc kd b">top: 0</code>将确保我们的头被固定在顶部，属性<code class="eh ka kb kc kd b">overflow: hidden</code>隐藏了<code class="eh ka kb kc kd b">header</code>元素之外的所有内容。</p><p id="7b2f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们应该定义标题部分的行为。</p><pre class="lh li lj lk fq ln kd lo lp aw lq dt"><span id="9037" class="lr kf hu kd b fv ls lt l lu lv">.header--alpha {<br/>  transition: .225s ease-out;<br/>}<br/><br/>.sticky .header--alpha {<br/>  opacity: .5;<br/>  transform: translateY(-100%);<br/>  transition: none;<br/>}</span></pre><p id="0abf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ka kb kc kd b">.header--alpha</code>，我们的静态头默认是可见的。当用户滚动超过偏移量时，包装器<code class="eh ka kb kc kd b">header</code>元素变得有粘性，它将立即被转换到包装器元素之外，没有任何过渡效果。请注意，当粘滞效果不活动时，当元素回到原始位置时，它将被转换。</p><pre class="lh li lj lk fq ln kd lo lp aw lq dt"><span id="5094" class="lr kf hu kd b fv ls lt l lu lv">.header--beta {<br/>  position: absolute;<br/>  top: 0;<br/>  left: 0;<br/>  right: 0;<br/>  opacity: .5;<br/>  transform: translateY(-100%);<br/>}<br/><br/>.sticky .header--beta {<br/>  opacity: 1;<br/>  transform: translateY(0);<br/>  transition: .35s ease-out;<br/>}</span></pre><p id="a1cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ka kb kc kd b">.header--beta</code>，我们的粘性头被绝对定位并在包装器<code class="eh ka kb kc kd b">header</code>元素之外被转换。当粘性效应被激活时，它将在原始位置进行平移和过渡。</p><h1 id="b76a" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">Java Script语言</h1><p id="6db8" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">您可能已经注意到了<code class="eh ka kb kc kd b">.fake-header</code>元素。</p><pre class="lh li lj lk fq ln kd lo lp aw lq dt"><span id="5503" class="lr kf hu kd b fv ls lt l lu lv">.fake-header {<br/>  height: 1px;<br/>  position: relative;<br/>}</span></pre><p id="90d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该元素用作滚动的偏移量。当它到达视窗顶部时，标题变得粘粘的。而当页眉变得有粘性时，伪元素会被推高页眉的高度加上一个额外的像素。当用户向上滚动并到达新位置的伪元素时，粘性效果将被关闭。</p><pre class="lh li lj lk fq ln kd lo lp aw lq dt"><span id="afcb" class="lr kf hu kd b fv ls lt l lu lv">const $realSticky = document.querySelector("header");<br/>const $fakeSticky = document.querySelector(".fake-header");<br/><br/>const stickyHeader = () =&gt; function() {<br/>  const sr1 = $fakeSticky.getBoundingClientRect();<br/>  const sr2 = $realSticky.getBoundingClientRect();<br/><br/>  if (sr1.top &gt; 0) {<br/>    $realSticky.classList.remove("sticky");<br/>    $fakeSticky.style.top = 0;<br/>  } else {<br/>    $realSticky.classList.add("sticky");<br/>    $fakeSticky.style.top = `-${sr2.height + 1}px`;<br/>  }<br/>};<br/><br/>window.addEventListener("scroll", _.debounce(stickyHeader(), 15));</span></pre><p id="fbca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本例中，<a class="ae mk" href="https://lodash.com/docs/4.17.10#debounce" rel="noopener ugc nofollow" target="_blank"> lodash debounce </a>函数用于在滚动事件时执行任务。</p><p id="deb0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ml">我知道我可以写出更好的JS代码，避免添加</em> <code class="eh ka kb kc kd b"><em class="ml">.fake-header</em></code> <em class="ml">元素，但是我想创建一个没有太多计算的演示。</em></p><p id="4205" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为静态标题决定了包装元素的高度，所以一旦粘性标题出现，我们就很难选择或点击它后面的内容。</p><p id="2eb8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以使用指针事件来解决这个问题:</p><pre class="lh li lj lk fq ln kd lo lp aw lq dt"><span id="634f" class="lr kf hu kd b fv ls lt l lu lv">header {<br/>  pointer-events: none;<br/>}<br/><br/>.header {<br/>  pointer-events: all;<br/>}</span></pre><p id="b2c8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先我们将<code class="eh ka kb kc kd b">pointer-events</code>到<code class="eh ka kb kc kd b">none</code>设置为<code class="eh ka kb kc kd b">header</code>元素来禁用点击/悬停事件，然后我们将<code class="eh ka kb kc kd b">pointer-events</code>设置为<code class="eh ka kb kc kd b">all</code>来再次启用它们。</p><h1 id="9ef4" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">结论</h1><p id="c244" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">你可以在我的代码笔上看到完整的演示<a class="ae mk" href="https://codepen.io/CiTA/pen/BGQPBz" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b61b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个演示使用了有限支持的<code class="eh ka kb kc kd b"><a class="ae mk" href="https://caniuse.com/#search=position%3A%20sticky" rel="noopener ugc nofollow" target="_blank">position: sticky</a></code>和<code class="eh ka kb kc kd b"><a class="ae mk" href="https://caniuse.com/#search=pointer-events" rel="noopener ugc nofollow" target="_blank">pointer-events</a></code>属性。</p><p id="4248" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看到CSS发展如此之快，我真的很兴奋。全新的属性，如<code class="eh ka kb kc kd b">position: sticky</code>和<code class="eh ka kb kc kd b">pointer-events</code>允许我们更轻松、更自然地为最终用户创造更好的体验。而且支持一天比一天好。🏆</p></div><div class="ab cl mm mn hc mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hn ho hp hq hr"><p id="79de" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ml">原载于</em><a class="ae mk" href="https://www.silvestarbistrovic.from.hr/articles/building-an-animated-sticky-header-with-custom-offset/" rel="noopener ugc nofollow" target="_blank"><em class="ml">www . silvestarbitrovic . from . HR</em></a><em class="ml">。</em></p></div></div>    
</body>
</html>