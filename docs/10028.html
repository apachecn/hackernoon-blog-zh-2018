<html>
<head>
<title>Preprocess Keras Model for TensorSpace</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">张量空间预处理Keras模型</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/preprocess-keras-model-for-tensorspace-ed5e4db9a2a1?source=collection_archive---------14-----------------------#2018-12-13">https://medium.com/hackernoon/preprocess-keras-model-for-tensorspace-ed5e4db9a2a1?source=collection_archive---------14-----------------------#2018-12-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="176c" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">神经网络三维可视化中Keras模型的张量空间兼容预处理</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/3b66f67e56f5b14a460011f09e21e65c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*frk5recEWdL8bzyFfFie4g.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">TensorSpace &amp; Keras</figcaption></figure><p id="c3c3" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><em class="kv">“tensor space是一个神经网络3D可视化框架。— TensorSpace.org" </em></p><p id="0040" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><em class="kv">“Keras是一个高级神经网络API。— keras.io " </em></p><h1 id="50ac" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated"><strong class="ak">简介</strong></h1><p id="f44a" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">你可能会了解到<a class="ae lt" href="https://tensorspace.org/" rel="noopener ugc nofollow" target="_blank">张量空间</a>可用于三维可视化神经网络。你可能看过我之前关于TensorSpace 的<a class="ae lt" href="https://medium.freecodecamp.org/tensorspace-js-a-way-to-3d-visualize-neural-networks-in-browsers-2c0afd7648a8" rel="noopener ugc nofollow" target="_blank">介绍。也许你会发现模型预处理有点复杂。</a></p><p id="1381" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">所以今天，我想详细谈谈张量空间的模型预处理。更具体地说，如何对Keras构建的深度学习模型进行预处理，使其与张量空间兼容。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lu"><img src="../Images/093287db714647579fffb85a3dd5b7d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YK8lD09kRBaMPluVYHF_sQ.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><strong class="bd lv">Fig. 1</strong> — Use TensorSpace to visualize an LeNet built by Keras</figcaption></figure><h1 id="3510" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated"><strong class="ak">我们应该拥有什么？</strong></h1><p id="b5d8" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">为了使Keras构建的模型与张量空间兼容，我们需要模型满足两个关键点:</p><ul class=""><li id="e0b6" class="lw lx hu kb b kc kd kf kg ki ly km lz kq ma ku mb mc md me dt translated">支持来自中间层的多个输出。</li><li id="a466" class="lw lx hu kb b kc mf kf mg ki mh km mi kq mj ku mb mc md me dt translated">支持浏览器友好的TensorSpace兼容格式。</li></ul><p id="b526" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在接下来的部分中，我将以LeNet为例介绍预处理Keras模型的工作流程。</p><p id="8902" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">为了继续这个过程，我假设我们已经建立了一个适当的Python环境:</p><ul class=""><li id="e40f" class="lw lx hu kb b kc kd kf kg ki ly km lz kq ma ku mb mc md me dt translated">Python 3.6</li><li id="26db" class="lw lx hu kb b kc mf kf mg ki mh km mi kq mj ku mb mc md me dt translated">导入keras和numpy</li><li id="f0b2" class="lw lx hu kb b kc mf kf mg ki mh km mi kq mj ku mb mc md me dt translated">已安装tfjs转换器。</li></ul><p id="973e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">你可以在<a class="ae lt" href="https://github.com/tensorspace-team/tensorspace/tree/master/docs/preprocess/Keras" rel="noopener ugc nofollow" target="_blank"> TensorSpace预处理Keras目录</a>中找到例子中的所有资源，包括:</p><ul class=""><li id="7f90" class="lw lx hu kb b kc kd kf kg ki ly km lz kq ma ku mb mc md me dt translated">预处理Keras模型的源代码(<a class="ae lt" href="https://github.com/tensorspace-team/tensorspace/tree/master/docs/preprocess/Keras/src_py" rel="noopener ugc nofollow" target="_blank">src _ py</a>&amp;<a class="ae lt" href="https://github.com/tensorspace-team/tensorspace/tree/master/docs/preprocess/Keras/src_sh" rel="noopener ugc nofollow" target="_blank">src _ sh</a>)</li><li id="29b9" class="lw lx hu kb b kc mf kf mg ki mh km mi kq mj ku mb mc md me dt translated"><a class="ae lt" href="https://github.com/tensorspace-team/tensorspace/blob/master/docs/preprocess/Keras/models/keras_model.h5" rel="noopener ugc nofollow" target="_blank">模型_之前_预处理</a></li><li id="47a0" class="lw lx hu kb b kc mf kf mg ki mh km mi kq mj ku mb mc md me dt translated"><a class="ae lt" href="https://github.com/tensorspace-team/tensorspace/tree/master/docs/preprocess/Keras/models/tfjs_model" rel="noopener ugc nofollow" target="_blank">模型_后_预处理</a></li></ul><p id="ac47" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">训练样本LeNet模式的源文件可以在<a class="ae lt" href="https://github.com/tensorspace-team/tensorspace/blob/master/docs/preprocess/Keras/src_py/keras_model.py" rel="noopener ugc nofollow" target="_blank"> keras_model.py </a>中找到。您还可以尝试使用您自己的模型，该模型应该是有效的，并且可以正确处理样本输入数据。</p><h1 id="3c33" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated"><strong class="ak">在预处理之前，我们从模型中得到什么？</strong></h1><p id="70a0" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">在预处理之前，预训练的LeNet模型实际上是一个黑盒:它由一个28x28的图像提供，然后返回10个双精度值的列表。每个双精度数代表一个数字从“0”到“9”的概率。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mk"><img src="../Images/bc787090e052e16b735ffb3a2d9f68b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*al0LSGqK3hHZ_aXWJy6vjA.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><strong class="bd lv">Fig.</strong> 2 — Classic pre-trained model with single output</figcaption></figure><p id="b13b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们可以加载模型并执行预测，如下所示:</p><pre class="jk jl jm jn fq ml mm mn mo aw mp dt"><span id="99a4" class="mq kx hu mm b fv mr ms l mt mu">model = load_model("/PATH/TO/OUTPUT/keras_model.h5")<br/>input_sample = np.ndarray(<br/>    shape=(28,28), <br/>    buffer=np.random.rand(28,28)<br/>)<br/>input_sample = np.expand_dims(input_sample, axis=0)<br/>print(model.predict(input_sample))</span></pre><p id="c8e8" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们使用一个28x28的numpy数组来模拟一个随机的输入图像。示例输出如下所示:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mv"><img src="../Images/665fdd859c169e7dfb46c9ec26c0b078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z3T8rJg8jnZybQEZ1Su7WQ.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><strong class="bd lv">Fig. </strong>3 — Single list prediction output from trained model</figcaption></figure><p id="3925" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果模型预先训练得很好，它就足以用作应用程序——我们只需要添加一个手写输入面板和一个适当的输出函数来显示预测。</p><p id="f0fc" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然而，就像“魔术”一样，人们很难了解模型预测的过程，因为输入和输出之间存在差距。预处理实际上是一种从间隙中暴露“魔术”的某些部分的方法。</p><h1 id="0d5a" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated"><strong class="ak">张量空间的预处理是什么？</strong></h1><p id="47bc" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">张量空间的模型预处理是这样的过程:</p><ul class=""><li id="f0d7" class="lw lx hu kb b kc kd kf kg ki ly km lz kq ma ku mb mc md me dt translated">检测必要的数据</li><li id="3667" class="lw lx hu kb b kc mf kf mg ki mh km mi kq mj ku mb mc md me dt translated">从隐藏层提取中间输出</li><li id="b797" class="lw lx hu kb b kc mf kf mg ki mh km mi kq mj ku mb mc md me dt translated">转换为TensorSpace兼容的模型格式</li></ul><p id="fdd7" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在将模型应用到张量空间框架之前，应该完成这一系列动作。张量空间的预处理是满足张量空间基本要求的途径。从预训练的深度学习模型收集的数据用于渲染张量空间可视化模型。</p><h1 id="a298" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated"><strong class="ak">如何预处理一个Keras模型？</strong></h1><p id="f854" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">从一个<code class="eh mw mx my mm b">model.summary()</code>的调用，更容易查到每一层的信息。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mv"><img src="../Images/2e16a30e7bf295460c555bdf6de22097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJugFQyyagUqbNaezUF2-g.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><strong class="bd lv">Fig.</strong> 4 — Model summary and layer names</figcaption></figure><p id="54c6" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">例如，我们希望收集所有图层名称。</p><pre class="jk jl jm jn fq ml mm mn mo aw mp dt"><span id="63e8" class="mq kx hu mm b fv mr ms l mt mu">output_layer_names = [<br/>    "Conv2D_1", "MaxPooling2D_1", "Conv2D_2", "MaxPooling2D_2", <br/>    "Dense_1", "Dense_2", "Softmax"<br/>]</span></pre><p id="dd7f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来，我们希望基于原始模型和我们刚刚收集的图层名称构建一个新模型。</p><pre class="jk jl jm jn fq ml mm mn mo aw mp dt"><span id="9055" class="mq kx hu mm b fv mr ms l mt mu">def generate_encapsulate_model_with_output_layer_names(model, <br/>    output_layer_names):<br/>    enc_model = Model(<br/>        inputs=model.input,<br/>        outputs=list(map(<br/>            lambda oln: model.get_layer(oln).output,<br/>            output_layer_names<br/>        ))<br/>    )<br/>    return enc_model</span><span id="63ac" class="mq kx hu mm b fv mz ms l mt mu">enc_model = generate_encapsulate_model_with_output_layer_names(<br/>    model, <br/>    output_layer_names<br/>)</span><span id="40b0" class="mq kx hu mm b fv mz ms l mt mu">enc_model.save("/PATH/TO/ENC_MODEL/enc_keras_model.h5")</span></pre><p id="300d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然后，我们可以使用新的封装模型来检查最后的预测是否像以前一样有效。</p><pre class="jk jl jm jn fq ml mm mn mo aw mp dt"><span id="868d" class="mq kx hu mm b fv mr ms l mt mu">input_sample = np.ndarray(<br/>    shape=(28,28), <br/>    buffer=np.random.rand(28,28)<br/>)<br/>input_sample = np.expand_dims(input_sample, axis=0)<br/>print(enc_model.predict(input_sample))</span></pre><p id="9669" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">封装后的模型返回一个很长的输出列表，它代表了我们的“output_layer_names”列表中中间层的结果。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mv"><img src="../Images/45307297e108b1638e0f3f82629c79ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u3FmMTHNEXV6CW7GIFIOgA.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><strong class="bd lv">Fig.</strong> 5 — Multiple list outputs after preprocessing</figcaption></figure><p id="78ea" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">最后一个输出是一个大小为10的double列表，它表示LeNet模型的原始输出。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mv"><img src="../Images/0bc2d0aa190f5148be8d165c8483f125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ExigN0GFN9ah0ZPbRWqznw.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><strong class="bd lv">Fig.</strong> 6 — Last list output is the same as the original inferences</figcaption></figure><p id="a9e1" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">最后，我们可以使用tfjs-converter将Keras模型转换为TensorFlow.js模型，TensorSpace可以直接使用它。</p><pre class="jk jl jm jn fq ml mm mn mo aw mp dt"><span id="6877" class="mq kx hu mm b fv mr ms l mt mu">tensorflowjs_converter \     <br/>    --input_format=keras \     <br/>    /PATH/TO/ENC_MODEL/enc_keras_model.h5 \     <br/>    /PATH/TO/OUTPUT_DIR/</span></pre><h1 id="6d6b" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated"><strong class="ak">预处理之后，我们对封装模式有什么期待？</strong></h1><p id="fe1d" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">预处理之后，我们应该有一个模型:</p><ul class=""><li id="984d" class="lw lx hu kb b kc kd kf kg ki ly km lz kq ma ku mb mc md me dt translated">包含原始模型中的所有内容</li><li id="9332" class="lw lx hu kb b kc mf kf mg ki mh km mi kq mj ku mb mc md me dt translated">能够从中间层提供数据输出</li><li id="8311" class="lw lx hu kb b kc mf kf mg ki mh km mi kq mj ku mb mc md me dt translated">是张量空间兼容的格式</li></ul><p id="7491" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">来自中间层的数据可以由张量空间收集，并用于在张量空间模型中渲染可视化对象。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff na"><img src="../Images/42b0ef39e4ba681f402bd1666606d9ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Co7qZ_fBKW2tr17WaAvxw.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><strong class="bd lv">Fig.</strong> 7 — TensorSpace compatible model with intermediate outputs</figcaption></figure><p id="192f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">最后，我们可以将预处理后的模型应用到张量空间进行可视化！</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="b55d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><a class="ae lt" href="https://codepen.io/syt123450/pen/667a7943b0f23727790ca38c93389689/" rel="noopener ugc nofollow" target="_blank"><em class="kv">CodePen</em></a><em class="kv">中的视图。</em></p><h1 id="b63a" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated"><strong class="ak">结论</strong></h1><p id="5d57" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">张量空间预处理是应用张量空间API的重要步骤。可以在预处理之后收集用于呈现3D可视化的必要中间数据。</p><p id="0e80" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在，我们可以从深度学习模型中收集更多的数据。下一步是如何明智地使用和分析来自中间层的数据。数据可视化可以是一种观察数据的方式，这可能需要一些工具，例如TensorSpace。</p></div><div class="ab cl nd ne hc nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="hn ho hp hq hr"><p id="2b5b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">有关TensorSpace.js的更多信息，请查看:</p><ul class=""><li id="2b3d" class="lw lx hu kb b kc kd kf kg ki ly km lz kq ma ku mb mc md me dt translated">预处理教程:<a class="ae lt" href="https://tensorspace.org/html/docs/preIntro.html" rel="noopener ugc nofollow" target="_blank">简介</a>、<a class="ae lt" href="https://tensorspace.org/html/docs/preTf.html" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>、<a class="ae lt" href="https://tensorspace.org/html/docs/preKeras.html" rel="noopener ugc nofollow" target="_blank">Keras</a>&amp;<a class="ae lt" href="https://tensorspace.org/html/docs/preTfjs.html" rel="noopener ugc nofollow" target="_blank">tensor flow . js</a></li><li id="c1fd" class="lw lx hu kb b kc mf kf mg ki mh km mi kq mj ku mb mc md me dt translated">官方网站:<a class="ae lt" href="https://tensorspace.org/" rel="noopener ugc nofollow" target="_blank">TensorSpace.org</a></li><li id="9ced" class="lw lx hu kb b kc mf kf mg ki mh km mi kq mj ku mb mc md me dt translated">GitHub资源库:<a class="ae lt" href="https://github.com/tensorspace-team/tensorspace" rel="noopener ugc nofollow" target="_blank">tensor space-Team/tensor space</a></li></ul></div></div>    
</body>
</html>