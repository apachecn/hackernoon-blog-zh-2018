<html>
<head>
<title>Scaling Selenium with Openresty</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Openresty缩放硒</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/scaling-selenium-with-openresty-cf31370ec06f?source=collection_archive---------20-----------------------#2018-12-13">https://medium.com/hackernoon/scaling-selenium-with-openresty-cf31370ec06f?source=collection_archive---------20-----------------------#2018-12-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/e3a6debe61919e2a35982868c5f229e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*q9jna6p2h6rwLMrjJYyO1g.png"/></div></figure><p id="b178" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Selenium成为浏览器/UI自动化的事实上的自动化标准/工具已经有一段时间了。</p><p id="59a1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">selenium的创建者还创建了selenium grid来扩展UI测试。网格由一个selenium hub和几个selenium节点组成，这些节点连接/托管浏览器，从而提供了一种同时运行几个UI测试的方法。Selenium还提供了一些定制/扩展现有功能的简单方法。对于大多数用例，基于selenium hub /node的架构伸缩性很好，不需要太多定制。</p><h2 id="c756" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">需要更高的可用性和规模</h2><p id="768b" class="pw-post-body-paragraph iy iz hu ja b jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr kv jt ju jv hn dt translated">尽管该架构支持扩展selenium节点，但它并不容易扩展hub本身。在典型的部署中，会有一个集线器和几个与之相连的节点。</p><p id="521d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">会话/浏览器实例的映射保存在集线器内部的内存中。因此，如果中枢出现故障，整个电网将变得不可用。</p><p id="f6b3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">启用某种级别的HA的一个简单方法是至少运行2个集线器。</p><h2 id="2686" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">多中心挑战</h2><p id="b54e" class="pw-post-body-paragraph iy iz hu ja b jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr kv jt ju jv hn dt translated"><strong class="ja hv">粘性会话需求</strong></p><p id="753d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">由于selenium hubs不能互相对话，所以负载到不同hub的分布需要某种粘性。这里的粘性需要确保一旦在一个hub上创建了会话，该特定会话的所有后续请求都会到达同一个hub。</p><p id="76f1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">会话粘性并不是一个新鲜事物。基于浏览器的客户端的典型粘性是通过cookies实现的。LB查看被传递的cookie信息，以决定请求将被转发到哪个上游服务器。</p><p id="0e2a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">曲奇基粘性排除</strong></p><p id="b90f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在selenium自动化场景中，使用cookie传递这些额外的信息是不可能的，所以这不是我们用例的选项。</p><p id="8efa" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">基于客户端ip的粘性</strong></p><p id="ec3e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">到目前为止，我们一直在使用的一个选项是基于客户端ip创建粘性。</p><p id="e011" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以从一个客户端ip发起的所有呼叫将总是到达给定的集线器。虽然这适用于大多数场景，但是集线器上的负载并不是均匀分布的。</p><p id="f3ea" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这种特殊的技术解决了HA问题，但是如果负载不均匀，这可能不是一个很好的扩展解决方案。</p><p id="759f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">测试套件中不均衡的负载和不均衡的测试用例</strong></p><p id="35f6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一个包含大量UI测试的大型测试套件可以完全阻塞所有测试的中心。</p><p id="4b21" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了使我们的测试基础设施更加可靠和健壮，我们可能必须探索一些不同的途径。</p><h2 id="95a9" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">乐于救援</h2><p id="b517" class="pw-post-body-paragraph iy iz hu ja b jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr kv jt ju jv hn dt translated">Openresty是nginx的一个软件包，包括一些高质量的Lua库。它允许您自定义负载平衡行为并添加自定义行为。</p><h2 id="ad12" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">设计</h2><p id="a5dc" class="pw-post-body-paragraph iy iz hu ja b jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr kv jt ju jv hn dt translated">我们可以在hub之前添加openresty作为代理层。</p><p id="a191" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以在hub前面部署几个openresty实例，LB可以以循环方式将请求转发到这些openresty实例中的一个(之前LB使用客户端ip哈希直接将请求转发到hub)。</p><p id="9aa9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Openresty实例作为反向代理，所有hub实例都是每个openresty实例的上游服务器。</p><h2 id="2287" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">魔力</h2><p id="051a" class="pw-post-body-paragraph iy iz hu ja b jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr kv jt ju jv hn dt translated">请求转发的工作方式是:</p><ol class=""><li id="e4e9" class="kw kx hu ja b jb jc jf jg jj ky jn kz jr la jv lb lc ld le dt translated">每个新的会话请求将以循环方式被转发到一个集线器。</li><li id="f964" class="kw kx hu ja b jb lf jf lg jj lh jn li jr lj jv lb lc ld le dt translated">一旦在hub上创建了会话，并且响应返回到openresty代理实例，它就检查响应主体，寻找会话id，并将上游主机ip(数字格式的主机ip)附加到现有的会话id上，并向客户端返回响应。</li><li id="465f" class="kw kx hu ja b jb lf jf lg jj lh jn li jr lj jv lb lc ld le dt translated">客户端接收一个新的会话id，其中嵌入了上游集线器节点。</li><li id="4324" class="kw kx hu ja b jb lf jf lg jj lh jn li jr lj jv lb lc ld le dt translated">客户端对该会话的任何后续操作都在url路径中使用该会话id，现在会话id中嵌入了上游集线器的ip。</li><li id="496d" class="kw kx hu ja b jb lf jf lg jj lh jn li jr lj jv lb lc ld le dt translated">代理检查请求url，并从请求中提取会话id。</li><li id="f831" class="kw kx hu ja b jb lf jf lg jj lh jn li jr lj jv lb lc ld le dt translated">它通过删除嵌入的主机ip部分来重写url路径。</li><li id="e2a5" class="kw kx hu ja b jb lf jf lg jj lh jn li jr lj jv lb lc ld le dt translated">它还将上游主机设置为在会话id的ip部分中找到的特定主机。</li><li id="663a" class="kw kx hu ja b jb lf jf lg jj lh jn li jr lj jv lb lc ld le dt translated">然后，它将请求转发到所需的集线器。</li><li id="0f70" class="kw kx hu ja b jb lf jf lg jj lh jn li jr lj jv lb lc ld le dt translated">集线器看到的会话id与它生成时的格式完全相同，并继续照常处理。</li></ol><p id="a365" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">嵌入lua代码的nginx配置示例:</p><div class="lk ll fm fo lm ln"><a href="https://github.com/Mitendra/code_samples/blob/master/scaling_selenium/nginx.conf" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab ej"><div class="lp ab lq cl cj lr"><h2 class="bd hv fv z el ls eo ep lt er et ht dt translated">Mitendra/code_samples</h2><div class="lu l"><h3 class="bd b fv z el ls eo ep lt er et ek translated">在GitHub上创建一个帐户，为Mitendra/code_samples开发做贡献。</h3></div><div class="lv l"><p class="bd b gc z el ls eo ep lt er et ek translated">github.com</p></div></div><div class="lw l"><div class="lx l ly lz ma lw mb iw ln"/></div></div></a></div><figure class="mc md me mf fq iv"><div class="bz el l di"><div class="mg mh l"/></div></figure><h2 id="b3a8" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">更进一步</h2><p id="38cf" class="pw-post-body-paragraph iy iz hu ja b jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr kv jt ju jv hn dt translated">在使用openresty代理解决规模和可用性问题的同时，我们可以将该代理用于构建在Selenium hub之上的更多功能。</p><ol class=""><li id="aa29" class="kw kx hu ja b jb jc jf jg jj ky jn kz jr la jv lb lc ld le dt translated">速率限制:尽管这有助于扩展集线器和节点，但在某些情况下，新会话的数量可能会超过可用资源的数量。目前，所有请求都被放入队列中，并在资源可用时进行处理，这导致了会话创建的延迟。不同的测试用例/框架有不同的超时设置，虽然其中一些会继续，但很多会停滞。很多时候，当客户端/测试用例层的会话超时时，集线器仍然会继续运行并创建一个会话。这些未使用的会话稍后会被清理掉，但这会使资源短缺更加严重。为了解决这个问题，我们可以添加一个速率限制功能，根据容量和流量模式，只允许队列中特定数量的会话，超过这个数量，我们可以返回一个http 429状态，其中包含一些详细信息，如当前活动会话和估计的重试时间。</li><li id="c4d5" class="kw kx hu ja b jb lf jf lg jj lh jn li jr lj jv lb lc ld le dt translated">监控数据:我们可以从代理层添加许多关于请求的会话、创建新会话的时间、活动会话时间等的监控数据，这可以进一步了解如何优化基础架构的使用。</li></ol><h2 id="f644" class="jw jx hu bd jy jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq dt translated">参考</h2><p id="9554" class="pw-post-body-paragraph iy iz hu ja b jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr kv jt ju jv hn dt translated">图片来源:<a class="ae mi" href="https://pixabay.com/en/skyscraper-highrise-building-tall-1209407/" rel="noopener ugc nofollow" target="_blank">https://pix abay . com/en/摩天大楼-高层建筑-高层-1209407/ </a></p><p id="110a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">硒:【https://www.seleniumhq.org/ T2】</p><p id="5ad4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">硒栅:【https://www.seleniumhq.org/docs/07_selenium_grid.jsp T4】</p><p id="da03" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">openresty:<a class="ae mi" href="https://openresty.org/en/" rel="noopener ugc nofollow" target="_blank">https://openresty.org/en/</a></p><div class="lk ll fm fo lm ln"><a href="https://github.com/openresty/lua-nginx-module#body_filter_by_lua" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab ej"><div class="lp ab lq cl cj lr"><h2 class="bd hv fv z el ls eo ep lt er et ht dt translated">openresty/Lua-nginx-模块</h2><div class="lu l"><h3 class="bd b fv z el ls eo ep lt er et ek translated">将Lua的能力嵌入NGINX HTTP服务器。为openresty/lua-nginx-module开发做出贡献，创建一个…</h3></div><div class="lv l"><p class="bd b gc z el ls eo ep lt er et ek translated">github.com</p></div></div><div class="lw l"><div class="mj l ly lz ma lw mb iw ln"/></div></div></a></div><div class="lk ll fm fo lm ln"><a href="https://github.com/openresty/lua-nginx-module#access_by_lua" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab ej"><div class="lp ab lq cl cj lr"><h2 class="bd hv fv z el ls eo ep lt er et ht dt translated">openresty/Lua-nginx-模块</h2><div class="lu l"><h3 class="bd b fv z el ls eo ep lt er et ek translated">将Lua的能力嵌入NGINX HTTP服务器。为openresty/lua-nginx-module开发做出贡献，创建一个…</h3></div><div class="lv l"><p class="bd b gc z el ls eo ep lt er et ek translated">github.com</p></div></div><div class="lw l"><div class="mk l ly lz ma lw mb iw ln"/></div></div></a></div></div></div>    
</body>
</html>