<html>
<head>
<title>Interacting with MapR-DB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与MapR-DB交互</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/interacting-with-mapr-db-58c4f482efa1?source=collection_archive---------9-----------------------#2018-12-14">https://medium.com/hackernoon/interacting-with-mapr-db-58c4f482efa1?source=collection_archive---------9-----------------------#2018-12-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/5ef6643f19d01041140eae5d743d7fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*-BT_BwyWeEW67aFvQW7bvg.png"/></div></figure><p id="51ef" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt jw translated">apR平台是一个很好的选择，可以解决与当今企业庞大且持续增长的数据集相关的许多问题。</p><p id="cfcf" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">高效的分布式文件系统以及强大而简单的标准流API是该平台成功的关键因素。然而，它最著名的部分之一是它的分布式、非T2 SQL、高度可用的JSON数据库。</p><p id="5511" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">MapR-DB支持HBase API以实现回溯兼容性，但最新的OJAI API是它的核心。</p><p id="0da2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们看一个可以存储在MapR-DB中的文档的例子。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="202b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是MapR-DB可以存储的纯JSON。这份文件可以像我们想要的那样复杂。实际上对文档大小、字段或递归嵌套字段的数量没有限制。</p><p id="e1dd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">文档存储在MapR集群中，因此对表的读写是并行进行的，分散了工作负载，并获得了令人印象深刻的性能数据，如一些独立的基准测试所示。</p><p id="0c06" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">下面的图片展示了其中的一些。</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff km"><img src="../Images/85a3a3ca9962fdd14e9c7fbfc9141e11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h8v7LObhsqCplzk4RDHcXA.png"/></div></div></figure><p id="2d1d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">MapR-DB每秒可以完成比竞争对手多得多的操作。</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff kr"><img src="../Images/ed973a6c2ce172a36b88eee708f80022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_6acfGlNpGB_AI3y6S3vg.png"/></div></div></figure><p id="f17b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">MapR-DB保持低延迟、恒定和可预测。</p><blockquote class="ks kt ku"><p id="3aa1" class="iy iz kf ja b jb jc jd je jf jg jh ji kv jk jl jm kw jo jp jq kx js jt ju jv hn dt translated">整个对比可以在这里找到<a class="ae ky" href="https://mapr.com/whitepapers/mike-leone-esg-lab-nosql-benchmark/assets/esg-lab-review-mapr-db-20170824.pdf" rel="noopener ugc nofollow" target="_blank"><strong class="ja hv"><em class="hu"/></strong></a>。</p></blockquote><p id="8879" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当读取或更新文档时，MapR-DB知道文档的哪一部分需要被读取或更新，并且只有那些部分被实际接触。MapR-DB试图有效地操作文档、表和底层文件系统，以保持最佳性能。</p><h1 id="c426" class="kz la hu bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">查询MapR-DB</h1><p id="77fd" class="pw-post-body-paragraph iy iz hu ja b jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr mb jt ju jv hn dt translated">MapR-DB是非<em class="kf"> SQL </em>数据库，因此它本身不支持<em class="kf"> SQL </em>。<a class="ae ky" href="https://github.com/ojai/ojai" rel="noopener ugc nofollow" target="_blank"><strong class="ja hv"><em class="kf">OJAI API</em></strong></a>是与MapR-DB交互的首选方式，通过使用该API，我们可以利用该数据库提供的所有功能。</p><p id="522f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以使用任何提供的客户机在MapR-DB上运行查询。下面是一个使用Java API创建文档的例子。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="ce67" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">正如我们所见，API允许以友好的方式操作对象，因为它们代表JSON文档。</p><p id="2e96" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">通过OJAI API，我们可以对MapR-DB进行各种操作，比如插入、更新等…</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="a19e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">基本上，从任何能够使用OJAI API的应用程序，我们都能够在MapR-DB中完成大部分工作。然而，我们可以问自己，需要不同处理能力的其他类型的工具呢？</p><p id="39f0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">例如，BI工具可以执行计数、分组、求和等聚合操作。另一方面，我们还应该能够快速查看数据库中的值，而无需编写应用程序，但这在MapR-DB中可能吗？让我们探索我们的选择。</p><h1 id="1e9f" class="kz la hu bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">MapR数据库外壳</h1><p id="6ad1" class="pw-post-body-paragraph iy iz hu ja b jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr mb jt ju jv hn dt translated">MapR-DB提供了一个名为<code class="eh mc md me mf b">dbshell</code>的工具，可以使用它的本地语言查询数据库。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="c619" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">使用<code class="eh mc md me mf b">dbshell</code>我们可以探索我们有哪些表，以所有可能的方式查询它们等等。让我们看一些例子。</p><p id="7d08" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们先列出我们在<code class="eh mc md me mf b">path</code>名下的桌子。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="c10c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们在这个表中插入一些值。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="1ff0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，让我们列出文件。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="26d0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以通过<code class="eh mc md me mf b">id</code>查询。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="a901" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">或者我们可以使用任何其他字段。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="2541" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">请注意查询是如何完成的。这是OJAI查询语言和API在发挥作用。这是MapR-DB的固有特性。<em class="kf">记住，它不是SQL数据库。</em></p><p id="0a42" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">正如您所想象的，<code class="eh mc md me mf b">dbshell</code>是体验MapR-DB如何工作以及进行快速简单探索的好方法。然而，可能很难将它视为大型复杂查询的首选工具。</p><p id="4abf" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们继续探索我们拥有的选项以及如何使用它们。</p><h1 id="63b5" class="kz la hu bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">Apache Spark的MapR-DB连接器</h1><p id="4733" class="pw-post-body-paragraph iy iz hu ja b jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr mb jt ju jv hn dt translated">MapR为Apache Spark提供了一个连接器，可用于MapR-DB之上的大型数据处理。</p><p id="3d86" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">该连接器可用于不同的Spark APIs，如<code class="eh mc md me mf b">RDD[A]</code>、<code class="eh mc md me mf b">DStream[A]</code>和<code class="eh mc md me mf b">DataFrame/DataSet[A]</code>。</p><p id="27ae" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了使用连接器，我们必须首先向我们的spark项目添加正确的依赖项。下面是来自<code class="eh mc md me mf b"><a class="ae ky" href="https://github.com/anicolaspp/reactor" rel="noopener ugc nofollow" target="_blank">Reactor</a></code>项目的一个<code class="eh mc md me mf b">build.sbt</code>文件。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="58f7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们应该可以毫无问题地使用连接器了。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="006a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">上面的例子只显示了应用程序的一个片段，但是请注意连接器是如何用于从MapR-DB加载数据帧和将数据帧保存到MapR-DB的。对于前面提到的其他Apache Spark抽象，也可以这样做。</p><p id="94da" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">使用Apache Spark的MapR-DB连接器，我们打开了无限的可能性，因为我们可以将MapR-DB和Apache Spark的分布式特性结合在一起，因此我们能够真正大规模地处理数据。</p><p id="71ff" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">尽管Apache Spark是我们工具集中最好的工具之一，但有时它还不够。我们需要问自己，没有编码经验的用户如何使用MapR-DB的强大功能，而不需要经历Spark的学习过程，老实说，这个过程不短也不容易。</p><h1 id="f7fa" class="kz la hu bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">使用Apache Drill的分布式处理</h1><blockquote class="ks kt ku"><p id="87be" class="iy iz kf ja b jb jc jd je jf jg jh ji kv jk jl jm kw jo jp jq kx js jt ju jv hn dt translated">当我们需要SQL时，我们有Drill。</p></blockquote><p id="251a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">使用Apache Drill，我们可以查询MapR平台中的几乎所有数据集，无论它存储在哪里，如何格式化，或者大小如何。</p><p id="c2b1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">与Drill的交互可以通过它的不同接口来完成。让我们从使用drill shell开始，因为它提供了一个非常简单的基于shell的解决方案。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="2bf9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以看到，我们可以通过Apache Drill使用纯<em class="kf"> SQL </em>查询MapR-DB，这是非<em class="kf"> SQL </em>数据库。正如所料，结果以表格的形式返回。正如您可能怀疑的那样，所有类型的查询都可以执行，聚合尤其有趣。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="10c1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在MapR-DB上运行这样的查询是令人兴奋的。Drill确切地知道如何将<em class="kf"> SQL </em>查询转换成底层的MapR-DB查询语言。</p><p id="4f97" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">需要注意的是，Drill也在MapR集群上分布式运行，因此同样的数据分布和高性能原则在这里仍然适用。</p><h2 id="1b4b" class="mg la hu bd lb mh mi mj lf mk ml mm lj jj mn mo ln jn mp mq lr jr mr ms lv mt dt translated">其他Apache Drill接口</h2><p id="66c8" class="pw-post-body-paragraph iy iz hu ja b jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr mb jt ju jv hn dt translated">外壳不是钻头支持的唯一接口。我们也可以使用Drill through REST接口。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="5e5c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">此外，Drill还提供了一个更友好的网络界面。伴随这些接口而来的是JDBC和ODBC接口。这些对于像Tableau、Microstrategy和其他与Drill连接和交互的BI工具非常重要。</p><p id="fc59" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们之前讨论过的同样的想法在这里也适用。例如，Tableau可以通过JDBC连接到Drill，Drill将在MapR-DB上运行分布式查询。这使得MapR-DB成为一个非常通用和强大的数据库。</p><h1 id="d2d5" class="kz la hu bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw dt translated">结论</h1><p id="068c" class="pw-post-body-paragraph iy iz hu ja b jb lx jd je jf ly jh ji jj lz jl jm jn ma jp jq jr mb jt ju jv hn dt translated">MapR-DB是最强大的非<em class="kf">SQL</em>选项之一。它在同一平台下提供HBase和JSON功能。它在MapR集群上分布式运行，共享底层平台(MapR-FS)上的大部分属性。MapR-DB可以以多种形式进行查询，例如OJAI API for application、<code class="eh mc md me mf b">dbshell</code>for quick and simple interactions、Apache Spark for scale data processing和Apache Drill for <em class="kf"> SQL </em>查询和数据分析以及BI工具集成。无论使用何种工具，MapR-DB都将性能放在首位，在任何规模下都保持低延迟和每秒快速操作，这使得它非常适合未来的下一代工作负载。</p></div><div class="ab cl mu mv hc mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hn ho hp hq hr"><p id="da5d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="kf">MapR-DB的其他工具是独立开发的，比如</em> <code class="eh mc md me mf b"><a class="ae ky" href="https://github.com/anicolaspp/maprdb-cleaner" rel="noopener ugc nofollow" target="_blank"><em class="kf">maprdbcls</em></a></code> <em class="kf">，这里</em>  <em class="kf">可以找到</em> <a class="ae ky" href="https://github.com/anicolaspp/maprdb-cleaner" rel="noopener ugc nofollow" target="_blank"> <em class="kf">。它允许基于查询删除文档(记录)。</em></a></p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="nb kl l"/></div></figure></div></div>    
</body>
</html>