<html>
<head>
<title>MapR-DB Atomic Document Updates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MapR-DB原子文档更新</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/mapr-db-atomic-document-updates-d54f535b589?source=collection_archive---------6-----------------------#2018-12-15">https://medium.com/hackernoon/mapr-db-atomic-document-updates-d54f535b589?source=collection_archive---------6-----------------------#2018-12-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/03a6193269b954d6254a2b4825cb55ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*lurj48XAZzmt5AE_DKjkGA.png"/></div></figure><p id="805f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt jw translated"><span class="l jx jy jz bm ka kb kc kd ke di">在</span> a <a class="ae kf" rel="noopener" href="/@anicolaspp/interacting-with-mapr-db-58c4f482efa1"> <em class="kg">前一篇文章</em> </a>中，我们已经讨论了MapR-DB的一些特性，这些特性使得这个分布式数据库特别有趣。在本帖中，我们打算通过展示一个具体的用例来继续这一努力。</p><h2 id="1d72" class="kh ki hu bd kj kk kl km kn ko kp kq kr jj ks kt ku jn kv kw kx jr ky kz la lb dt translated">问题是</h2><p id="4554" class="pw-post-body-paragraph iy iz hu ja b jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv hn dt translated">要解决的问题可以描述如下。</p><blockquote class="lh li lj"><p id="90a4" class="iy iz kg ja b jb jc jd je jf jg jh ji lk jk jl jm ll jo jp jq lm js jt ju jv hn dt translated">一系列消息通过一个流传来。每个值都有一个<code class="eh ln lo lp lq b"><em class="hu">id</em></code>和一个<code class="eh ln lo lp lq b"><em class="hu">count</em></code>。对于每个<code class="eh ln lo lp lq b"><em class="hu">id</em></code>,我们必须通过使用流中的<code class="eh ln lo lp lq b"><em class="hu">count</em></code>增加其值来更新数据库中现有的<code class="eh ln lo lp lq b"><em class="hu">count</em></code>。</p></blockquote><p id="e630" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">下图显示了该问题的一个示例。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff lr"><img src="../Images/78f9ed4b757fe6eadd218ea0349bae52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RNSGCW1Hstce36uE9IyhCA.png"/></div></div><figcaption class="ma mb fg fe ff mc md bd b be z ek">The problem in an image.</figcaption></figure><p id="d0fe" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">有各种方法可以解决这个问题。一种方法是读取存储在数据库中的给定<code class="eh ln lo lp lq b">id</code>的当前状态，然后使用流中的值更新其<code class="eh ln lo lp lq b">count</code>，最后将更新后的值保存回数据库。</p><p id="883e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们来详细看看这个过程。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="fe ff lr"><img src="../Images/9c7917666ee42ed2bb5153af8d8af70b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BLUdpPDf5yNAx9KLyxC1Iw.jpeg"/></div></div><figcaption class="ma mb fg fe ff mc md bd b be z ek">Loading, merging, and saving.</figcaption></figure><p id="0d35" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">正如我们在上面的图像中看到的，为了更新数据库中的状态，我们需要首先从数据库中加载每条数据，将值与传入的流连接起来以计算新的状态，最后，将新的状态保存回持久存储。一般来说，无论我们选择使用哪种数据库技术，无论是MapR-DB还是任何其他持久性技术，我们都必须遵循相同的过程。</p><p id="0f0a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">下面的代码展示了我们如何使用与MapR-ES (MapR Streams technology)和MapR-DB集成的Apache Spark来实现这个想法。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="2741" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">需要注意的是，在每张流式幻灯片上，我们从MapR-DB(或任何其他数据库)加载，并将加载的数据帧与流合并。然后，我们将当前最近计算的新状态保存回数据库。</p><p id="c117" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个过程完全有意义，而且在大多数数据库中，这是无法回避的。然而，每次我们在流上接收数据时，这些操作的执行成本都很高。</p><h1 id="6205" class="mg ki hu bd kj mh mi mj kn mk ml mm kr mn mo mp ku mq mr ms kx mt mu mv la mw dt translated">MapR-DB突变</h1><blockquote class="lh li lj"><p id="e70c" class="iy iz kg ja b jb jc jd je jf jg jh ji lk jk jl jm ll jo jp jq lm js jt ju jv hn dt translated">别人摔短裤的时候，MapR-DB大放异彩。</p></blockquote><p id="0c62" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">MapR-DB能够增量更新文档，而不需要先加载它们。更具体地说，可以只更新文档的某些字段，而不涉及文档级别的任何其他内容。</p><p id="24c9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一个合理的问题是:鉴于MapR-DB的分布式本质，这些更新是自动应用的吗？答案是肯定的。</p><p id="a62a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们先写一些代码来证明最后一个陈述，然后我们将使用这个概念来解决问题。</p><p id="f882" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以从下面的代码片段开始。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="5348" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">正如我们所见，<code class="eh ln lo lp lq b">run</code>函数将为给定的<code class="eh ln lo lp lq b">id</code>增加<code class="eh ln lo lp lq b">count</code>，具体来说，是增加<code class="eh ln lo lp lq b">times</code>倍。</p><p id="6734" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">基于这段代码，我们可以创建另一个函数，通过创建多个线程并在每个线程上执行<code class="eh ln lo lp lq b">UpdateSameId.run</code>来并行执行相同的操作。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="5562" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以用下面的方式运行上面的代码。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="22dd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这将打印出MapR-DB上每个文档的最终状态，通过这一点，我们可以肯定地说更新是自动应用的。</p><blockquote class="lh li lj"><p id="66aa" class="iy iz kg ja b jb jc jd je jf jg jh ji lk jk jl jm ll jo jp jq lm js jt ju jv hn dt translated">整个代码是<a class="ae kf" href="https://github.com/anicolaspp/reactor/tree/master/mapr_db_atomic_updates" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hv"> <em class="hu">反应器项目的一部分，你可以在这里找到</em> </strong> </a>。</p></blockquote><p id="92c1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">正如我们所看到的，即使在多线程或多处理器环境中运行，MapR-DB也能保证值的一致(原子)更新。为了增加并行性，我们可以使用Apache Spark编写类似的代码，但是结果是一样的；我们试过了。</p><p id="88f7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">基于这些发现，我们可以改进我们的原始应用程序，以解决我们首先提出的问题。</p><p id="fd6a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们从删除首先从MapR-DB加载的部分开始，用更新替换它们。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="b93d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们回顾一下我们最初的应用程序的一些重要变化。</p><p id="c303" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先，根本不需要从数据库加载当前状态。相反，我们创建必要的突变，并将它们并行应用于MapR-DB。</p><p id="5783" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">其次，我们显著减少了Spark必须执行的任务数量，提高了整体性能，同时降低了数据库的负载。</p><p id="ae27" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第三，代码更简单、更优雅、更容易理解，增加了可维护的索引，同时使其他人的生活更容易。</p><p id="b17d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后，我们为每个分区创建一个连接，这样我们可以避免任何Spark串行化问题，同时增加并行性，因为每个分区操作将同时运行(Spark magic在这里工作)。</p><p id="010c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">流程运行后，我们可以放心，我们的数据将通过我们最新的方法得到正确有效的更新。</p><h1 id="5e86" class="mg ki hu bd kj mh mi mj kn mk ml mm kr mn mo mp ku mq mr ms kx mt mu mv la mw dt translated">结论</h1><p id="3e07" class="pw-post-body-paragraph iy iz hu ja b jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv hn dt translated">如前所述，MapR-DB是一个非SQL数据库，具有非常有趣的特性，值得探索。这些特性不仅使它成为高性能和分布式工作负载的首选，也使我们作为问题解决者的生活更加轻松。尽管MapR-DB固有的分布式本质，我们可以将自己从像这样的复杂系统所具有的许多问题中抽象出来，并轻松地使用MapR-DB来解决市场上最复杂的业务问题。</p></div><div class="ab cl mx my hc mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hn ho hp hq hr"><p id="2a67" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">请阅读<a class="ae kf" rel="noopener" href="/@anicolaspp/interacting-with-mapr-db-58c4f482efa1"> <strong class="ja hv"> <em class="kg">与MapR-DB</em></strong></a><strong class="ja hv"><em class="kg"/></strong>进行交互，以更全面地了解如何使用MapR-DB及其相关工具。</p></div></div>    
</body>
</html>