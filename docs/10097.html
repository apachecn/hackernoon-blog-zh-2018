<html>
<head>
<title>Strengthen TLS in React Native Through Certificate Pinning — iOS Edition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过证书锁定增强React Native中的TLS—iOS版</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/strengthen-tls-in-react-native-through-certificate-pinning-ios-edition-9a42562b6da6?source=collection_archive---------7-----------------------#2018-12-16">https://medium.com/hackernoon/strengthen-tls-in-react-native-through-certificate-pinning-ios-edition-9a42562b6da6?source=collection_archive---------7-----------------------#2018-12-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="e7a5" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">增强React Native在Android和iOS上的联网API保护，无需接触您的Javascript代码或手动编辑本机代码项目。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/25bfae5a54ad2cabff57d4c04214a687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XCFMEiy3-OabmOjy"/></div></div></figure><p id="af07" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">本文第一版实现了Android上React原生应用的TLS证书锁定。从那时起，<a class="ae kr" href="https://www.npmjs.com/package/react-native-cert-pinner" rel="noopener ugc nofollow" target="_blank"> react-native-cert-pinner </a>包已经得到了增强，以支持在iOS设备上的锁定，这一期的帖子遍历了之前针对iOS的示例。</p><p id="abd4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">从2018年7月68版本开始，Chrome开始将所有不运行HTTPS (TLS over HTTP)的网站标记为“不安全”。TLS使用站点证书建立信任链，并在传输层加密通信。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/a21a64fafe1775a2cb376671ba733995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*kAH6eUkBw0o2THy3"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">SOURCE: <a class="ae kr" href="https://security.googleblog.com/2018/02/a-secure-web-is-here-to-stay.html" rel="noopener ugc nofollow" target="_blank">Google Security Blog</a></figcaption></figure><p id="db47" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是网络、API和<a class="ae kr" href="https://hackernoon.com/mobile-api-security-techniques-682a5da4fe10" rel="noopener ugc nofollow" target="_blank">移动安全</a>的重大提升，但尤其是在移动设备上，这可能还不够。不幸的是，欺骗移动设备信任由意想不到的证书颁发机构签署的证书太容易了。<a class="ae kr" href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning" rel="noopener ugc nofollow" target="_blank">证书锁定</a>应用于限制对网站叶证书的信任，或仅限于应用本身信任的中间或根授权机构。</p><p id="bbb8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">由于实施和维护上的困难，证书锁定并没有得到应有的普及。对于React Native，这甚至更具挑战性，因为实现锁定所需的网络接口没有在javascript层公开。</p><p id="30ae" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当前可用的支持React Native中证书锁定的包需要<a class="ae kr" href="https://www.npmjs.com/package/react-native-pinch" rel="noopener ugc nofollow" target="_blank">替换内置的网络包</a>或<a class="ae kr" href="http://www.madebymany.com/stories/a-year-of-react-native-ssl-pinning" rel="noopener ugc nofollow" target="_blank">手动更改本机代码</a>。这个npm包，<a class="ae kr" href="https://www.npmjs.com/package/react-native-cert-pinner" rel="noopener ugc nofollow" target="_blank">react-native-cert-pinner</a>，不需要对javascript代码做任何修改就可以进行网络获取。用于固定连接的底层本机代码完全由开发人员指定的JSON配置文件生成。这是一项正在进行的工作，目前可以在Android和iOS上使用，随后会有额外的软件包自动化和安全性。</p><h1 id="2b27" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">防止中间人攻击</h1><p id="c37a" class="pw-post-body-paragraph jv jw hu jx b jy lp iv ka kb lq iy kd ke lr kg kh ki ls kk kl km lt ko kp kq hn dt translated">一年的React Native: SSL Pinning 很好地描述了移动连接的风险，甚至在使用TLS时也是如此。对证书颁发机构或移动设备的损害会导致应用程序不正确地信任假冒的服务器证书，并允许攻击者将其自身插入到连接中，静默地解密、观察、可能修改和重新加密本应安全的通信。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lu"><img src="../Images/5701dd2ebb473852210c37c338802ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jsdpCDWzxOuVhdEK"/></div></div></figure><p id="fb00" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">证书锁定基于现有的HTTPS(HTTP上的SSL或TLS)技术。使用TLS，移动设备会跟踪证书链，直到到达由它信任的机构签署的证书。</p><p id="9db2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">证书锁定用于识别特定证书或限制受信任为目标网站签名的证书颁发机构的数量。通过在应用程序中固定受信任服务器证书的有限列表，欺诈性签名的证书，即使其证书颁发机构受到设备的信任，也将被应用程序拒绝。该应用程序可以锁定服务器的叶证书和中间证书。</p><p id="e196" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">通常建议固定多个证书的公钥，以便在其他密钥泄露的情况下，应用程序仍然可以信任一个密钥。</p><p id="f985" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">SSL固定是一种缓解方法，旨在降低通过假冒后端服务器的SSL证书实现的MitM攻击的有效性。锁定中间密钥简化了证书轮换和更新。检查公钥的散列是方便的，并且对任何攻击者隐藏了证书信息。</p><h1 id="3647" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">React本机示例应用程序</h1><p id="3f0a" class="pw-post-body-paragraph jv jw hu jx b jy lp iv ka kb lq iy kd ke lr kg kh ki ls kk kl km lt ko kp kq hn dt translated">NPM<a class="ae kr" href="https://www.npmjs.com/package/react-native-cert-pinner" rel="noopener ugc nofollow" target="_blank">react-native-cert-pin ner</a>模块包含一个示例应用程序，我们将使用它来</p><p id="e175" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">演示证书锁定。该应用程序检查与demo-server . approvr . io服务器的HTTPS连接:</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="7cb2" class="ma ky hu lw b fv mb mc l md me">$ curl <a class="ae kr" href="https://demo-server.approovr.io" rel="noopener ugc nofollow" target="_blank">https://demo-server.approovr.io</a></span><span id="cba4" class="ma ky hu lw b fv mf mc l md me">Hello World!</span></pre><p id="7064" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">由于TLS不是通过fetch()等React原生网络调用公开的，所以必须引入原生模块，Expo环境不容易用于开发。</p><p id="7dbb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先使用<code class="eh mg mh mi lw b">react-native-cli</code>初始化一个React本地项目:</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="8d8d" class="ma ky hu lw b fv mb mc l md me">$ react-native init example<br/>Installing react-native…</span></pre><p id="cc3d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来安装<a class="ae kr" href="https://www.npmjs.com/package/react-native-cert-pinner" rel="noopener ugc nofollow" target="_blank">react-native-cert-pin ner</a>包:</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="76b5" class="ma ky hu lw b fv mb mc l md me">$ cd example<br/>$ npm install -S react-native-cert-pinner<br/>+ react-native-cert-pinner@0.3.0<br/>added 4 packages from 2 contributors and audited packages in 6.689s<br/>found 0 vulnerabilities</span></pre><p id="0fe3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">使用react-native自动链接cert pinner本机模块:</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="6769" class="ma ky hu lw b fv mb mc l md me">$ react-native link<br/>Scanning folders for symlinks in /Users/skiph/Projects/<br/>  rn-pinning/rncp-test/example/node_modules (13ms)<br/>rnpm-install info Linking react-native-cert-pinner ios dependency<br/>rnpm-install info Platform ‘ios’ module react-native-cert-pinner has<br/>  been successfully linked<br/>rnpm-install info Linking react-native-cert-pinner android<br/>  dependency<br/>rnpm-install info Platform ‘android’ module react-native-cert-pinner<br/>  has been successfully linked</span></pre><p id="399b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">删除默认的<code class="eh mg mh mi lw b">index.js</code>和<code class="eh mg mh mi lw b">App.js</code>文件，从cert pinner包的示例目录中安装<code class="eh mg mh mi lw b">index.js</code>和<code class="eh mg mh mi lw b">src/</code>文件:</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="7f38" class="ma ky hu lw b fv mb mc l md me">$ rm ./index.js ./App.js<br/>$ cp ./node_modules/react-native-cert-pinner/example/index.js ./<br/>$ cp -r ./node_modules/react-native-cert-pinner/example/src ./</span></pre><p id="80b8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">对于iOS，复制示例<code class="eh mg mh mi lw b">podfile</code>并手动安装pod:</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="fb1a" class="ma ky hu lw b fv mb mc l md me">$ cp ./node_modules/react-native-cert-pinner/example/ios/podfile ./ios/<br/>$ cd ios &amp;&amp; pod install</span></pre><p id="bc79" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您应该准备好构建和运行应用程序。确保iOS模拟器正在运行或iOS设备已连接，并启动应用程序:</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="b560" class="ma ky hu lw b fv mb mc l md me">$ react-native run-ios<br/>…</span><span id="4489" class="ma ky hu lw b fv mf mc l md me">** BUILD SUCCEEDED **</span><span id="9e9e" class="ma ky hu lw b fv mf mc l md me">The following commands produced analyzer issues:<br/> Analyze …/RCTModuleMethod.mm normal x86_64<br/> Analyze …/RCTImageCache.m normal x86_64<br/> Analyze …/RCTNetInfo.m normal x86_64<br/>(3 commands with analyzer issues)</span><span id="f43b" class="ma ky hu lw b fv mf mc l md me">Installing build/Build/Products/Debug-iphonesimulator/example.app<br/>Launching org.reactjs.native.example.example<br/>org.reactjs.native.example.example: 9252</span></pre><p id="58cb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在开始屏幕上，按下屏幕底部的测试Hello按钮。成功的连接将显示一个笑脸:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/b09e758a29d282bbddcd743b6a778930.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/0*RbtvZsep16qmV3lN"/></div></figure><p id="a41d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">尽管通过TLS成功建立了连接，但没有使用证书锁定。</p><h1 id="7fd2" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">固定可信证书</h1><p id="19b4" class="pw-post-body-paragraph jv jw hu jx b jy lp iv ka kb lq iy kd ke lr kg kh ki ls kk kl km lt ko kp kq hn dt translated">要添加证书固定，首先要在示例项目的主目录中初始化一个pinset配置文件:</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="c6dc" class="ma ky hu lw b fv mb mc l md me">$ npx pinset init<br/>File ‘./pinset.json’ initialized.</span></pre><p id="73b3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来，从用于演示服务器的证书链中确定几个公钥哈希。approvr . io .<a class="ae kr" href="https://report-uri.com/" rel="noopener ugc nofollow" target="_blank">https://report-uri.com/home/pkp_hash</a><a class="ae kr" href="https://report-uri.com/home/pkp_hash" rel="noopener ugc nofollow" target="_blank">的</a>报告URI<a class="ae kr" href="https://report-uri.com/home/pkp_hash" rel="noopener ugc nofollow" target="_blank">有一个方便的查找服务。在撰写本文时，可用的公钥散列是:</a></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mk"><img src="../Images/85f236d7e58c51061af2720d520bd8f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OowwyBTXr56crx4x"/></div></div></figure><p id="41ed" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">编辑<code class="eh mg mh mi lw b">pinset.json</code>以锁定一些关键散列:</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="4ddc" class="ma ky hu lw b fv mb mc l md me">{<br/>  “domains”: {<br/>    “*.approovr.io”: {<br/>      “pins”: [<br/>        “sha256/oq+Uj+2TYMg13txh1pXW0/VLAkonU3TnoPr5hfxPZVc=”,<br/>        “sha256/8Rw90Ej3Ttt8RRkrg+WYDS9n7IS03bk5bjP/UXPtaY8=”<br/>      ] <br/>    } <br/>  } <br/>}</span></pre><p id="791b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在生产应用程序中，您需要为应用程序与之通信的每个服务器域添加pin。如果您连接到许多服务器，考虑使用一个<a class="ae kr" href="https://hackernoon.com/whitelists-and-indirection-go-together-like-chocolate-and-peanut-butter-a350786f8381" rel="noopener ugc nofollow" target="_blank"> API代理网关</a>来提高API保护并减少您需要管理的pin集数量。</p><p id="89d1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">通过运行pinset gen生成所需的本地项目文件:</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="05db" class="ma ky hu lw b fv mb mc l md me">$ npx pinset gen<br/>Reading config file ‘./pinset.json’.<br/>Updating plist file ‘./ios/example/info.plist’.</span></pre><p id="2dc8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果您认为发布公钥证书的散列是一种安全违规，您可能希望从存储库中删除或忽略pinset配置和生成的文件。在您的根文件<code class="eh mg mh mi lw b">.gitignore</code>中，添加:</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="3e1e" class="ma ky hu lw b fv mb mc l md me"># default configuration file<br/>./pinset.json</span><span id="234b" class="ma ky hu lw b fv mf mc l md me"># default generated source files<br/>./ios/example/info.plist</span></pre><p id="077f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">重新构建并启动修改后的应用程序。您应该会再次看到一个成功的连接，但是这一次连接被至少一个公钥哈希锁定。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/c3c16d2adff149587de2a14e3550e7c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/0*dfxqQy-OlLH6XfOz"/></div></figure><h1 id="926a" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">拒绝无法识别的证书</h1><p id="7223" class="pw-post-body-paragraph jv jw hu jx b jy lp iv ka kb lq iy kd ke lr kg kh ki ls kk kl km lt ko kp kq hn dt translated">要测试证书锁定，请更改<code class="eh mg mh mi lw b">pinset.json</code>中的<code class="eh mg mh mi lw b">*.approovr.io</code>公钥散列，使它们不匹配任何预期值:</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="8e2d" class="ma ky hu lw b fv mb mc l md me">{<br/>  “domains”: {<br/>    “*.approovr.io”: {<br/>      “pins”: [<br/>        “sha256/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX”<br/>      ] <br/>    } <br/>  }<br/>}</span></pre><p id="3318" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">通过运行<code class="eh mg mh mi lw b">pinset gen</code>重新生成本地项目文件:</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="3d7f" class="ma ky hu lw b fv mb mc l md me">$ npx pinset gen<br/>Reading config file ‘./pinset.json’.<br/>Updating plist file ‘./ios/example/info.plist’.</span></pre><p id="2139" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">重新构建并启动修改后的应用程序。这一次您应该会看到一个连接失败，因为应用程序找不到与其预期pin匹配的公钥散列。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/a7d944592ae48aacbd8ef1c19b94a208.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/0*vmSpMvX-eyVLRoQt"/></div></figure><h1 id="8bcf" class="kx ky hu bd kz la lb lc ld le lf lg lh ja li jb lj jd lk je ll jg lm jh ln lo dt translated">暂时结束</h1><p id="764d" class="pw-post-body-paragraph jv jw hu jx b jy lp iv ka kb lq iy kd ke lr kg kh ki ls kk kl km lt ko kp kq hn dt translated">您已经成功地演示了一个针对iOS上的React Native的pinning实用程序，它使用内置的fetch() API，而不需要对本机iOS代码进行任何手动编辑。参见本文的<a class="ae kr" href="https://hackernoon.com/strengthen-tls-in-react-native-through-certificate-pinning-e6e8d53e8254" rel="noopener ugc nofollow" target="_blank">第一版</a>以在Android中遵循相同的示例。</p><p id="b1c7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">未来的软件包增强功能包括:</p><ul class=""><li id="ce12" class="ml mm hu jx b jy jz kb kc ke mn ki mo km mp kq mq mr ms mt dt translated">每当管脚集配置改变时，自动重新生成本地源文件。</li><li id="01de" class="ml mm hu jx b jy mu kb mv ke mw ki mx km my kq mq mr ms mt dt translated">将源代码重新生成和git忽略添加到大部分自动反应的本地链接步骤中。</li><li id="b72b" class="ml mm hu jx b jy mu kb mv ke mw ki mx km my kq mq mr ms mt dt translated">将证书公钥哈希查找添加到pinset实用程序。</li><li id="b6e9" class="ml mm hu jx b jy mu kb mv ke mw ki mx km my kq mq mr ms mt dt translated">加强应用程序中pinset信息的安全性。</li></ul><p id="eadd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">通过简化React本地应用的证书锁定，<a class="ae kr" href="https://www.npmjs.com/package/react-native-cert-pinner" rel="noopener ugc nofollow" target="_blank"> react-native-cert-pinner </a>包应该可以帮助更多的开发人员使用这些技术来加强他们的移动API连接的完整性。</p></div><div class="ab cl mz na hc nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hn ho hp hq hr"><p id="a217" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">要了解更多关于API安全和相关主题的信息，请访问<a class="ae kr" href="https://www.approov.io/" rel="noopener ugc nofollow" target="_blank">approv . io</a>或在twitter上关注<a class="ae kr" href="https://twitter.com/critblue" rel="noopener ugc nofollow" target="_blank"> @critblue </a>。</p></div></div>    
</body>
</html>