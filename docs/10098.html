<html>
<head>
<title>Decluttering a React Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">清理React应用程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/decluttering-a-react-application-d3c5f2d40f22?source=collection_archive---------8-----------------------#2018-12-16">https://medium.com/hackernoon/decluttering-a-react-application-d3c5f2d40f22?source=collection_archive---------8-----------------------#2018-12-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="346b" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">清理和组织代码的步骤</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/7702a868d346fdeaed612a72b9366f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uawRCmmNm1A2l9PknfwixQ.jpeg"/></div></div></figure><p id="a4f9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">几年前，我们开始开发React应用程序。我们从Flux开始，但是当Redux可用时，我们转向了Redux。随着时间的推移，需求不断发展，应用程序不断增长。我们也转向了新的表单、模态和图表框架，仅举几例。事实上，我们代码的很大一部分现在使用了GraphQL，所以Redux的状态管理减少了。我们边走边学，新特性的实现通常优先于清理工作代码。</p><p id="46d7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">因此，清理应用程序的时机已经成熟。在本练习开始时，应用程序有500多个组件和数百个减少器和动作。所以，这不是一个玩具应用程序。</p><p id="d15c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们使用<a class="ae kr" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>所以单个文件相对干净。但是如果一个模块没有被使用或者一个导出的函数从来没有被调用过，ESLint就没有用了。<strong class="jx hv">挑战在于删除不用的代码，重组现有的代码，使代码更小、更容易理解、更易维护。</strong></p><p id="d19e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先，我们使用实用程序<a class="ae kr" href="https://www.npmjs.com/package/lxjs" rel="noopener ugc nofollow" target="_blank"> lxjs </a>和商业工具<a class="ae kr" href="https://lattix.com/lattix-architect" rel="noopener ugc nofollow" target="_blank"> Lattix Architect </a>来创建我们的应用程序的依赖关系图。对于任何文件，它允许我们看到它导入了什么以及谁导入了它。跟踪依赖链也很容易。底层数据来自<a class="ae kr" href="https://github.com/pahen/madge" rel="noopener ugc nofollow" target="_blank"> madge </a>可以免费下载。</p><p id="2c9a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">有了这些数据，我们开始重构应用程序。</p><h2 id="3f46" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">删除未使用的文件</h2><p id="1db8" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">我们很快识别出不再使用的文件。当然，仅仅删除未使用的文件是不够的，我们还必须跟踪只被这些文件使用的代码。</p><h2 id="c451" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">组织组件</h2><p id="2c96" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">组件是我们客户代码中最大的部分。大约70%的客户代码是组件。这是大部分工作投入的地方。我们最终将组件分成两部分:<em class="ls">视图</em>和<em class="ls">组件</em>。视图是顶层组件，通常对应于页面，而底层组件是视图使用的共享组件。特定于一个视图的组件通常保存在该视图中，但是我们并不拘泥于此。当视图之间没有交叉依赖，并且从组件到视图之间没有向后依赖时，我们知道我们有相当干净的分离。</p><h2 id="2f12" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">清理动作和减速器</h2><p id="2b79" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">随着我们的应用程序的发展，许多动作不再被使用。由于动作由组件和缩减器使用，所以寻找未使用的动作并不简单。我们必须识别所有没有被任何组件使用的动作。这有助于我们为我们的行为和reducers制定强有力的命名约定。一旦删除了未使用的动作，就很容易识别和删除引用这些未使用动作的所有减速器。</p><h2 id="fda7" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">拆除不必要的联轴器</h2><p id="1f54" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">选择器是不必要耦合的来源。虽然我们的大多数选择器位于减速器中，但也有一些位于组件中。我们只是把选择器和减速器放在一起。这也有助于将状态封装在reducers中，并对组件隐藏细节。有时选择器会使用其他选择器。这在异径管之间产生了耦合。我们将选择器与减速器放在一起，以避免在减速器之间产生循环耦合。</p><p id="db05" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">临时助手是不想要的耦合的另一个来源。</strong>有些帮助器最初是为了支持一个组件而创建的，然后被其他组件使用。例如，任何处理时间/日期选择的组件都必须处理时区调整。最初，这些帮助函数中有许多是时区选择组件的一部分。这些函数被移到一个单独的helpers目录中，供所有组件使用。</p><h2 id="3418" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">清理样式</h2><p id="555c" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">我们有超过50个css文件。大多数位于一个单独的<em class="ls">样式</em>目录中，但是有些与组件放在一起。我们很容易地去掉了不用的css文件。我们并没有试图合理化不同组件使用的风格多样性，因为这并不是一个问题。</p><h1 id="be15" class="lt kt hu bd ku lu lv lw ky lx ly lz lc ja ma jb lf jd mb je li jg mc jh ll md dt translated">经验教训</h1><p id="827c" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">这比看起来容易。这是一个惊喜。清理被认为是艰难和费力不讨好的，不会增加利润。然而，每当你做出改变时，技术债务就会增加一点。最初的估计是，这项工作可能需要几个月时间。事实上，这项工作的大部分是在两周内完成的。</p><p id="b2b5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">了解你的代码组织。</strong>这项工作的一个有价值的副产品是，它调整了当前的团队。您通常可以通过特性或类型来组织代码<a class="ae kr" href="https://softwareengineering.stackexchange.com/questions/338597/folder-by-type-or-folder-by-feature" rel="noopener ugc nofollow" target="_blank">。我们在不同的层次上结合使用了这两种方法。然而，我们总是通过依赖来协调这两种方法，以确保我们不会引入</a><a class="ae kr" href="https://en.wikipedia.org/wiki/Acyclic_dependencies_principle" rel="noopener ugc nofollow" target="_blank">循环依赖</a>。</p><p id="6f29" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">减少捆绑包的大小并不是目标。</strong>这不是一个减少包大小的练习，尽管它确实帮助我们去掉了一些库。<em class="ls">图书馆的多样性本身就是一种混乱。</em>例如，我们的应用程序同时使用了Redux-form和Formik。去掉其中的一个将有助于减少包的大小和库的混乱，但是我们把它放在了这个工作的范围之外。</p><h1 id="f4d7" class="lt kt hu bd ku lu lv lw ky lx ly lz lc ja ma jb lf jd mb je li jg mc jh ll md dt translated">为什么我们会堆积杂物</h1><p id="d498" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">通常代码开始时组织得很好，但随着时间的推移会逐渐削弱。归咎于期限和业务需求很容易，但它们并不能完全解释这一普遍现象。其他原因包括:</p><p id="7c7f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">编程文化不强调清理。</strong>我们通过使用正确的技术组合来解决业务问题。我们写测试。然后我们转移到sprint的下一个问题。在我们的开发过程中，清理是不被衡量或重视的。</p><p id="99cb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">对于现在的程序员来说，并不是优先考虑的事情。随着新人的加入或新功能的加入，问题就出现了。对于当前的程序员来说，只有当应用程序增长并且他们不再理解其他人开发的部分代码库时，问题才变得明显。</strong></p><p id="0201" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">程序员尽量减少对他们没有编写的代码的修改。即使对于专业程序员来说也是如此。将帮助函数从一个文件移动到另一个文件需要更改不熟悉的文件。删除一段代码需要理解为什么在第一种情况下创建它，并确保它确实没有被使用。所有这些都分散了人们对手头任务的注意力，妨碍了完成冲刺。</strong></p><p id="01bc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">没有代码的组织原则，没有持续清理的文化，代码腐烂是不可避免的。</p><h1 id="c536" class="lt kt hu bd ku lu lv lw ky lx ly lz lc ja ma jb lf jd mb je li jg mc jh ll md dt translated">我们取得的成就</h1><p id="b53f" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">在这个练习的最后，我们最终减少了大约25%的代码。行动减少了一半，减少了40%。零部件数量也下降了约10%。</p><p id="cf62" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">多年积累的杂物不见了。</p></div></div>    
</body>
</html>