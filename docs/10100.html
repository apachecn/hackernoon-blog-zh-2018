<html>
<head>
<title>Babel: Your first code transformations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">巴别塔:你的第一次代码转换</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/babel-your-first-code-transformations-2d1a9a2f3bc4?source=collection_archive---------10-----------------------#2018-12-16">https://medium.com/hackernoon/babel-your-first-code-transformations-2d1a9a2f3bc4?source=collection_archive---------10-----------------------#2018-12-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/bb2ac45202a2c971a9ab983e8176fe09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yl42Tqet103wA6seNUBLXA.jpeg"/></div></div></figure><p id="fa64" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本教程中，我们将使用Babel对一些源代码进行一些基本的转换。许多人觉得转换代码的想法很可怕，难以接近，但是利用AST(抽象语法树)的力量和Babel提供给我们的一套工具，大部分繁重的工作已经为我们完成了。</p><p id="f326" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注意</strong>:文章中的例子将包括特定于<code class="eh ka kb kc kd b">react</code>、<code class="eh ka kb kc kd b">redux</code>和<code class="eh ka kb kc kd b">react-redux</code>的代码，但是熟悉这些库对于本教程来说并不是必需的。</p><h1 id="da13" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">AST浏览器</h1><p id="2518" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">有一个名为<a class="ae lh" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank"> AST explorer </a>的网站，我们可以将代码粘贴到其中，并获得多种格式的AST表示。这个网站将有助于快速查看AST格式的代码，并且有助于确定我们需要定位哪些节点。</p><h1 id="5144" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated"><strong class="ak">基本插入</strong></h1><p id="6069" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">下面，我们有一个文件<code class="eh ka kb kc kd b">reducers.js</code>，其中有几个导入和一个默认的导出。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="0302" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于我们的第一个转换，让我们为<code class="eh ka kb kc kd b">reducers.js</code>添加一个新的导入和导出。我们再加<code class="eh ka kb kc kd b">mice</code>。为此，我们需要:</p><ol class=""><li id="0eba" class="lo lp hu je b jf jg jj jk jn lq jr lr jv ls jz lt lu lv lw dt translated">将代码解析为AST格式。</li><li id="64a0" class="lo lp hu je b jf lx jj ly jn lz jr ma jv mb jz lt lu lv lw dt translated">遍历AST，找到与我们要添加的节点相邻的节点。</li><li id="b783" class="lo lp hu je b jf lx jj ly jn lz jr ma jv mb jz lt lu lv lw dt translated">插入新节点。</li><li id="1cf1" class="lo lp hu je b jf lx jj ly jn lz jr ma jv mb jz lt lu lv lw dt translated">从我们的AST生成新代码。</li></ol><p id="2290" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是我们实现这一目标的方法:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="fdfe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们来分析一下。首先，我们在代码上调用解析器，解析器将代码从字符串转换成AST。</p><pre class="li lj lk ll fq mc kd md me aw mf dt"><span id="266b" class="mg kf hu kd b fv mh mi l mj mk">const ast = parser(file, {sourceType: 'module'});</span></pre><blockquote class="ml mm mn"><p id="6cd4" class="jc jd mo je b jf jg jh ji jj jk jl jm mp jo jp jq mq js jt ju mr jw jx jy jz hn dt translated">注意，由于我们使用的是ES6模块，我们需要用<code class="eh ka kb kc kd b">{sourceType: ‘module’}</code>让解析器知道。</p></blockquote><p id="d017" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们使用<code class="eh ka kb kc kd b">traverse</code>找到我们的相关节点。我们怎么知道我们需要<code class="eh ka kb kc kd b">ExportDefaultDeclaration</code>和<code class="eh ka kb kc kd b">ObjectExpression</code>？这就是AST探险家派上用场的地方。下面，我们将代码粘贴在左边的面板上，在右边，我们可以看到代码的AST表示。</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ms"><img src="../Images/bb0164cb85315c342e5bd09089405fd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_AezFA7uiuYiJwyw-SKtw.png"/></div></div></figure><p id="d450" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们有2个<code class="eh ka kb kc kd b">ImportDeclaration</code>，所以<code class="eh ka kb kc kd b">traverse</code>将帮助我们迭代它们，并将最后一个保存到一个名为<code class="eh ka kb kc kd b">lastImport</code>的变量中。然后我们使用<code class="eh ka kb kc kd b">insertAfter</code>在最后一个导入之后插入新的导入。</p><pre class="li lj lk ll fq mc kd md me aw mf dt"><span id="97aa" class="mg kf hu kd b fv mh mi l mj mk">// this file is made up of snippets from transform.js</span><span id="b181" class="mg kf hu kd b fv mt mi l mj mk">let lastImport;</span><span id="a314" class="mg kf hu kd b fv mt mi l mj mk">traverse(ast, {<br/>  ImportDeclaration(path) {<br/>  lastImport = path;<br/>}</span><span id="ce6b" class="mg kf hu kd b fv mt mi l mj mk">const importCode = `import ${reducerName} from './${reducerName}'`;<br/>lastImport.insertAfter(parser(importCode, {sourceType: 'module'}));</span></pre><p id="cafe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了给默认导出的对象添加一个属性，我们将使用<code class="eh ka kb kc kd b">traverse</code>来迭代<code class="eh ka kb kc kd b">ObjectExpression</code>的。我们只期望有一个，所以我们将使用<code class="eh ka kb kc kd b">properties = path.parent.declaration.properties</code>来保存它的属性。然后，我们可以将新的<code class="eh ka kb kc kd b">mice</code>标识符推入<code class="eh ka kb kc kd b">properties</code>数组。</p><pre class="li lj lk ll fq mc kd md me aw mf dt"><span id="8079" class="mg kf hu kd b fv mh mi l mj mk">// this file is made up of snippets from transform.js</span><span id="4107" class="mg kf hu kd b fv mt mi l mj mk">traverse(ast, {<br/>  ObjectExpression(path) {<br/>    properties = path.parent.declaration.properties<br/>  }<br/>})</span><span id="05d5" class="mg kf hu kd b fv mt mi l mj mk">const id = t.identifier(REDUCER_NAME)<br/>properties.push(t.objectProperty(id, id, false, true))</span></pre><blockquote class="ml mm mn"><p id="33ca" class="jc jd mo je b jf jg jh ji jj jk jl jm mp jo jp jq mq js jt ju mr jw jx jy jz hn dt translated">你可能想知道<code class="eh ka kb kc kd b">t.objectProperty(id, id, false, true)</code>是什么？好问题。由于<code class="eh ka kb kc kd b">mice</code>本身没有足够的上下文，我们不能像上一个例子那样在一串代码上调用<code class="eh ka kb kc kd b">parser</code>。Babel会将其解析为<code class="eh ka kb kc kd b">Identifier</code>而不是<code class="eh ka kb kc kd b">Property</code>，导致重新生成代码时出现问题。为了解决这个问题，我们使用<code class="eh ka kb kc kd b">@babel/types</code>包来帮助解析器理解我们添加到AST中的内容。</p></blockquote><p id="2da9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们已经更新了我们的AST，我们可以在它上面调用<code class="eh ka kb kc kd b">generate</code>。这将把代码从AST转换回字符串格式。我们在字符串上运行得更好，最终得到如下代码:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><h1 id="c010" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">在函数中包装变量</h1><p id="99fc" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">接下来，我们将学习如何使用<code class="eh ka kb kc kd b">replaceWith</code>在高阶组件中包装标识符。</p><p id="5b99" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本质上，我们想从:</p><pre class="li lj lk ll fq mc kd md me aw mf dt"><span id="0fb8" class="mg kf hu kd b fv mh mi l mj mk">export default Sports;</span></pre><p id="ef0b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">收件人:</p><pre class="li lj lk ll fq mc kd md me aw mf dt"><span id="b6f6" class="mg kf hu kd b fv mh mi l mj mk">const mapStateToProps = ({ volleyball, soccer }) =&gt; ({<br/>  volleyball,<br/>  soccer<br/>});</span><span id="cee3" class="mg kf hu kd b fv mt mi l mj mk">export default connect(mapStateToProps)(Sports);</span></pre><p id="b0c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这包括两个步骤。</p><ol class=""><li id="ca21" class="lo lp hu je b jf jg jj jk jn lq jr lr jv ls jz lt lu lv lw dt translated">获取默认导出的名称(标识符)。</li><li id="4f30" class="lo lp hu je b jf lx jj ly jn lz jr ma jv mb jz lt lu lv lw dt translated">用其自身的包装版本和<code class="eh ka kb kc kd b">mapStateToProps</code>函数替换它。</li></ol><p id="2ebe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是我们将要操作的文件:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="8302" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是转换它的代码:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="baef" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先要注意的是，由于我们这次解析JSX，我们需要让解析器知道:</p><pre class="li lj lk ll fq mc kd md me aw mf dt"><span id="020d" class="mg kf hu kd b fv mh mi l mj mk">const ast = parser(file, {sourceType: 'module', plugins: ['jsx']});</span></pre><p id="c3b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这次我们使用<code class="eh ka kb kc kd b">traverse</code>来迭代AST并找到<code class="eh ka kb kc kd b">ExportDefaultDeclaration</code>。一旦我们找到它，我们就存储被导出的变量的名字。</p><pre class="li lj lk ll fq mc kd md me aw mf dt"><span id="49a6" class="mg kf hu kd b fv mh mi l mj mk">const declarationName = exportDefaultPath.node.declaration.name;</span></pre><p id="5a2f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于我们知道导出变量的名称，现在我们可以用新代码替换整个默认导出:</p><pre class="li lj lk ll fq mc kd md me aw mf dt"><span id="9f3e" class="mg kf hu kd b fv mh mi l mj mk">exportDefaultPath.replaceWith(<br/>  // new code...<br/>)</span></pre><p id="734c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">转换完AST后，我们可以在上面运行<code class="eh ka kb kc kd b">generate</code>和<code class="eh ka kb kc kd b">prettier</code>，并将文件写入磁盘。我们最终会得到:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><h1 id="b557" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">总结</h1><p id="ec25" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">学习如何操作AST将为您打开许多新的可能性。使用AST，您可以编写:</p><ul class=""><li id="6bac" class="lo lp hu je b jf jg jj jk jn lq jr lr jv ls jz mu lu lv lw dt translated">林挺插件</li><li id="e275" class="lo lp hu je b jf lx jj ly jn lz jr ma jv mb jz mu lu lv lw dt translated">巴别塔插件</li><li id="5f89" class="lo lp hu je b jf lx jj ly jn lz jr ma jv mb jz mu lu lv lw dt translated">代码模块</li></ul><p id="8e5b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望这篇教程能帮助你探索AST的世界！</p></div></div>    
</body>
</html>