<html>
<head>
<title>How to test Microservices with Consumer-Driven Contracts?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何测试消费者驱动契约的微服务？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-test-microservices-with-consumer-driven-contracts-9bf5c2c05349?source=collection_archive---------1-----------------------#2018-12-17">https://medium.com/hackernoon/how-to-test-microservices-with-consumer-driven-contracts-9bf5c2c05349?source=collection_archive---------1-----------------------#2018-12-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/294141cc4337a6b8ffeb9ebb65e5b750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-z4KqFcIUey4l6dqcXCaQ.jpeg"/></div></div></figure><p id="8ba9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">许多软件公司决定以分布式方式构建他们的应用程序。这种方法提供了高可用性，并且从长远来看提高了开发速度。设计分布式系统最常见的架构模式是微服务。微服务架构是将应用程序分割成小的独立服务，每个服务在整个系统中扮演一个独立的角色。</p><p id="9b59" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设你的客户想要建立一个工作公告。该产品必须允许用户放置工作机会，并向他们收取少量的上市费。它还必须发送几种电子邮件通知。实际上，它不是一个单一的应用程序，而是一个网页，以及iPhone和Android应用程序。需要做的第一件事是决定我们将选择什么架构。</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><h1 id="4ff8" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">单片架构的优势</h1><p id="775c" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">一个单一的方法在项目开始时给了一个推动力。不需要定义复杂的集成测试和部署过程。一切都被简化为单一的服务。</p><p id="f72e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">优点:</strong></p><ul class=""><li id="0633" class="lk ll hu je b jf jg jj jk jn lm jr ln jv lo jz lp lq lr ls dt translated">单一代码库——易于开发(至少在开始阶段)。</li><li id="2a30" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">不需要验证与其他服务的集成，因为它们不存在。</li><li id="62c2" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">相对简单的部署流程—只需要部署一项服务。</li></ul><p id="f67f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">缺点:</strong></p><ul class=""><li id="2a0f" class="lk ll hu je b jf jg jj jk jn lm jr ln jv lo jz lp lq lr ls dt translated">单点故障—如果一个应用程序宕机，整个服务都会宕机。</li><li id="6717" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">维护的复杂性随着时间的推移而增加。</li><li id="2a1c" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">难以适应新技术和工艺。通常需要从头开始重写应用程序。</li></ul></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><h1 id="c57a" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">微服务的优势</h1><p id="4476" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">微服务比整体架构(单个应用程序负责整个系统)有很多优势。最重要的是:</p><ul class=""><li id="7a3d" class="lk ll hu je b jf jg jj jk jn lm jr ln jv lo jz lp lq lr ls dt translated">没有单点故障。当一个服务关闭时，用户仍然可以使用应用程序。其他服务仍在运行。</li><li id="2ed2" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">单个微服务可以纵向扩展，以提高其容量和可用性。</li><li id="9427" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">安全性——大多数服务不会暴露在互联网上。</li><li id="a5ef" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">每个服务都可以独立于其他服务进行部署。只要他们不违反API合同。</li></ul><p id="83e1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">缺点:</strong></p><ul class=""><li id="aaef" class="lk ll hu je b jf jg jj jk jn lm jr ln jv lo jz lp lq lr ls dt translated">需要投入大量的工作来建立基础。</li><li id="56d5" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">部署过程更加复杂。一些部署可能需要部署多个服务。</li><li id="fe59" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">DevOps上的大量工作。尤其是部署…</li><li id="41bf" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">处理集成测试。</li></ul><p id="cb36" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">大多数大型应用程序都是由数百名开发人员开发的。这就是为什么将一个应用程序拆分成更小的服务会使工作更容易、更快。微服务架构对于大中型应用来说是一个很好的选择，尽管最成功的初创公司都是从单片架构开始应用，后来才迁移到微服务。</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><h1 id="a1e4" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">为工作发布应用程序设计微服务</h1><p id="37e8" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">让我们为工作公告考虑下面的架构。网站和移动应用程序通过应用编程接口网关与服务通信。应用编程接口网关是从互联网访问服务的唯一途径。这些服务在内部网络中相互通信。</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ly"><img src="../Images/cb59ef2f00e3a133c6842ac924c5ebee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELi1YaKNm6joSQkHfbGblw.png"/></div></div></figure><p id="bc94" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想象一下，一个用户创建了一个新帐户。他们进入网站，填写表单，并将请求发送给API Gateway。API网关将此请求传递给创建新帐户的用户服务。创建帐户后，用户服务向电子邮件服务发送请求，以发送激活电子邮件。然后，会发送一封带有链接的电子邮件，用户需要单击该链接才能激活其帐户。</p><p id="2e5a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如您所注意到的，电子邮件服务不能通过API Gateway使用。这是因为只有内部服务才能触发电子邮件通知。</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><h1 id="608d" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">如何处理测试？</h1><p id="acd1" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">微服务总是会遇到测试问题—如何确认所有服务都在一起工作？处理整体应用程序的测试是直截了当的。该应用程序只有一个代码库，不依赖任何外部服务。相比之下，微服务使所有服务分布式。他们依赖来自其他人的信息，这意味着系统架构师必须找到方法来验证服务使用相同的语言。通常，他们决定构建一个集成环境，在这个环境中服务被分解，测试人员运行测试。不幸的是，这种方法效率低下且成本高昂。在我们的例子中，我们需要并行运行六个服务。请记住，其中一些服务需要运行数据库或其他系统。</p><p id="8f04" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽管提升整个应用程序堆栈需要大量硬件，但想想测试地狱吧。假设预算对您的客户来说不是问题。您有必要的硬件和一些开发人员来构建和维护集成环境。运行所有测试需要花费大量时间…</p><p id="1d97" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">…有时几个小时，说真的…</p><p id="be0b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的一些服务看起来运行cron和批处理作业。您可以想象，预测执行它们所需的时间几乎是不可能的，这意味着依赖于这些工作的测试可能是不可靠的。</p><p id="02cd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当您的测试依赖于cron作业处理的数据，并且它会在cron作业完成之前尝试确认测试时，会发生什么？您的测试失败，需要重新运行测试…</p><p id="9a1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">…经过几次尝试后，您将获得绿色版本。您在这上面浪费了3个小时，但是现在您可以合并您的更改，并提供一个功能…</p><p id="b4ff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">耶！生活是美好的！</p><p id="73f7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">…不幸的是，两分钟前有人合并了一些东西，所以您需要合并这些更改，并再次运行所有测试…</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff md"><img src="../Images/5351184f2d8619c0f2ecd75c24fb6d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*itpAdE6O7ldkLqBqvW2ZTA.jpeg"/></div></div></figure></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><h1 id="d8e3" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">消费者驱动的合同</h1><p id="c50d" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">与其在所有服务之间运行集成测试，不如将它们去掉。所有服务都通过RESTful APIs进行通信。这意味着，如果我们在API之间定义了一个紧密的“契约”,我们就不需要提升整个平台。它足以验证其他服务的需求满足情况。</p><blockquote class="me mf mg"><p id="ce28" class="jc jd mh je b jf jg jh ji jj jk jl jm mi jo jp jq mj js jt ju mk jw jx jy jz hn dt translated">示例代码可以在Github 上找到<a class="ae ml" href="https://github.com/mateuszsokola/contract-tests-example" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><h2 id="f5ff" class="mm ki hu bd kj mn mo mp kn mq mr ms kr jn mt mu kv jr mv mw kz jv mx my ld mz dt translated">它是如何工作的？</h2><p id="2539" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">有两个对等点—消费者(客户端)和提供者(服务)。作为开发人员，我们希望确认它们是相互兼容的；这就是我们在消费者端定义API契约的原因。合同必须由服务提供商强制执行。</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ly"><img src="../Images/6eb92d43cea49f78d2b37579fcd81e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BTBUnzy5hQqKfsAsGmpMBw.png"/></div></div></figure><h2 id="32d1" class="mm ki hu bd kj mn mo mp kn mq mr ms kr jn mt mu kv jr mv mw kz jv mx my ld mz dt translated"><strong class="ak">使用什么工具？</strong></h2><p id="2672" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">在这篇文章中，我使用了<a class="ae ml" href="https://docs.pact.io/" rel="noopener ugc nofollow" target="_blank">协议</a>。我还没有找到其他可以和Pact竞争的产品。Pact支持<a class="ae ml" href="https://docs.pact.io/implementation_guides" rel="noopener ugc nofollow" target="_blank">多种语言</a>，被<a class="ae ml" href="https://www.atlassian.com/" rel="noopener ugc nofollow" target="_blank"> Atlassian </a>等知名公司使用。</p><p id="a397" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可能也想考虑一下Dredd。</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ly"><img src="../Images/aba5d0be486a1f3851f20f3a7990df36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R6dB9Suc3OBe3HVMrtWOSg.png"/></div></div></figure><h2 id="8185" class="mm ki hu bd kj mn mo mp kn mq mr ms kr jn mt mu kv jr mv mw kz jv mx my ld mz dt translated">什么是消费者？</h2><p id="4dcf" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">消费者是希望从其他服务(例如，web前端或消息接收端点)接收一些数据的客户端。它们定义了对端点的要求，比如HTTP头、状态代码、有效负载和响应。契约是在单元测试运行时生成的。所有测试成功后，pact创建包含HTTP请求信息的json文件。这是合同示例:</p><figure class="lz ma mb mc fq iv"><div class="bz el l di"><div class="na nb l"/></div></figure><h2 id="a1f7" class="mm ki hu bd kj mn mo mp kn mq mr ms kr jn mt mu kv jr mv mw kz jv mx my ld mz dt translated">什么是提供商？</h2><p id="169f" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">提供者是提供数据的服务或服务器(例如，提供客户端所需数据的服务器上的API，或者发送消息的服务)。向提供者验证合同的工具称为<a class="ae ml" href="https://github.com/pact-foundation/pact-provider-verifier" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">契约提供者验证者</strong> </a>。验证器根据消费者创建的合同运行HTTP请求。如果服务器响应是消费者所期望的形式，测试就通过了。</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nc"><img src="../Images/71d0b047ff6668e10159f3182c4a6a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XvXg5q1rp7pZFUEZfLqdeA.png"/></div></div></figure><p id="6533" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果提供商没有达到预期，他们就会失败…</p><figure class="lz ma mb mc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nc"><img src="../Images/7ef21ce868d3486094f3fb767d0f29b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xau1666ATY1Udc_-5PiZEA.png"/></div></div></figure></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><h2 id="649d" class="mm ki hu bd kj mn mo mp kn mq mr ms kr jn mt mu kv jr mv mw kz jv mx my ld mz dt translated">稍等一下……那么，如何向所有同行交付合同呢？</h2><p id="b4bf" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">在消费者端的所有测试成功之后，包含契约的json文件就创建好了。我们的工作是将它们交付给提供商以验证合同。有几种方法可以做到这一点:</p><ul class=""><li id="b24c" class="lk ll hu je b jf jg jj jk jn lm jr ln jv lo jz lp lq lr ls dt translated">一个<strong class="je hv"> Git存储库</strong>，用于存储契约，并通过Git子模块将它们包含到每个项目中。在我看来，最好的方法是，</li><li id="2d96" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">文件系统。</li><li id="74aa" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated">契约经纪人。</li></ul><p id="0c88" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Pact Broker是一个应用程序，用于共享消费者驱动的合同和验证结果。我们可以把我们的合同推到那里，允许服务提供商下载它们，并对它们进行测试。</p><p id="c959" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">DiUS提供了Pact Broker的云版本，也许你可以看看并使用它。我看不出经营自己的契约经纪人有什么好处。最终，这又是一项需要DevOps维护的服务。如果你想自己跑<a class="ae ml" href="https://hub.docker.com/r/dius/pact-broker/" rel="noopener ugc nofollow" target="_blank">这里是Docker图片</a>。</p><p id="d72c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我认为将合同存储在单独的git存储库中已经足够好了。就我个人而言，我会在集成管道中创建它们，并在同一个集成工作中对服务提供者运行测试——这里是的<a class="ae ml" href="https://travis-ci.org/mateuszsokola/contract-tests-example/builds/354853499?utm_source=github_status&amp;utm_medium=notification" rel="noopener ugc nofollow" target="_blank">示例集成管道。</a></p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><h1 id="2b36" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">为什么不招摇？</h1><p id="2e9a" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">Swagger是用于记录API的定义格式。它通过映射所有的资源和相关的操作来创建开发和使用API的接口。输出可以被人(通过网站)和机器(通过yaml和json文件)理解。不幸的是，Swagger并不是用来测试的。Swagger生成的模拟服务器不验证请求负载，验证由前端处理。</p><p id="54f4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">并不是说你完全不应该用Swagger，你可以，强烈推荐。如果您使用微服务，很可能它们是由许多团队开发的，并被其他团队(有时是外部团队)使用。将文档链接到API可以加快开发速度，因为开发人员不需要知道如何使用端点。他们可以在文档页面上阅读并试用。</p><p id="55da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可能想阅读更多关于<a class="ae ml" href="https://bitbucket.org/atlassian/swagger-mock-validator" rel="noopener ugc nofollow" target="_blank"> Swagger模拟验证器</a>的内容；一个允许你根据Swagger文件验证合同的工具。</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><h1 id="214d" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">摘要</h1><p id="7cba" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">测试微服务是一个复杂的问题。没有什么灵丹妙药，也没有一套在任何情况下都能轻松使用的规则。我写这篇文章是为了向你展示我所在的团队是如何决定处理这个问题的。</p><p id="a4be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你对消费者驱动的合同感兴趣，我强烈推荐观看来自Atlassian的Mauri Edo和Ben Sayers的演讲。</p><figure class="lz ma mb mc fq iv"><div class="bz el l di"><div class="nd nb l"/></div></figure><p id="a3b9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我决定在我的Github  上保留<a class="ae ml" href="https://github.com/mateuszsokola/contract-tests-example" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">所有代码，这样文章更容易阅读。</strong></a></p><p id="37a2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">如果你有任何问题或建议，请写下评论。</strong></p><p id="9739" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以通过<a class="ae ml" rel="noopener" href="/@mateuszsokola">媒体</a>和<a class="ae ml" href="https://twitter.com/msokola" rel="noopener ugc nofollow" target="_blank">推特</a>联系我。</p></div></div>    
</body>
</html>