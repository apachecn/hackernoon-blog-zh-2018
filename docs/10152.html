<html>
<head>
<title>NetworkDeciding on what to do with a packet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网络决定如何处理数据包</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/deciding-on-what-to-do-with-a-packet-d8c47412c61b?source=collection_archive---------31-----------------------#2018-12-17">https://medium.com/hackernoon/deciding-on-what-to-do-with-a-packet-d8c47412c61b?source=collection_archive---------31-----------------------#2018-12-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="5086" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当一台设备要向另一台设备发送数据包时，有两种选择:</p><ol class=""><li id="85fb" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">如果接收者在同一个子网上，它可以直接发送<a class="ae jy" href="https://hackernoon.com/tagged/packet" rel="noopener ugc nofollow" target="_blank">包</a>给他们，它只需要确定接收者的MAC地址。</li><li id="ee73" class="jp jq hu it b iu jz iy ka jc kb jg kc jk kd jo ju jv jw jx dt translated">如果接收方在另一个子网上，它会将数据包传递到一个设备上，该设备可以将数据包转发到目的地。</li></ol><h1 id="3909" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">选项1</h1><p id="3f74" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">发送设备需要测试的第一件事是，接收设备和我在同一个子网吗？</p><p id="b430" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，它使用配置接口时定义的IP地址和网络掩码来确定与其位于同一子网的地址范围。</p><p id="f7a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="d24a" class="lq kf hu lm b fv lr ls l lt lu">eth0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500<br/>        <strong class="lm hv">inet 10.0.0.7  netmask 255.255.255.0</strong>  broadcast 10.0.0.255<br/>        ether b8:27:eb:28:f5:e0  txqueuelen 1000  (Ethernet)</span></pre><p id="6108" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用各种工具之一，我们可以计算出这意味着，10 . 0 . 0 . 1–10 . 0 . 0 . 254范围内的任何IP都与我们在同一个子网中</p><figure class="lh li lj lk fq lw fe ff paragraph-image"><div class="fe ff lv"><img src="../Images/edc78cc23b656b0c4a9227cb1cd9d26c.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*IH8VKF3pOImK2rn0HvB0_A.png"/></div></figure><p id="21a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们知道一个收件人和我们在同一个子网，那么我们需要找出它的MAC地址，这是使用ARP请求来完成的。</p><p id="f5f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">地址解析协议(ARP)是一种将IP地址映射到MAC地址的协议。</p><p id="cdd5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">设备可以发出一个ARP请求，询问“谁有IP地址X？”，它被发送到广播地址，这意味着它被传送到子网上的每个设备。</p><p id="67a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有收件人都会检查邮件并丢弃邮件，除非他们拥有所述的IP地址。IP地址的所有者回复说“IP地址X在MAC地址Y”。</p><p id="89f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个响应通常会被缓存，这样下次发送者就不需要再次执行查找。</p><p id="aea5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以使用<code class="eh lz ma mb lm b">ping</code>生成一些数据包，看看WireShark会发生什么</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="70e8" class="lq kf hu lm b fv lr ls l lt lu">pi@raspberrypi:~$ ping 10.0.0.4<br/>PING 10.0.0.4 (10.0.0.4) 56(84) bytes of data.<br/>64 bytes from 10.0.0.4: icmp_seq=1 ttl=64 time=1.96 ms<br/>64 bytes from 10.0.0.4: icmp_seq=2 ttl=64 time=0.932 ms</span></pre><p id="ef06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lz ma mb lm b">10.0.0.4</code>与<code class="eh lz ma mb lm b">10.0.0.7/24</code>在同一个子网中，因此第一步是发出一个ARP请求来查找<code class="eh lz ma mb lm b">10.0.0.7</code>的MAC地址</p><figure class="lh li lj lk fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mc"><img src="../Images/7c0a5f50f5f8601cacf242314a9ae154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6x5UBgBxUzPIRj0v4U9ilA.png"/></div></div></figure><p id="61e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lz ma mb lm b">10.0.0.4</code>看到ARP请求是给自己的，响应表示对应的MAC地址是自己的。</p><figure class="lh li lj lk fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mh"><img src="../Images/621598269202a801436a3230aa2309ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jZIjv715hrR_ahTSgEPKTw.png"/></div></div></figure><p id="0a9e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，发送方知道了接收方的MAC地址，就可以将消息打包并发送给接收方。</p><figure class="lh li lj lk fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mi"><img src="../Images/f0e3f941a081300716544058ca55714f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o4gFE80sv13bWnHgu2VzIA.png"/></div></div></figure><h1 id="ca94" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">选项2</h1><p id="46ca" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">如果发送方确定接收方不在同一个子网上，它需要将消息传递给能够将消息发送到目的地的其他人。</p><p id="f785" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">路由表根据数据包的目的地提供数据包发送目的地的信息。</p><p id="7c9f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更具体的路由优于更一般的路由，通常有一个默认路由用于不匹配任何规则的数据包。</p><p id="d77a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Linux上的<code class="eh lz ma mb lm b">ip route </code>命令显示系统路由表</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="2679" class="lq kf hu lm b fv lr ls l lt lu">router:~ $ ip route<br/>default via 192.168.1.1 dev wlan0<br/>10.0.0.0/24 via 10.0.0.8 dev eth2 <br/>10.0.0.4 <br/> nexthop dev eth0 weight 1 <br/> nexthop dev eth1 weight 1 <br/>192.168.1.0/24 dev wlan0 proto kernel scope link src 192.168.1.85</span></pre><p id="c64b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这表明:</p><ul class=""><li id="28fd" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo mj jv jw jx dt translated">任何目的地为<code class="eh lz ma mb lm b">192.168.1.0/24</code>子网的数据包都会从直接连接到该子网的<code class="eh lz ma mb lm b">wlan0</code>接口发出(没有通过关键字的<strong class="it hv">),因此设备会查找目的地MAC地址，并将数据包直接传递到匹配的设备。</strong></li><li id="6252" class="jp jq hu it b iu jz iy ka jc kb jg kc jk kd jo mj jv jw jx dt translated">任何去往<code class="eh lz ma mb lm b">10.0.0.4</code>的数据包都会从直接连接到设备的<code class="eh lz ma mb lm b">eth0</code>或<code class="eh lz ma mb lm b">eth1</code>接口发出。所选择的路由取决于Linux内核版本以及它如何实现等价多路径(ECMP)路由。</li><li id="bdd3" class="jp jq hu it b iu jz iy ka jc kb jg kc jk kd jo mj jv jw jx dt translated">任何目的地为<code class="eh lz ma mb lm b">10.0.0.0/24</code>的数据包，除了目的地为<code class="eh lz ma mb lm b">10.0.0.4</code>的数据包(因为它们有一个更具体的路由，该路由优先于此路由)，都从接口<code class="eh lz ma mb lm b">eth2</code>发送到<code class="eh lz ma mb lm b">10.0.0.8</code>处的设备，接口<code class="eh lz ma mb lm b">eth2</code>可以将它们转发到它们的目的地(通过关键字的<strong class="it hv">表示这是一个中间跳)，因此将从<code class="eh lz ma mb lm b">eth2</code>发出ARP请求，以在<code class="eh lz ma mb lm b">10.0.0.8</code>处查找设备的MAC地址，并且数据包将简单地传递到设备上，以转发到目的地。</strong></li><li id="daa4" class="jp jq hu it b iu jz iy ka jc kb jg kc jk kd jo mj jv jw jx dt translated">最后，如果这些路由都不匹配您的数据包，默认规则会通过<code class="eh lz ma mb lm b">wlan0</code>接口将它们发送到<code class="eh lz ma mb lm b">192.168.1.1</code>，以便转发到目的地。</li></ul><p id="64e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以构建一个更简单的<a class="ae jy" href="https://hackernoon.com/tagged/network" rel="noopener ugc nofollow" target="_blank">网络</a>，我们自己的路由器，并将不同子网上的设备连接到它，以说明这如何与Wireshark一起工作。</p><figure class="lh li lj lk fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mk"><img src="../Images/d4fa9ba018484ac48a7b2ca367f5bc5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HyFITWnkQKQqG2lQxu9DLw.png"/></div></div></figure><p id="3674" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的路由器上(A)</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="2896" class="lq kf hu lm b fv lr ls l lt lu">pi@raspberrypi-router:~ $ sudo ip route<br/>10.0.0.0/24 dev eth2 proto kernel scope link src 10.0.1.2<br/>10.0.2.0/24 dev eth1 scope link</span></pre><p id="9ee1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该路由器连接网络B和C，网络B和C分别具有范围<code class="eh lz ma mb lm b">10.0.0.0/24</code>和<code class="eh lz ma mb lm b">10.0.2.0/24</code>内的设备，这些设备可从<code class="eh lz ma mb lm b">eth2</code>和<code class="eh lz ma mb lm b">eth1</code>到达。为简单起见，我们将集中讨论这些网络上的单个设备(<code class="eh lz ma mb lm b">10.0.0.2</code>和<code class="eh lz ma mb lm b">10.0.2.2</code>)，但是B和C可以是连接多个设备的交换机。</p><p id="d61f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在设备B上(10.0.0.2)</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="8b31" class="lq kf hu lm b fv lr ls l lt lu">pi@raspberrypi:~ $ sudo ip route<br/>10.0.1.0/24 dev eth0 scope link<br/>10.0.2.0/24 via 10.0.1.2 dev eth0</span></pre><p id="ec6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该设备通过<code class="eh lz ma mb lm b">eth0</code>接口直接连接到<code class="eh lz ma mb lm b">10.0.1.0/24</code>网络，并可以通过<code class="eh lz ma mb lm b">10.0.1.2</code>到达<code class="eh lz ma mb lm b">10.0.2.0/24</code>网络</p><p id="7311" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在设备C上(10.0.2.2)</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="e7a8" class="lq kf hu lm b fv lr ls l lt lu">pi@raspberrypi:~ $ sudo ip route<br/>10.0.0.0/24 via 10.0.1.1 dev eth0<br/>10.0.1.0/24 dev eth0 scope link</span></pre><p id="2c65" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该设备通过<code class="eh lz ma mb lm b">eth0</code>接口直接连接到<code class="eh lz ma mb lm b">10.0.1.0/24</code>网络，并可以通过<code class="eh lz ma mb lm b">10.0.1.1</code>到达<code class="eh lz ma mb lm b">10.0.2.0/24</code>网络</p><p id="1631" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在有了Wireshark，我们可以看到它们的运行，让我们从设备B向设备C发送一个请求</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="6b03" class="lq kf hu lm b fv lr ls l lt lu">curl 10.0.2.2:8000/</span></pre><p id="da79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">设备B发现它有一个到<code class="eh lz ma mb lm b">10.0.2.0/24 via 10.0.1.2 dev eth0</code>的路由，所以它首先从<code class="eh lz ma mb lm b">eth0</code>发出一个ARP请求，以找到<code class="eh lz ma mb lm b">10.0.1.2</code>的MAC地址</p><figure class="lh li lj lk fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff ml"><img src="../Images/95d5be981a0077ebaa7ed41ce803fcc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vP7wFW-_IqsuBw9JRJEW2Q.png"/></div></div></figure><p id="3d42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，它尝试建立到目的地<code class="eh lz ma mb lm b">(10.0.2.2)</code>的TCP连接，并通过将其MAC地址作为目的地，将数据包发送到<code class="eh lz ma mb lm b">10.0.1.2</code>处的路由器。</p><figure class="lh li lj lk fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mm"><img src="../Images/2b31cdddfdd43f3118687ad66106cc74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dCbCN9CAkO9xkZ3KEBzQuw.png"/></div></div></figure><p id="e2e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">路由器接收数据包，并查看它是否可以通过路由<code class="eh lz ma mb lm b">10.0.2.0/24 dev eth1</code>到达<code class="eh lz ma mb lm b">10.0.2.2</code></p><p id="3c5b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，它在<code class="eh lz ma mb lm b">eth1</code>上发出一个ARP请求，以找到<code class="eh lz ma mb lm b">10.0.2.2</code>的MAC地址</p><figure class="lh li lj lk fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mn"><img src="../Images/17cc6959d994c3e8d7e1c8fc450b61b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aIhieb5j2qdUJTAHnvXfuQ.png"/></div></div></figure><p id="d3c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它将刚刚学习的MAC地址作为目的地，并将数据包转发到其目的地。</p><figure class="lh li lj lk fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mo"><img src="../Images/3eaa68863aa733986e491971daee32d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3U-Wy-EtzKdKiRP2KUuWkQ.png"/></div></div></figure><p id="6d9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，在设备C处，它接收数据包，并向设备a发回回复。它查询自己的路由表，为<code class="eh lz ma mb lm b">10.0.0.2</code>找到一条路由</p><p id="54ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lz ma mb lm b">10.0.0.2</code>可以通过<code class="eh lz ma mb lm b">eth0</code>界面到达，<code class="eh lz ma mb lm b">10.0.0.0/24 via 10.0.1.1 dev eth0</code></p><p id="d97f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它已经缓存了之前的MAC地址<code class="eh lz ma mb lm b">10.0.1.1</code>，因此不需要发出ARP请求，只需将缓存的MAC地址作为目的地。</p><figure class="lh li lj lk fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mp"><img src="../Images/c87f611bcbda5fbc20ac1c66037d9c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vsUBgb_cdwdbwfIdKc4_hg.png"/></div></div></figure><p id="97e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，路由器将反向重复该过程，并将回复转发回发送方！</p><p id="b16f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">仅此而已，有了足够多的互连路由器，你就可以在任何你喜欢的网络之间路由数据包。</p><figure class="lh li lj lk fq lw"><div class="bz el l di"><div class="mq mr l"/></div></figure></div></div>    
</body>
</html>