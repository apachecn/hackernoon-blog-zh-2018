<html>
<head>
<title>Testing LiveData on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android上测试LiveData</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/testing-livedata-on-android-d717c241efb1?source=collection_archive---------33-----------------------#2018-12-17">https://medium.com/hackernoon/testing-livedata-on-android-d717c241efb1?source=collection_archive---------33-----------------------#2018-12-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/89bff305616a0d56849d4058b36f740e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IqWjd9Oy8CX3ay5E.jpg"/></div></div></figure><blockquote class="jc jd je"><p id="e8bf" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">测试<code class="eh ke kf kg kh b">LiveData</code>代表了一个有趣的挑战，因为它的技术特性和它简化你的Android应用程序开发的方式。</p></blockquote><p id="6d93" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated">我最近开始开发一个Android应用程序，让我在学习Kotlin的旅程中保持动力。我最近的经验是关于<a class="ae kl" href="https://developer.android.com/topic/libraries/architecture/" rel="noopener ugc nofollow" target="_blank">架构组件</a>的，这篇简短的博客文章将特别关注在使用<code class="eh ke kf kg kh b"><a class="ae kl" href="https://developer.android.com/jetpack/arch/livedata" rel="noopener ugc nofollow" target="_blank">LiveData</a></code>时对你的DAO进行单元测试。</p><h2 id="6afb" class="km kn hu bd ko kp kq kr ks kt ku kv kw ki kx ky kz kj la lb lc kk ld le lf lg dt translated">什么是LiveData？</h2><p id="2b43" class="pw-post-body-paragraph jf jg hu ji b jj lh jl jm jn li jp jq ki lj jt ju kj lk jx jy kk ll kb kc kd hn dt translated"><code class="eh ke kf kg kh b">LiveData</code>是一个生命周期感知、可观察的数据持有者，它将帮助您对数据源的变化做出反应。在我的例子中，我将它与<code class="eh ke kf kg kh b"><a class="ae kl" href="https://developer.android.com/jetpack/arch/room" rel="noopener ugc nofollow" target="_blank">Room</a></code>结合使用，以确保我的应用程序对数据库中可用的新数据做出反应。</p><h2 id="0a07" class="km kn hu bd ko kp kq kr ks kt ku kv kw ki kx ky kz kj la lb lc kk ld le lf lg dt translated">我们简单的刀</h2><p id="dcbe" class="pw-post-body-paragraph jf jg hu ji b jj lh jl jm jn li jp jq ki lj jt ju kj lk jx jy kk ll kb kc kd hn dt translated">在这篇博文中，我们假设有一个非常简单的DAO，如下所示:</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="9fcb" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated">这只是一把帮你取帖的刀。</p><p id="7774" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated">正如你所看到的，函数的返回类型不仅仅是简单的<code class="eh ke kf kg kh b">List&lt;Post&gt;</code>，而是将它包装在一个<code class="eh ke kf kg kh b"><a class="ae kl" href="https://developer.android.com/reference/android/arch/lifecycle/LiveData" rel="noopener ugc nofollow" target="_blank">LiveData</a></code>实例中。这很棒，因为我们可以一次获得帖子列表的实例，然后<a class="ae kl" href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html#observe(android.arch.lifecycle.LifecycleOwner,%20android.arch.lifecycle.Observer%3CT%3E)" rel="noopener ugc nofollow" target="_blank"> <em class="jh">观察</em>的变化，并对它们做出反应</a> <em class="jh">。</em></p><h2 id="68d2" class="km kn hu bd ko kp kq kr ks kt ku kv kw ki kx ky kz kj la lb lc kk ld le lf lg dt translated">让我们测试一下</h2><p id="2b27" class="pw-post-body-paragraph jf jg hu ji b jj lh jl jm jn li jp jq ki lj jt ju kj lk jx jy kk ll kb kc kd hn dt translated">Android开发人员文档中有一个关于如何对DAO进行单元测试的简洁示例:</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="3711" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated">这个非常简单的测试的目的是测试数据是否被正确公开，并且一旦post被添加到数据库，它就会被<code class="eh ke kf kg kh b">getAll()</code>调用反映出来。</p><p id="96cd" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated">不幸的是，当我们断言它的时候，<code class="eh ke kf kg kh b">LiveData</code>实例的值将不会被填充，这将使我们的测试失败。这是因为<code class="eh ke kf kg kh b">LiveData</code>使用面向生命周期的异步机制来填充底层数据，并期望注册一个观察者来通知数据变化。</p><h2 id="9c41" class="km kn hu bd ko kp kq kr ks kt ku kv kw ki kx ky kz kj la lb lc kk ld le lf lg dt translated">观察你的数据</h2><p id="37ca" class="pw-post-body-paragraph jf jg hu ji b jj lh jl jm jn li jp jq ki lj jt ju kj lk jx jy kk ll kb kc kd hn dt translated"><code class="eh ke kf kg kh b">LiveData</code>提供了一种方便的观察方法，允许<em class="jh">观察</em>数据的变化。我们可以用它来注册一个将断言期望值的观察者。</p><p id="6c44" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated"><a class="ae kl" href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html#observe(android.arch.lifecycle.LifecycleOwner,%20android.arch.lifecycle.Observer%3CT%3E)" rel="noopener ugc nofollow" target="_blank">观察</a>方法具有以下签名:</p><pre class="lm ln lo lp fq ls kh lt lu aw lv dt"><span id="e6a7" class="km kn hu kh b fv lw lx l ly lz">void observe(<a class="ae kl" href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner.html" rel="noopener ugc nofollow" target="_blank">LifecycleOwner</a> owner, <a class="ae kl" href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html" rel="noopener ugc nofollow" target="_blank">Observer</a>&lt;T&gt; observer)</span></pre><p id="4c8c" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated">它需要一个观察者实例和其生命周期的所有者。在我们的例子中，我们感兴趣的只是将观察者留在能够断言已更改数据的地方。我们不希望每次数据改变时都评估相同的断言。</p><h2 id="78c7" class="km kn hu bd ko kp kq kr ks kt ku kv kw ki kx ky kz kj la lb lc kk ld le lf lg dt translated">掌控您的生命周期</h2><p id="f5fe" class="pw-post-body-paragraph jf jg hu ji b jj lh jl jm jn li jp jq ki lj jt ju kj lk jx jy kk ll kb kc kd hn dt translated">那么，我们能做的就是构建一个拥有自己生命周期的观察者实例。在处理完<a class="ae kl" href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html#onChanged(T)" rel="noopener ugc nofollow" target="_blank"> <em class="jh"> onChange </em> </a>事件后，我们会将观察者的生命周期标记为销毁，并让框架完成剩余的工作。</p><p id="d4f3" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated">让我们看看观察者代码是什么样子的:</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="efe1" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated">这个observer实现接受一个<em class="jh"> lambda </em>，它将作为<em class="jh"> onChange </em>事件的一部分被执行。一旦处理程序完成，它自己的生命周期将把自己标记为<code class="eh ke kf kg kh b"><em class="jh">ON_DESTROY</em></code>，这将触发从<code class="eh ke kf kg kh b">LiveData</code>实例中删除的过程。</p><p id="b0cb" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated">然后，我们可以在LiveData上创建一个扩展来利用这种观察器:</p><pre class="lm ln lo lp fq ls kh lt lu aw lv dt"><span id="0b05" class="km kn hu kh b fv lw lx l ly lz">fun &lt;T&gt; LiveData&lt;T&gt;.observeOnce(onChangeHandler: (T) -&gt; Unit) { <br/>    val observer = OneTimeObserver(handler = onChangeHandler) <br/>    observe(observer, observer)<br/>}</span></pre><h2 id="8a1e" class="km kn hu bd ko kp kq kr ks kt ku kv kw ki kx ky kz kj la lb lc kk ld le lf lg dt translated">让我们再测试一次<em class="ma"/></h2><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="b7fa" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated">这次有几件事需要注意。</p><p id="710f" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated">首先，我们正在利用一个<code class="eh ke kf kg kh b"><a class="ae kl" href="https://developer.android.com/reference/androidx/arch/core/executor/testing/InstantTaskExecutorRule" rel="noopener ugc nofollow" target="_blank">InstantTaskExecutorRule</a></code>。这是一个有用的实用规则，它负责将后台异步任务执行器与同步任务执行器进行交换。这对于能够确定性地测试我们的代码是至关重要的。(如果你想了解更多关于JUnit规则的信息，请查看这个。</p><p id="6534" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated">除此之外，我们现在利用我们已经编写的<code class="eh ke kf kg kh b">LiveData</code>扩展来编写我们的断言:</p><pre class="lm ln lo lp fq ls kh lt lu aw lv dt"><span id="0e45" class="km kn hu kh b fv lw lx l ly lz">postDao.getAll().observeOnce {<br/>    assertEquals(0, it.size)<br/>}</span></pre><p id="37de" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated">我们只是通过将所有细节留在我们的observer实现中，以一种更加紧凑和富有表现力的方式进行了断言。我们现在以确定的方式断言<code class="eh ke kf kg kh b">LiveData</code>实例，使得这种测试更容易读写。</p><h2 id="3e7e" class="km kn hu bd ko kp kq kr ks kt ku kv kw ki kx ky kz kj la lb lc kk ld le lf lg dt translated">结论</h2><p id="45a7" class="pw-post-body-paragraph jf jg hu ji b jj lh jl jm jn li jp jq ki lj jt ju kj lk jx jy kk ll kb kc kd hn dt translated">我希望这篇文章能帮助你更有效地为你的DAO编写测试。这是我最早使用Kotlin和Android的经验之一:请随意评论解决这个问题的更好方法。</p><p id="03bf" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kd hn dt translated"><em class="jh">封面照片由</em> <a class="ae kl" href="https://unsplash.com/photos/cwqG1N1AtI0?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> <em class="jh">欧文·史密斯</em></a><em class="jh"/><a class="ae kl" href="https://unsplash.com/search/photos/mobile-app-programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="jh">Unsplash</em></a></p></div></div>    
</body>
</html>