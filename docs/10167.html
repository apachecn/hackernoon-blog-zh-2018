<html>
<head>
<title>An Approach To Automating Application Resiliency Testing With Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种使用Kubernetes自动化应用弹性测试的方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/an-approach-to-automating-application-resiliency-testing-with-kubernetes-c336a4836c19?source=collection_archive---------1-----------------------#2018-12-18">https://medium.com/hackernoon/an-approach-to-automating-application-resiliency-testing-with-kubernetes-c336a4836c19?source=collection_archive---------1-----------------------#2018-12-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/77a299d273b458f915ce8ef3b21994ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5JHfko0QSTD8_XOq_qvLQ.jpeg"/></div></div></figure><figure class="jd je jf jg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff jc"><img src="../Images/79c80c725e923b7440ed18727aee6086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GITnLIb3hiTl-Dv7_JI5YA.png"/></div></div></figure><h1 id="3a37" class="jh ji hu bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dt translated">目录</h1><p id="2d2e" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">如果你从未失败过，你就没有活过</p><p id="1f9a" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated"><a class="ae ld" href="#f257" rel="noopener ugc nofollow">可靠性和弹性</a></p><p id="5393" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated"><a class="ae ld" href="#c287" rel="noopener ugc nofollow">所以让它破碎吧…但是要为它做好计划！</a></p><ul class=""><li id="cd6d" class="lj lk hu kh b ki le km lf kq ll ku lm ky ln lc lo lp lq lr dt translated"><a class="ae ld" href="#797f" rel="noopener ugc nofollow">为什么选择Kubernetes？</a></li><li id="bbaa" class="lj lk hu kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr dt translated"><a class="ae ld" href="#37c0" rel="noopener ugc nofollow">用ToxiProxy组织抗性</a></li><li id="3ca4" class="lj lk hu kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr dt translated"><a class="ae ld" href="#fb9a" rel="noopener ugc nofollow"> ResiProxy:一个Kubernetes同伴</a></li><li id="a2ef" class="lj lk hu kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr dt translated"><a class="ae ld" href="#6e62" rel="noopener ugc nofollow">快乐vs另类路径</a></li><li id="547a" class="lj lk hu kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr dt translated"><a class="ae ld" href="#2e2b" rel="noopener ugc nofollow">用空手道保持冷静和克制</a></li></ul><p id="d0f3" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated"><a class="ae ld" href="#7f16" rel="noopener ugc nofollow">结论</a></p></div><div class="ab cl lx ly hc lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hn ho hp hq hr"><h1 id="bc7b" class="jh ji hu bd jj jk me jm jn jo mf jq jr js mg ju jv jw mh jy jz ka mi kc kd ke dt translated">如果你从未失败过，那你就没有活过</h1><p id="b683" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">不要对微服务过于悲观，这句俗语也是有道理的:失败是任何分布式系统的固有特征。数百个独立的实体试图沟通和合作，以实现更大的利益…其中至少有一个肯定会失败。</p><p id="9af7" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">试图避免所有这些失败是一厢情愿的想法，有时会导致额外的复杂性，这会直接影响架构及其成本，特别是限制其发展、测试和维护的能力。</p><p id="8134" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">一如既往，需要一种平衡:即使我们显然应该通过增加冗余来显著限制它们，接受失败和尝试弹性在构建架构时提供了一系列不同的方法和机会。</p><p id="a38d" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">一旦理解了不同类型的可能故障以及如何设计和构建系统来处理它们，在生产中体验它们之前进行测试是很自然的。</p><p id="45d6" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">本文关注最后一个方面，并展示了一种在微服务级别自动测试弹性的方法。</p></div><div class="ab cl lx ly hc lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hn ho hp hq hr"><h1 id="f257" class="jh ji hu bd jj jk me jm jn jo mf jq jr js mg ju jv jw mh jy jz ka mi kc kd ke dt translated">可靠性和弹性</h1><p id="b192" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">任何系统的一个重要方面是其可靠性:</p><blockquote class="mj"><p id="c650" class="mk ml hu bd mm mn mo mp mq mr ms lc ek translated">可信性或可靠性描述了系统或组件在规定的条件下运行一段时间的能力。可靠性与可用性密切相关，可用性通常被描述为组件或系统在特定时刻或时间间隔内运行的能力。— <a class="ae ld" href="https://en.wikipedia.org/wiki/Reliability_engineering" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="857f" class="pw-post-body-paragraph kf kg hu kh b ki mt kk kl km mu ko kp kq mv ks kt ku mw kw kx ky mx la lb lc hn dt translated">它隐含地捕获了系统避免故障的能力，因此在给定的时间内是可用的:<a class="ae ld" href="https://landing.google.com/sre/sre-book/chapters/availability-table/" rel="noopener ugc nofollow" target="_blank"> x 9的可用性</a>。</p><p id="6544" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">然而，对于由多个独立服务组成的系统，有效地计算和管理全局开始变得棘手。<a class="ae ld" rel="noopener" href="/netflix-techblog/fault-tolerance-in-a-high-volume-distributed-system-91ab4faae74a">这篇来自网飞的旧文章</a>有助于你了解更大的图景。</p><p id="e3a4" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">失败可能有多种来源:微服务可能会耗尽资源，在较重的负载下失败，或者仅仅是因为对于分布式系统来说，构建无错误的应用程序更加复杂。</p><p id="56c2" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">此外，仅仅因为网络的<a class="ae ld" href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing" rel="noopener ugc nofollow" target="_blank">可靠性方面，平台(硬件、软件+、网络)永远无法保证100%的可用性。</a></p><p id="10b2" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">然后，透过<strong class="kh hv">弹性:</strong>的透镜来观察系统变得很重要</p><blockquote class="mj"><p id="0da4" class="mk ml hu bd mm mn mo mp mq mr ms lc ek translated">弹性是系统从容处理故障并从故障中恢复的能力。云托管的本质是应用程序通常是多租户的，使用共享平台服务，竞争资源和带宽，通过互联网进行通信，并在商用硬件上运行，这意味着出现暂时性和永久性故障的可能性增加。检测故障并快速高效地恢复，对于保持弹性是必要的。— <a class="ae ld" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency" rel="noopener ugc nofollow" target="_blank">微软Azure </a></p></blockquote><p id="81df" class="pw-post-body-paragraph kf kg hu kh b ki mt kk kl km mu ko kp kq mv ks kt ku mw kw kx ky mx la lb lc hn dt translated">尽管不能在沙箱中测试每种类型的故障，但是可以模拟它们对客户端的影响。</p><p id="e1ed" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">最终，目标是做好准备。回退策略(例如在降级模式下运行)可以在应用程序级别实施，随后需要进行验证。</p></div><div class="ab cl lx ly hc lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hn ho hp hq hr"><h1 id="c287" class="jh ji hu bd jj jk me jm jn jo mf jq jr js mg ju jv jw mh jy jz ka mi kc kd ke dt translated">所以让它破碎吧…但是要为它做好计划！</h1><p id="830b" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">事不宜迟，这最后一部分展示了如何模拟Kubernetes集群中独立(微)服务之间的故障，并通过自动化测试捕获这些场景。</p><h2 id="797f" class="my ji hu bd jj mz na nb jn nc nd ne jr kq nf ng jv ku nh ni jz ky nj nk kd nl dt translated">为什么是Kubernetes？</h2><p id="a5e0" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">对于那些必须处理集成问题的人来说，试图找出为什么在开发或QA环境中工作的服务在生产中会失败，通过只采用一种部署模型来最小化这些差异是显而易见的。</p><p id="a6c6" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">除此之外，我们希望支持另外一种类型的测试，而且受环境拓扑的影响，其中一个需求是使用生产中使用的相同部署平台进行测试，即Kubernetes。</p><p id="f461" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">下面所有的例子都基于一个部署，该部署由两个相同的go微服务组成，公开了同一个<code class="eh nm nn no np b">/status</code> REST端点:服务1依赖于服务2，比如当它接收到一个GET请求时，它将它转发给服务2，并在返回全局状态之前聚合响应。</p><p id="448d" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">此处提供了该示例微服务的代码<a class="ae ld" href="https://github.com/marqub/go-service" rel="noopener ugc nofollow" target="_blank">，两种部署都可以使用提供的舵图进行设置:</a></p><pre class="jd je jf jg fq nq np nr ns aw nt dt"><span id="4c1c" class="my ji hu np b fv nu nv l nw nx">$ helm install chart/ --name service1 --namespace resiliency-testing --set DEPENDENCY_NAME=http://service2-go-service.resiliency-testing:8080</span><span id="7e4f" class="my ji hu np b fv ny nv l nw nx">$ helm install chart/ --name service2 --namespace resiliency-testing</span></pre><p id="82be" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">它创建了以下Kubernetes资源:</p><pre class="jd je jf jg fq nq np nr ns aw nt dt"><span id="2197" class="my ji hu np b fv nu nv l nw nx">$ <strong class="np hv">kubectl get pods,services,ingresses -n resiliency-testing</strong></span><span id="7cc8" class="my ji hu np b fv ny nv l nw nx">NAME                                       READY     STATUS    <br/>pod/service1-go-service-7b4bc7c444-mnfvz   1/1       Running   <br/>pod/service2-go-service-6dff85ff9c-8rzg6   1/1       Running</span><span id="2750" class="my ji hu np b fv ny nv l nw nx">NAME                          TYPE         PORT(S)          <br/>service/service1-go-service   NodePort     8080:32564/TCP   <br/>service/service2-go-service   NodePort     8080:30829/TCP</span><span id="2b01" class="my ji hu np b fv ny nv l nw nx">NAME                                     HOSTS                             <br/>ingress.extensions/service1-go-service   service1.resiliency-testing.com   <br/>ingress.extensions/service2-go-service   service2.resiliency-testing.com</span></pre><p id="cfe5" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">简单来说:</p><ul class=""><li id="2493" class="lj lk hu kh b ki le km lf kq ll ku lm ky ln lc lo lp lq lr dt translated">每个微服务有一个pod，</li><li id="3e62" class="lj lk hu kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr dt translated">微服务可通过其专用的K8s服务在内部访问，</li><li id="244e" class="lj lk hu kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr dt translated">K8s服务重定向到pod，</li><li id="f224" class="lj lk hu kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr dt translated">入口通过重定向到K8s服务，允许集群外部的客户端通过主机名与微服务进行交互。</li></ul><figure class="jd je jf jg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nz"><img src="../Images/b9d1d0c3e947d51e43a812a17ec5f816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6fR1RHw3SxlgWFHVyBcXIQ.png"/></div></div></figure><p id="41f4" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">对于此请求:</p><pre class="jd je jf jg fq nq np nr ns aw nt dt"><span id="c55b" class="my ji hu np b fv nu nv l nw nx">curl -X GET <a class="ae ld" href="http://service1.resiliency-testing.com/status" rel="noopener ugc nofollow" target="_blank">http://service1.resiliency-testing.com/status</a></span></pre><p id="634f" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">一个健康的系统会返回:</p><pre class="jd je jf jg fq nq np nr ns aw nt dt"><span id="8392" class="my ji hu np b fv nu nv l nw nx">{<br/>    "status": "OK",<br/>    "name": "service1",<br/>    "dependencies": [<br/>        {<br/>            "status": "OK",<br/>            "name": "service2"<br/>        }<br/>    ]<br/>}</span></pre><h2 id="37c0" class="my ji hu bd jj mz na nb jn nc nd ne jr kq nf ng jv ku nh ni jz ky nj nk kd nl dt translated">用毒素组织抵抗</h2><p id="9e52" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">我们首先寻找的是一种篡改网络通信的方法，然后，它在Kubernetes集群中工作。</p><p id="19a2" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated"><a class="ae ld" href="https://github.com/Shopify/toxiproxy" rel="noopener ugc nofollow" target="_blank"> ToxiProxy </a>来了，<a class="oa ob gr" href="https://medium.com/u/bab76dfc19b0?source=post_page-----c336a4836c19--------------------------------" rel="noopener" target="_blank"> Shopify </a>的L4代理。</p><blockquote class="oc od oe"><p id="e288" class="kf kg of kh b ki le kk kl km lf ko kp og lg ks kt oh lh kw kx oi li la lb lc hn dt translated">Toxiproxy是一个模拟网络条件的框架。它专门用于测试、CI和开发环境，支持连接的确定性篡改，但支持随机混乱和定制。Toxiproxy是您需要通过测试来证明您的应用程序没有单点故障的工具。</p></blockquote><p id="65b2" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">ToxiProxy允许动态打开端口，并将任何传入的TCP流量转发到目标目的地。在服务和它的外部依赖项之间有这样的代理是模拟失败的最佳场所。</p><p id="2520" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">最重要的是，ToxiProxy公开了一组Restful APIs，使得在服务之间动态创建代理和模拟问题变得容易。完成初始部署后，这是一种安静的便利！</p><h2 id="fb9a" class="my ji hu bd jj mz na nb jn nc nd ne jr kq nf ng jv ku nh ni jz ky nj nk kd nl dt translated">resi proxy:Kubernetes的伙伴</h2><p id="6b8b" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">不幸的是，尽管它可以打包成Docker容器，但ToxiProxy一旦部署到Kubernetes就无法工作:Kubernetes集群中的端口转发不仅仅是在应用程序级别打开端口。</p><p id="0070" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">通过Kubernetes服务可以在集群中访问在容器中运行的应用程序。该服务必须打开一个传入端口，以指向由应用程序打开并由容器/pod公开的端口。</p><p id="f6c4" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">每当ToxiProxy打开一个新端口时，它都需要映射到一个关联的k8s服务的端口。更多信息<a class="ae ld" href="https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</p><p id="a1a7" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">为了完成这项工作，我们想到了ResiProxy:一个用Go编写的轻量级ToxiProxy K8s伙伴，它代理对tox proxy的调用。这里是git存储库。</p><p id="a7c2" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">它用于<strong class="kh hv"> only </strong>拦截<strong class="kh hv">REST admins</strong>对tox proxy的调用，如果需要，执行K8s相关操作，然后将调用转发给tox proxy完成。</p><p id="71b4" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">提供了用于部署ResiProxy和ToxiProxy的舵图:</p><pre class="jd je jf jg fq nq np nr ns aw nt dt"><span id="8c14" class="my ji hu np b fv nu nv l nw nx">helm<strong class="np hv"> </strong>install chart/ --namespace resiliency-testing --name resiproxy</span></pre><p id="e85c" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">它创建了一个额外的pod，其中包含ResiProxy和tox proxy容器、两个关联的服务以及一个用于访问ResiProxy(并配置tox proxy)的入口:</p><pre class="jd je jf jg fq nq np nr ns aw nt dt"><span id="49f8" class="my ji hu np b fv nu nv l nw nx">$ <strong class="np hv">kubectl get pods,services,ingresses -n resiliency-testing</strong></span><span id="c2f6" class="my ji hu np b fv ny nv l nw nx">NAME                                       READY     STATUS    <br/><strong class="np hv">pod/resiproxy-resiproxy-7dd7867984-sjk8r   2/2       Running  <br/></strong>pod/service1-go-service-56f6b67c6b-czjjg   1/1       Running<br/>pod/service2-go-service-6dff85ff9c-8rzg6   1/1       Running</span><span id="f27e" class="my ji hu np b fv ny nv l nw nx">NAME                          TYPE       PORT(S)                                        <br/><strong class="np hv">service/resiproxy-resiproxy   NodePort   8080:32342/TCP                                 <br/>service/resiproxy-toxiproxy   NodePort   8474:31974/TCP</strong><br/>service/service1-go-service   NodePort   8080:31666/TCP                                 <br/>service/service2-go-service   NodePort   8080:30829/TCP</span><span id="7d1f" class="my ji hu np b fv ny nv l nw nx">NAME                                     HOSTS                              <br/><strong class="np hv">ingress.extensions/resiproxy-resiproxy   resiproxy.resiliency-testing.com</strong><br/>ingress.extensions/service1-go-service   service1.resiliency-testing.com<br/>ingress.extensions/service2-go-service   service2.resiliency-testing.com</span></pre><p id="6be5" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated"><strong class="kh hv">想要<strong class="kh hv">配置ToxiProxy </strong>的外部客户端</strong>将使用<strong class="kh hv">入口来ResiProxy。</strong>随后<strong class="kh hv">，一个希望<strong class="kh hv">与另一个<strong class="kh hv">依赖</strong>的</strong>对话的微服务</strong>将使用<strong class="kh hv">ToxiProxy的K8s服务</strong>和之前创建的端口。</p><p id="b891" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">默认情况下，这个服务只“公开”一个端口，ToxiProxy在这个端口监听REST调用，ResiProxy将配置请求转发到这个端口:8474。</p><pre class="jd je jf jg fq nq np nr ns aw nt dt"><span id="b3d5" class="my ji hu np b fv nu nv l nw nx">$ <strong class="np hv">kubectl describe service resiproxy-toxiproxy -n resiliency-testing</strong></span><span id="0c3d" class="my ji hu np b fv ny nv l nw nx">Name:                     resiproxy-toxiproxy<br/>Namespace:                resiliency-testing<br/>Labels:                   app=resiproxy<br/>                          chart=resiproxy-0.0.1<br/>                          heritage=Tiller<br/>                          release=resiproxy<br/>Annotations:              &lt;none&gt;<br/>Selector:                 app=resiproxy,release=resiproxy<br/>Type:                     NodePort<br/>IP:                       xxx.xxx.xxx.xxx<br/><strong class="np hv">Port:                     http-toxiproxy  8474/TCP<br/>TargetPort:               8474/TCP</strong><br/>NodePort:                 http-toxiproxy  31974/TCP<br/>Endpoints:                xxx.xxx.xxx.xxx:8474<br/>Session Affinity:         None<br/>External Traffic Policy:  Cluster<br/>Events:                   &lt;none&gt;</span></pre><p id="56be" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">如上所述，为了配置服务1和服务2之间的桥，我们需要使用ResiProxy。</p><pre class="jd je jf jg fq nq np nr ns aw nt dt"><span id="124e" class="my ji hu np b fv nu nv l nw nx">curl -X POST <a class="ae ld" href="http://resiproxy.resiliency-testing.com/proxies" rel="noopener ugc nofollow" target="_blank">http://resiproxy.resiliency-testing.com/proxies</a> \  <br/>  -H 'Content-Type: application/json' \<br/>  -d '{<br/>    "name": "proxy_service2",<br/>    "listen": "[::]:8081",<br/>    "upstream": "service2-go-service.resiliency-testing:8080",<br/>    "enabled": true<br/>}'</span></pre><p id="bd44" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">现在，发送到ToxiProxy的端口8081的每个请求都将被转发到service 2的端口8080。不出所料，ToxiProxy的K8s服务级别现在开放了一个新端口:</p><pre class="jd je jf jg fq nq np nr ns aw nt dt"><span id="53f3" class="my ji hu np b fv nu nv l nw nx">$ <strong class="np hv">kubectl describe service resiproxy-toxiproxy -n resiliency-testing</strong></span><span id="a5e9" class="my ji hu np b fv ny nv l nw nx">Name:                     resiproxy-toxiproxy<br/>Namespace:                resiliency-testing<br/>Labels:                   app=resiproxy<br/>                          chart=resiproxy-0.0.1<br/>                          heritage=Tiller<br/>                          release=resiproxy<br/>Annotations:              &lt;none&gt;<br/>Selector:                 app=resiproxy,release=resiproxy<br/>Type:                     NodePort<br/>IP:                       xxx.xxx.xxx.xxx<br/><strong class="np hv">Port:                     http-toxiproxy  8474/TCP<br/>TargetPort:               8474/TCP</strong><br/>NodePort:                 http-toxiproxy  31974/TCP<br/>Endpoints:                xxx.xxx.xxx.xxx:8474<br/><strong class="np hv">Port:                     8081  8081/TCP<br/>TargetPort:               8081/TCP</strong><br/>NodePort:                 8081  30795/TCP<br/>Endpoints:                xxx.xxx.xxx.xxx:8081<br/>Session Affinity:         None<br/>External Traffic Policy:  Cluster<br/>Events:                   &lt;none&gt;</span></pre><p id="184a" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">然后，我们可以重新部署服务1以指向ToxiProxy打开的新端口，该端口重定向到服务2 ( <a class="ae ld" href="#4c1c" rel="noopener ugc nofollow">而不是像以前那样直接指向服务2</a>):</p><pre class="jd je jf jg fq nq np nr ns aw nt dt"><span id="b3fa" class="my ji hu np b fv nu nv l nw nx">$ helm install chart/ --name service1 --namespace resiliency-testing --set DEPENDENCY_NAME=http://resiproxy-toxiproxy.resiliency-testing:8081</span></pre><p id="bd77" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">总而言之，弹性测试部署模型现在看起来像这样:</p><figure class="jd je jf jg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oj"><img src="../Images/e633e51d470421fcd0f94494742c3c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vgo6_NI45pc9YSZmLM7Vaw.png"/></div></div></figure><h2 id="6e62" class="my ji hu bd jj mz na nb jn nc nd ne jr kq nf ng jv ku nh ni jz ky nj nk kd nl dt translated">快乐vs另类路径</h2><p id="6737" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">有趣的是，在这个初始部署之后，代理在默认情况下是启用的，并且将从服务1发起的任何请求转发到服务2:</p><pre class="jd je jf jg fq nq np nr ns aw nt dt"><span id="d573" class="my ji hu np b fv nu nv l nw nx">{<br/>    "name": "proxy_service2",<br/>    "listen": "[::]:8081",<br/>    "upstream": "service2-go-service.resiliency-testing:8080",<br/><strong class="np hv">    "enabled": true,<br/></strong>    "toxics": []<br/>}</span></pre><p id="aa68" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">从客户端来看，测试快乐路径与我们的第一个测试完全相同。</p><p id="cf2a" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">测试替代路径(例如，在服务2不可达的地方)非常简单，并且只需要一个先前的REST请求来禁用该代理。</p><pre class="jd je jf jg fq nq np nr ns aw nt dt"><span id="592a" class="my ji hu np b fv nu nv l nw nx">curl -X POST \<br/> <a class="ae ld" href="http://resiproxy.resiliency-testing.com/proxies/proxy_service2" rel="noopener ugc nofollow" target="_blank">http://resiproxy.resiliency-testing.com/proxies/proxy_service2</a> \<br/>  -H 'Content-Type: application/json' \<br/>  -d '{<br/>    "name": "proxy_service2",<br/>    "listen": "[::]:8081",<br/>    "upstream": "service2-go-service.resiliency-testing:8080",<br/><strong class="np hv">    "enabled": false<br/></strong>}'</span></pre><p id="52eb" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">相同的先前REST请求</p><pre class="jd je jf jg fq nq np nr ns aw nt dt"><span id="46c7" class="my ji hu np b fv nu nv l nw nx">curl -X GET <a class="ae ld" href="http://service1.resiliency-testing.com/status" rel="noopener ugc nofollow" target="_blank">http://service1.resiliency-testing.com/status</a></span></pre><p id="856d" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">现在将返回一个完全不同的结果:</p><pre class="jd je jf jg fq nq np nr ns aw nt dt"><span id="1c6d" class="my ji hu np b fv nu nv l nw nx">{<br/>    "status": "OK",<br/>    "name": "service1",<br/>    "dependencies": [<br/>        <strong class="np hv">{<br/>            "status": "UNKNOWN",<br/>            "name": "</strong><a class="ae ld" href="http://resiproxy-toxiproxy.resiliency-testing:8081" rel="noopener ugc nofollow" target="_blank"><strong class="np hv">http://resiproxy-toxiproxy.resiliency-testing:8081</strong></a><strong class="np hv">"<br/>        }</strong><br/>    ]<br/>}</span></pre><p id="1e31" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">测试这个场景可以确保它是否以及如何被计划。例如，通过重试，返回预定义的错误，或者在这种情况下，<strong class="kh hv">返回降级的部分响应</strong>。</p><h2 id="2e2b" class="my ji hu bd jj mz na nb jn nc nd ne jr kq nf ng jv ku nh ni jz ky nj nk kd nl dt translated">用空手道保持冷静和控制</h2><blockquote class="oc od oe"><p id="5140" class="kf kg of kh b ki le kk kl km lf ko kp og lg ks kt oh lh kw kx oi li la lb lc hn dt translated"><a class="ae ld" href="https://github.com/intuit/karate" rel="noopener ugc nofollow" target="_blank">空手道</a>是唯一一个将API测试自动化、<a class="ae ld" href="https://github.com/intuit/karate/blob/master/karate-netty" rel="noopener ugc nofollow" target="_blank">模仿</a>和<a class="ae ld" href="https://github.com/intuit/karate/blob/master/karate-gatling" rel="noopener ugc nofollow" target="_blank">性能测试</a>结合成一个单一的、<em class="hu">统一的</em>框架的开源工具。Cucumber推广的BDD语法是语言中立的，即使对于非程序员也很容易理解。除了强大的JSON &amp; XML断言，您还可以并行运行测试以提高速度——这对HTTP API测试至关重要。</p><p id="3d5e" class="kf kg of kh b ki le kk kl km lf ko kp og lg ks kt oh lh kw kx oi li la lb lc hn dt translated">您可以轻松地构建(或重用)复杂的请求负载，并从响应数据中动态构造更多的请求。有效负载和模式验证引擎可以对两个JSON或XML文档进行“智能比较”(深度相等)，您甚至可以在需要时忽略动态值。</p><p id="d150" class="kf kg of kh b ki le kk kl km lf ko kp og lg ks kt oh lh kw kx oi li la lb lc hn dt translated">测试执行和报告生成感觉就像任何标准的Java项目。但是也有一个<a class="ae ld" href="https://github.com/intuit/karate/blob/master/karate-netty#standalone-jar" rel="noopener ugc nofollow" target="_blank">独立的可执行文件</a>供不熟悉Java的团队使用。只需用简单的、<em class="hu">可读的</em>语法编写测试——为HTTP、JSON、GraphQL和XML精心设计。</p></blockquote><p id="f114" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">空手道是一种工具，我们用它来自动化所有的测试，直到现在我们都是手工进行的。通过这种方式，我们可以轻松地将它们集成为CI/CD管道的一部分，并增强我们对生产系统整体稳健性的信心。</p><p id="db7e" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">这最后一部分通过在单独的自动化场景中捕捉所有前面的例子，给出了<a class="oa ob gr" href="https://medium.com/u/f335be9d99c4?source=post_page-----c336a4836c19--------------------------------" rel="noopener" target="_blank">空手道DSL </a>的概述。</p><p id="4b65" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">为了提高可读性，第一项任务是将REST调用分为两种不同的场景:</p><p id="4892" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">1.创建代理</p><pre class="jd je jf jg fq nq np nr ns aw nt dt"><span id="ffbd" class="my ji hu np b fv nu nv l nw nx">Feature: Create service2 proxy: does not fail if the proxy already exists</span><span id="6d70" class="my ji hu np b fv ny nv l nw nx"><strong class="np hv">Scenario</strong>:<br/>* def validStatus = [201, 409]<br/>* def proxy = <br/>"""<br/>{<br/>    "name": "proxy_service2",<br/>    "listen": "[::]:8081",<br/>    "upstream": "service2-go-service.resiliency-testing:8080",<br/>    "enabled": true<br/>}<br/>"""<br/><strong class="np hv">Given</strong> url '<a class="ae ld" href="http://resiproxy.resiliency-testing.com/proxies'" rel="noopener ugc nofollow" target="_blank">http://resiproxy.resiliency-testing.com/proxies'</a><br/><strong class="np hv">And</strong> request proxy<br/><strong class="np hv">When</strong> method post<br/><strong class="np hv">Then</strong> match validStatus contains responseStatus</span></pre><p id="a362" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">2.启用/禁用它</p><pre class="jd je jf jg fq nq np nr ns aw nt dt"><span id="cdfe" class="my ji hu np b fv nu nv l nw nx">Feature: Enable/Disable service2 proxy</span><span id="d1f9" class="my ji hu np b fv ny nv l nw nx"><strong class="np hv">Scenario</strong>:<br/>* def enabled = __arg.enabled<br/>* def proxy = <br/>"""<br/>{<br/>    "name": "proxy_service2",<br/>    "listen": "[::]:8081",<br/>    "upstream": "service2-go-service.resiliency-testing:8080",<br/>    "enabled": "#(enabled)",<br/>}<br/>"""<br/><strong class="np hv">Given</strong> url '<a class="ae ld" href="http://resiproxy.resiliency-testing.com/proxies/proxy_service2'" rel="noopener ugc nofollow" target="_blank">http://resiproxy.resiliency-testing.com/proxies/proxy_service2'</a><br/><strong class="np hv">And</strong> request proxy<br/><strong class="np hv">When</strong> method post<br/><strong class="np hv">Then</strong> status 200</span></pre><p id="52d9" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">然后我们可以定义一个场景来捕捉我们之前用<a class="ae ld" href="#592a" rel="noopener ugc nofollow"> curl命令</a>手动测试的快乐路径:</p><pre class="jd je jf jg fq nq np nr ns aw nt dt"><span id="55cb" class="my ji hu np b fv nu nv l nw nx">Background:<br/><strong class="np hv">* url '</strong><a class="ae ld" href="http://service1.resiliency-testing.com'" rel="noopener ugc nofollow" target="_blank"><strong class="np hv">http://service1.resiliency-testing.com'</strong></a><strong class="np hv"><br/>* call read('failures/service2-delete.feature')<br/>* call read('failures/service2-create.feature')</strong></span><span id="d265" class="my ji hu np b fv ny nv l nw nx"><strong class="np hv">Scenario</strong>: Retrieve status when service 2 is available</span><span id="e674" class="my ji hu np b fv ny nv l nw nx"><strong class="np hv">* call read('failures/service2-enable.feature') { enabled: true }</strong></span><span id="f626" class="my ji hu np b fv ny nv l nw nx"><strong class="np hv">Given</strong> path 'status'<br/><strong class="np hv">When</strong> method get<br/><strong class="np hv">Then</strong> status 200<br/><strong class="np hv">Then</strong> match response ==<br/>  """<br/>    {<br/>    "status":"OK",<br/>    "name":"service1",<br/>    "dependencies":[<br/>        {<br/>            "status":"OK",<br/>            "name":"service2"<br/>        }<br/>    ]<br/>    }<br/>  """</span></pre><p id="883f" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">最后，服务2不可用时的备用路径也可以在不同的场景中定义:</p><pre class="jd je jf jg fq nq np nr ns aw nt dt"><span id="f95c" class="my ji hu np b fv nu nv l nw nx"><strong class="np hv">Scenario</strong>: Retrieve status when service 2 is not available</span><span id="80de" class="my ji hu np b fv ny nv l nw nx"><strong class="np hv">* call read('failures/service2-enable.feature') { enabled: false }</strong></span><span id="0d4b" class="my ji hu np b fv ny nv l nw nx"><strong class="np hv">Given</strong> path 'status'<br/><strong class="np hv">When</strong> method get<br/><strong class="np hv">Then</strong> status 200<br/><strong class="np hv">Then</strong> match response ==<br/>  """<br/>    {<br/>    "status":"OK",<br/>    "name":"service1",<br/>    "dependencies":[<br/>        {<br/>            "status":"UNKNOWN",<br/>            "name":"#ignore"<br/>        }<br/>    ]<br/>    }</span></pre><p id="bb99" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">ToxiProxy公开了一组Restful APIs，使得在服务之间动态创建代理和模拟“问题”变得容易。如果大多数时候我们想玩网络延迟或者只是模拟不可用性，ToxiProxy支持更广泛的被称为<a class="ae ld" href="https://github.com/Shopify/toxiproxy#toxics" rel="noopener ugc nofollow" target="_blank"> <em class="of">毒物</em> </a>的东西。</p><p id="97ab" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">空手道提供了清晰的BDD可读语法(GIVEN/WHEN/THEN)来捕获这些测试并防止将来的回归。</p><p id="4fac" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">这些测试的完整代码可以在<a class="ae ld" href="https://github.com/marqub/resiliency-testing" rel="noopener ugc nofollow" target="_blank">这个git库</a>中找到。</p></div><div class="ab cl lx ly hc lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hn ho hp hq hr"><h1 id="7f16" class="jh ji hu bd jj jk me jm jn jo mf jq jr js mg ju jv jw mh jy jz ka mi kc kd ke dt translated">结论</h1><p id="3e9d" class="pw-post-body-paragraph kf kg hu kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc hn dt translated">这篇文章不是关于:</p><ul class=""><li id="1b3d" class="lj lk hu kh b ki le km lf kq ll ku lm ky ln lc lo lp lq lr dt translated">描述分布式系统中可能发生的不同类型的故障，</li><li id="0def" class="lj lk hu kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr dt translated">构建弹性应用程序，</li><li id="b8d0" class="lj lk hu kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr dt translated">详述测试弹性的不同方法，</li><li id="5ddc" class="lj lk hu kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr dt translated">或者以后如何利用可观察性来监控、检测和理解故障以及适当的策略。</li></ul><p id="deac" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">所有这些都将是后续帖子的好主题，尽管其中一些内容已经被广泛传播，从<a class="ae ld" href="https://pragprog.com/book/mnee2/release-it-second-edition" rel="noopener ugc nofollow" target="_blank">的优秀书籍<em class="of">发布开始！</em> </a>。</p><p id="99ae" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">从全局来看，架构的弹性方面创造了不同的机会，如提供不同的用户体验、扩展和支持更重的负载，以及构建更健壮的系统。</p><p id="1a2a" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">这篇文章是关于给开发者合适的工具来关注这个方面，并且除了常规的单元测试之外，简单地用Kubernetes测试它。</p><p id="9f62" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">另一个好处是其他人，比如QA团队，能够在以后查看完成的工作，检查不同的部分是否一起工作，以及它们是否与外部系统配合良好。</p><p id="44c4" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">ResiProxy/ToxiProxy和空手道是添加到您的测试工具箱中的新工具。它们有助于将这些类型的测试从其他测试中分离出来，并强调它们的重要性。</p><p id="91a8" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated">你可以回头看看这篇文章中列出的不同git库的所有代码:<a class="ae ld" href="https://github.com/marqub/resiproxy" rel="noopener ugc nofollow" target="_blank"> ResiProxy </a>，<a class="ae ld" href="https://github.com/marqub/go-service" rel="noopener ugc nofollow" target="_blank">样例go微服务</a>和<a class="ae ld" href="https://github.com/marqub/resiliency-testing" rel="noopener ugc nofollow" target="_blank">空手道测试</a>。</p></div><div class="ab cl lx ly hc lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hn ho hp hq hr"><p id="b426" class="pw-post-body-paragraph kf kg hu kh b ki le kk kl km lf ko kp kq lg ks kt ku lh kw kx ky li la lb lc hn dt translated"><em class="of">觉得这篇文章有用吗？关注我上</em> <a class="ae ld" rel="noopener" href="/@bmarquie"> <em class="of">中</em></a><em class="of"/><a class="ae ld" href="http://bit.ly/2G40HXe" rel="noopener ugc nofollow" target="_blank"><em class="of">推特</em> </a> <em class="of">，还有</em><a class="ae ld" href="http://t.co/JI0k1ZMs9k" rel="noopener ugc nofollow" target="_blank"><em class="of">Linkedin</em></a><em class="of">！请👏这篇文章分享一下吧！</em></p></div></div>    
</body>
</html>