<html>
<head>
<title>A crash course on serverless-side rendering with React.js, Next.js and AWS Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React.js、Next.js和AWS Lambda的无服务器端渲染速成班</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-crash-course-on-serverless-side-rendering-with-react-js-next-js-and-aws-lambda-30e0ba967849?source=collection_archive---------2-----------------------#2018-12-18">https://medium.com/hackernoon/a-crash-course-on-serverless-side-rendering-with-react-js-next-js-and-aws-lambda-30e0ba967849?source=collection_archive---------2-----------------------#2018-12-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/c737f4aada8aeb8bc3b39cb15c7b2fd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qW57VxADnoD9_o_0L-We0Q.jpeg"/></div></div></figure><p id="e5f7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不久前，我开始探索服务器端呈现的单页面应用程序。是的，试着快速说三遍。为初创公司打造产品教会了我，如果你想在网上立足，搜索引擎优化是必不可少的。但是，你也想要水疗所能提供的性能。</p><p id="f375" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们希望两全其美。SEO boost服务器端呈现提供了单个页面应用程序的速度。今天，我将在AWS Lambda上的一个无服务器环境中向您展示这一切，并且基本上是免费的。</p><h1 id="200e" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="47a8" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">让我们浏览一下本教程将涵盖的内容。你可以浏览并跳到你感兴趣的部分。或者，做个书呆子，继续读书。<br/> <em class="ld"> *耳语*请做个书呆子。</em></p><ul class=""><li id="165e" class="le lf hu je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated">我们在建造什么？</li><li id="0c47" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">配置和安装依赖项</li><li id="59b2" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">用<a class="ae ls" href="https://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>和<a class="ae ls" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>构建app</li><li id="cd9d" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">将应用程序部署到<a class="ae ls" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a></li></ul><p id="7a4f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ld">注意</em> </strong> <em class="ld">:我们要写的</em> <a class="ae ls" href="https://github.com/adnanrahic/serverless-side-rendering-react-next" rel="noopener ugc nofollow" target="_blank"> <em class="ld">代码已经在GitHub </em> </a> <em class="ld">上了，如果需要进一步参考或者遗漏了什么步骤，可以随时查看。在我开始写这个教程之前，</em><a class="ae ls" href="https://statsbot.co/cubejs/" rel="noopener ugc nofollow" target="_blank"><em class="ld">cube . js</em></a><em class="ld">的家伙们给了我一个快速的React概要。他们有一个</em> <a class="ae ls" href="https://github.com/statsbotco/cubejs-client" rel="noopener ugc nofollow" target="_blank"> <em class="ld">无服务器分析框架</em> </a> <em class="ld">，可以很好地插入React。请随意尝试一下。</em></p><h1 id="1dd2" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">我们在建造什么？</h1><p id="d924" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">当然是反应极快的应用程序！虽然每个水疗中心的成本是糟糕的搜索引擎优化能力。因此，我们需要以一种整合服务器端渲染的方式构建应用程序。听起来很简单。我们可以使用<a class="ae ls" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>，一个用于静态和服务器渲染<a class="ae ls" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React.js </a>应用的轻量级框架。</p><p id="66f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为此，我们需要启动一个简单的Express服务器，并配置下一个应用程序通过Express提供文件服务。这比听起来简单多了。</p><p id="2d13" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，从标题中，你可以假设我们不喜欢我家附近的<em class="ld">服务器</em>这个词。解决方案是将整个应用程序部署到<a class="ae ls" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>！它毕竟是一个很小的Node.js实例。</p><p id="9115" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">准备好了吗？让我们开始吧！</p><h1 id="4fe2" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">配置和安装依赖项</h1><p id="5885" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">和往常一样，我们从枯燥的部分开始，设置项目并安装依赖项。</p><h2 id="72c1" class="lt kb hu bd kc lu lv lw kg lx ly lz kk jn ma mb ko jr mc md ks jv me mf kw mg dt translated">1.安装无服务器框架</h2><p id="6c77" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">为了让无服务器开发<strong class="je hv">不</strong>成为绝对的折磨，继续安装<a class="ae ls" href="https://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>。</p><pre class="mh mi mj mk fq ml mm mn mo aw mp dt"><span id="3e74" class="lt kb hu mm b fv mq mr l ms mt">$ npm i -g serverless</span></pre><p id="4985" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注意:</strong> <em class="ld">如果您使用的是Linux或Mac，您可能需要以</em> <code class="eh mu mv mw mm b"><em class="ld">sudo</em></code> <em class="ld">的身份运行该命令。</em></p><p id="7ada" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦全局安装到您的机器上，您就可以在终端的任何地方使用这些命令。但是为了让它与您的AWS帐户通信，您需要配置一个IAM用户。跳过<a class="ae ls" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users_create.html" rel="noopener ugc nofollow" target="_blank">这里的解释</a>，然后返回并使用提供的键运行下面的命令。</p><pre class="mh mi mj mk fq ml mm mn mo aw mp dt"><span id="b404" class="lt kb hu mm b fv mq mr l ms mt">$ serverless config credentials \  <br/>    --provider aws \  <br/>    --key xxxxxxxxxxxxxx \  <br/>    --secret xxxxxxxxxxxxxx</span></pre><p id="8ee3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，当您运行任何终端命令时，您的无服务器安装知道要连接到哪个帐户。让我们来看看它是如何工作的。</p><h2 id="d453" class="lt kb hu bd kc lu lv lw kg lx ly lz kk jn ma mb ko jr mc md ks jv me mf kw mg dt translated">2.创建服务</h2><p id="386b" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">创建一个新目录来存放您的无服务器应用程序服务。在那里启动一个终端。现在您已经准备好创建一个新的服务了。</p><p id="91db" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你问的服务是什么？将其视为一个项目。但也不尽然。在这里定义AWS Lambda函数、触发它们的事件以及它们需要的任何AWS基础设施资源，所有这些都在一个名为<strong class="je hv"> serverless.yml </strong>的文件中。</p><p id="be0e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">回到您的终端，键入:</p><pre class="mh mi mj mk fq ml mm mn mo aw mp dt"><span id="d144" class="lt kb hu mm b fv mq mr l ms mt">$ serverless create --template aws-nodejs --path ssr-react-next</span></pre><p id="e90d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">create命令将创建一个新的<strong class="je hv">服务</strong>。修卡！但有趣的部分来了。我们需要为函数选择一个运行时。这被称为<strong class="je hv">模板</strong>。传入<code class="eh mu mv mw mm b">aws-nodejs</code>会将运行时设置为Node.js .这正是我们想要的。<strong class="je hv">路径</strong>将为服务创建一个文件夹。</p><h2 id="c19e" class="lt kb hu bd kc lu lv lw kg lx ly lz kk jn ma mb ko jr mc md ks jv me mf kw mg dt translated">3.安装npm模块</h2><p id="25c0" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">在您的终端中切换到<strong class="je hv"> ssr-react-next </strong>文件夹。这里应该有三个文件，但是现在，让我们首先初始化npm。</p><pre class="mh mi mj mk fq ml mm mn mo aw mp dt"><span id="37c6" class="lt kb hu mm b fv mq mr l ms mt">$ npm init -y</span></pre><p id="837c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在创建了<code class="eh mu mv mw mm b">package.json</code>文件之后，您可以安装一些依赖项。</p><pre class="mh mi mj mk fq ml mm mn mo aw mp dt"><span id="42ea" class="lt kb hu mm b fv mq mr l ms mt">$ npm i \<br/>    axios \<br/>    express \<br/>    serverless-http \<br/>    serverless-apigw-binary \<br/>    next \<br/>    react \<br/>    react-dom \<br/>    path-match \<br/>    url \<br/>    serverless-domain-manager</span></pre><p id="fa1f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些是我们的生产依赖项，我将更详细地解释它们的作用。最后一个叫做<code class="eh mu mv mw mm b">serverless-domain-manager</code>，它将让我们把一个域绑定到我们的端点。太棒了。</p><p id="f43d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，你的<code class="eh mu mv mw mm b">package.json</code>应该看起来像这样。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="6be9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们还需要添加两个脚本，一个用于构建，一个用于部署应用程序。你可以在<code class="eh mu mv mw mm b">package.json</code>的<code class="eh mu mv mw mm b">scripts</code>区看到它们。</p><h2 id="982a" class="lt kb hu bd kc lu lv lw kg lx ly lz kk jn ma mb ko jr mc md ks jv me mf kw mg dt translated">4.配置serverless.yml文件</h2><p id="c044" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">接下来，让我们最终在代码编辑器中打开项目。检查<strong class="je hv"> serverless.yml </strong>文件，它包含此服务的所有配置设置。您可以在这里指定常规配置设置和每个功能的设置。您的<strong class="je hv"> serverless.yml </strong>将充满样板代码和注释。请随意删除它，并粘贴这个。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="2522" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mu mv mw mm b">functions</code>属性列出了服务中的所有函数。我们只需要一个函数，因为它将运行下一个应用程序并呈现React页面。它的工作原理是旋转一个微型Express服务器，在Express路由器旁边运行下一个渲染器，并将服务器传递给<strong class="je hv">无服务器http </strong>模块。</p><p id="a4ce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">反过来，这将把整个Express应用捆绑到一个lambda函数中，并将其绑定到一个API网关端点。在functions属性下，您可以看到一个<strong class="je hv">服务器</strong>函数，它在<code class="eh mu mv mw mm b">index.js</code>文件中有一个名为<code class="eh mu mv mw mm b">server</code>的处理程序。API Gateway会将所有请求代理到内部的Express路由器，然后它会告诉Next呈现React.js页面。哇，听起来很复杂！但其实真的不是。一旦我们开始写代码，你会看到它是多么简单。</p><p id="8b6b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们还添加了两个插件，一个是让更多mime类型通过API网关的<code class="eh mu mv mw mm b">serverless-apigw-binary</code>,另一个是让我们毫不费力地将域名连接到端点的<code class="eh mu mv mw mm b">serverless-domain-manager</code>。</p><p id="8baf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们在底部还有一个<code class="eh mu mv mw mm b">custom</code>部分。属性充当了一种将环境变量安全加载到我们的服务中的方式。稍后通过使用<code class="eh mu mv mw mm b">${self:custom.secrets.&lt;environment_var&gt;}</code>来引用它们，实际值保存在一个名为<code class="eh mu mv mw mm b">secrets.json</code>的简单文件中。</p><p id="a192" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除此之外，我们还让API网关二进制插件知道我们想让所有类型通过，并为我们的端点设置一个自定义域。</p><p id="0449" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">配置到此为止，下面添加<code class="eh mu mv mw mm b">secrets.json</code>文件。</p><h2 id="a991" class="lt kb hu bd kc lu lv lw kg lx ly lz kk jn ma mb ko jr mc md ks jv me mf kw mg dt translated">5.添加机密文件</h2><p id="4e86" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">添加一个<code class="eh mu mv mw mm b">secrets.json</code>文件并将其粘贴进去。这将阻止我们向GitHub推送秘密密钥。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="a569" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，只有通过更改这些值，您才能将不同的环境部署到不同的阶段和域。相当酷。</p><h1 id="2225" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">使用无服务器框架和Next.js构建应用程序</h1><p id="a13e" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">为了构建服务器端呈现的React.js应用程序，我们将使用Next.js框架。它让你专注于编写应用程序，而不是担心搜索引擎优化。它的工作原理是在将JavaScript发送给客户端之前对其进行渲染。一旦它被加载到客户端，它将缓存它并从那里提供服务。你必须喜欢它的速度！</p><p id="c824" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们从编写服务器上的Next.js设置开始。</p><h2 id="4814" class="lt kb hu bd kc lu lv lw kg lx ly lz kk jn ma mb ko jr mc md ks jv me mf kw mg dt translated">1.设置Next.js服务器端渲染</h2><p id="d316" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">创建一个名为<strong class="je hv"> server.js </strong>的文件。很直观，我知道。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="adb3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这很简单。我们获取了Express和Next，用<code class="eh mu mv mw mm b">express.static</code>创建了一个静态路由，并将Next将要创建的捆绑JavaScript的目录传递给它。路径是<code class="eh mu mv mw mm b">/_next</code>，它指向<code class="eh mu mv mw mm b">.next</code>文件夹。</p><p id="e577" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们还将设置服务器端路由，并为客户端呈现器添加一个<em class="ld">总括</em>路由。</p><p id="5c79" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，应用程序需要连接到<code class="eh mu mv mw mm b">serverless-http</code>，并作为lambda函数导出。创建一个<code class="eh mu mv mw mm b">index.js</code>文件并粘贴进去。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="f893" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如您所见，我们还需要创建<code class="eh mu mv mw mm b">binaryMimeTypes.js</code>文件来保存我们想要启用的所有mime类型。这只是一个简单的数组，我们将它传递给<code class="eh mu mv mw mm b">serverless-http</code>模块。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="0f58" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">太好了，这就是关于Next.js的设置。让我们跳进客户端代码！</p><h2 id="6802" class="lt kb hu bd kc lu lv lw kg lx ly lz kk jn ma mb ko jr mc md ks jv me mf kw mg dt translated">2.编写客户端React.js</h2><p id="ab7c" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">在项目的根目录下创建三个文件夹，分别命名为<code class="eh mu mv mw mm b">components</code>、<code class="eh mu mv mw mm b">layouts</code>、<code class="eh mu mv mw mm b">pages</code>。进入<code class="eh mu mv mw mm b">layouts</code>文件夹后，创建一个名为<code class="eh mu mv mw mm b">default.js</code>的新文件，并将其粘贴进去。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="87c0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">默认视图将有一个用于动态设置元标记的<code class="eh mu mv mw mm b">&lt;Meta /&gt;</code>组件和一个<code class="eh mu mv mw mm b">&lt;Navbar /&gt;</code>组件。<code class="eh mu mv mw mm b">{ children }</code>将从使用该布局的组件中呈现。</p><p id="8c3c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在再添加两个文件。<code class="eh mu mv mw mm b">components</code>文件夹中的一个<code class="eh mu mv mw mm b">navbar.js</code>和一个<code class="eh mu mv mw mm b">meta.js</code>文件。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="5475" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个非常简单的导航工具，可以用来在一些可爱的狗狗之间导航。一旦我们在<code class="eh mu mv mw mm b">pages</code>文件夹中添加了一些东西，这就有意义了。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="6938" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mu mv mw mm b">meta.js</code>将使我们更容易向meta标签中注入值。现在你可以在<code class="eh mu mv mw mm b">pages</code>文件夹中创建一个<code class="eh mu mv mw mm b">index.js</code>文件。粘贴下面的代码。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="c86f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mu mv mw mm b">index.js</code>文件将呈现在我们的应用程序的根路径上。它调用一个狗API，会显示一个可爱的狗的图片。</p><p id="fe04" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们创建更多的路线。创建一个名为<code class="eh mu mv mw mm b">dogs</code>的子文件夹，并在其中创建一个<code class="eh mu mv mw mm b">index.js</code>文件和一个<code class="eh mu mv mw mm b">_breed.js</code>文件。<code class="eh mu mv mw mm b">index.js</code>将在<code class="eh mu mv mw mm b">/dogs</code>路线渲染，而<code class="eh mu mv mw mm b">_breed.js</code>将在<code class="eh mu mv mw mm b">/dogs/:breed</code>渲染，其中<code class="eh mu mv mw mm b">:breed</code>代表路线参数。</p><p id="5261" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将其添加到<code class="eh mu mv mw mm b">dogs</code>目录中的<code class="eh mu mv mw mm b">index.js</code>中。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="22ac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有，<code class="eh mu mv mw mm b">dogs</code>文件夹中的<code class="eh mu mv mw mm b">_breed.js</code>文件中的另一个片段。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mx my l"/></div></figure><p id="9034" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如你在<code class="eh mu mv mw mm b">Default</code>组件中看到的，我们正在注入定制的元标签。它将在你的页面的<code class="eh mu mv mw mm b">&lt;head&gt;</code>中添加自定义字段，给它适当的SEO支持！</p><p id="7129" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ld">注意</em> </strong> <em class="ld">:如果你卡住了，</em> <a class="ae ls" href="https://github.com/adnanrahic/serverless-side-rendering-react-next" rel="noopener ugc nofollow" target="_blank"> <em class="ld">下面是回购</em> </a> <em class="ld">中代码的样子。</em></p><p id="55cf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们部署它，看看它是否有效。</p><h1 id="ef5f" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">将应用程序部署到AWS Lambda</h1><p id="5e51" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">在最开始的时候，我们给我们的<code class="eh mu mv mw mm b">package.json</code>添加了一个叫做<code class="eh mu mv mw mm b">deploy</code>的脚本。它将构建下一个应用程序，并部署我们在<code class="eh mu mv mw mm b">serverless.yml</code>中指定的无服务器服务。</p><p id="e4c6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你需要做的就是跑:</p><pre class="mh mi mj mk fq ml mm mn mo aw mp dt"><span id="20f8" class="lt kb hu mm b fv mq mr l ms mt">$ npm run deploy</span></pre><p id="d394" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">终端将为您的应用程序返回带有端点的输出。我们还需要添加域以使其正常工作。我们已经在<code class="eh mu mv mw mm b">serverless.yml</code>中添加了配置，但是我们还需要运行一个命令。</p><pre class="mh mi mj mk fq ml mm mn mo aw mp dt"><span id="5134" class="lt kb hu mm b fv mq mr l ms mt">$ sls create_domain</span></pre><p id="57fa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将创建一个CloudFront发行版，并将其连接到您的域。确保您已将证书添加到AWS帐户。AWS通常需要大约20分钟来提供一个新的发行版。让你的眼睛休息一会儿。</p><p id="c3c4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦你回来了，继续部署它。</p><pre class="mh mi mj mk fq ml mm mn mo aw mp dt"><span id="78c1" class="lt kb hu mm b fv mq mr l ms mt">$ npm run deploy</span></pre><p id="3db8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在它应该被绑定到您的域。它应该是这样的。</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mz"><img src="../Images/a805977aa01fee85a3308fef12dcbddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HaS-RZkMplATqE1nqCk5Tw.png"/></div></div></figure><p id="f784" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不错！该应用程序已启动并运行。去试试吧。</p><h1 id="6bef" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">包扎</h1><p id="5419" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">这个演练是情感的过山车！它给你一个新的视角来创建快速和高性能的单页应用程序，同时保持服务器端应用程序的SEO功能。然而，有了一个条件。没有你需要担心的服务器。这一切都运行在AWS Lambda的无服务器环境中。它易于部署和自动扩展。不会变得更好。</p><p id="98e9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你在某个地方卡住了，看看<a class="ae ls" href="https://github.com/adnanrahic/serverless-side-rendering-react-next" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>做进一步参考，如果你想让更多人在GitHub上看到它，请随意给它打个星。</p><p id="5ae7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想阅读我以前的一些无服务器沉思，请前往<a class="ae ls" rel="noopener" href="/@adnanrahic">我的简介</a>或<a class="ae ls" href="https://upscri.be/b6f3d5/" rel="noopener ugc nofollow" target="_blank">加入我的时事通讯！</a></p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="na my l"/></div></figure><p id="a216" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者，马上看看我的几篇文章:</p><ul class=""><li id="ba41" class="le lf hu je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated"><a class="ae ls" href="https://hackernoon.com/a-crash-course-on-serverless-with-aws-building-apis-with-lambda-and-aurora-serverless-49885c46e37a" rel="noopener ugc nofollow" target="_blank">AWS无服务器速成班——用Lambda和Aurora无服务器构建APIs】</a></li><li id="e8cd" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ls" href="https://hackernoon.com/a-crash-course-on-serverless-with-aws-image-resize-on-the-fly-with-lambda-and-s3-850be95d5833" rel="noopener ugc nofollow" target="_blank">AWS无服务器速成班——使用Lambda和S3动态调整图像大小</a></li><li id="6d0b" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ls" href="https://hackernoon.com/a-crash-course-on-serverless-with-aws-triggering-lambda-with-sns-messaging-bc17d9f81ca2" rel="noopener ugc nofollow" target="_blank">AWS无服务器速成班SNS消息触发Lambda</a></li><li id="9215" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ls" href="https://hackernoon.com/a-crash-course-on-serverless-side-rendering-with-vue-js-nuxt-js-and-aws-lambda-fbfaad80aa25" rel="noopener ugc nofollow" target="_blank">关于使用Vue.js、Nuxt.js和AWS Lambda进行无服务器端渲染的速成课程</a></li><li id="9b5c" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ls" href="https://hackernoon.com/building-a-serverless-contact-form-with-aws-lambda-and-aws-ses-fbf01d523678" rel="noopener ugc nofollow" target="_blank">使用AWS Lambda和AWS SES构建无服务器联系表单</a></li><li id="05cd" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ls" href="https://hackernoon.com/a-crash-course-on-serverless-apis-with-express-and-mongodb-77774f7730fe" rel="noopener ugc nofollow" target="_blank">Express和MongoDB的无服务器API速成班</a></li><li id="bb6f" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ls" href="https://hackernoon.com/solving-invisible-scaling-issues-with-serverless-and-mongodb-1a065b5a6465" rel="noopener ugc nofollow" target="_blank">使用Serverless和MongoDB解决不可见的伸缩问题</a></li><li id="a60d" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ls" href="https://dev.to/adnanrahic/how-to-deploy-a-nodejs-application-to-aws-lambda-using-serverless-2nc7" rel="noopener ugc nofollow" target="_blank">如何使用无服务器将Node.js应用程序部署到AWS Lambda</a></li><li id="68fa" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ls" href="https://hackernoon.com/getting-started-with-aws-lambda-and-node-js-4ce3259c6dfd" rel="noopener ugc nofollow" target="_blank">AWS Lambda和Node.js入门</a></li><li id="01e2" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ls" href="https://medium.freecodecamp.org/a-crash-course-on-securing-serverless-apis-with-json-web-tokens-ff657ab2f5a5" rel="noopener ugc nofollow" target="_blank">用JSON web令牌保护无服务器API的速成班</a></li><li id="c885" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ls" href="https://hackernoon.com/migrating-your-node-js-rest-api-to-serverless-d2a170e0856c" rel="noopener ugc nofollow" target="_blank">将Node.js REST API迁移到无服务器</a></li><li id="faa6" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ls" href="https://hackernoon.com/building-a-serverless-rest-api-with-node-js-and-mongodb-2e0ed0638f47" rel="noopener ugc nofollow" target="_blank">用Node.js和MongoDB构建无服务器REST API</a></li><li id="01b6" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ls" href="https://hackernoon.com/a-crash-course-on-serverless-with-node-js-632b37d58b44" rel="noopener ugc nofollow" target="_blank">node . js无服务器速成班</a></li></ul><p id="1194" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我也强烈推荐查看<a class="ae ls" href="https://blog.logrocket.com/how-to-build-a-server-rendered-react-app-with-next-express-d5a389e7ab2f" rel="noopener ugc nofollow" target="_blank">这篇关于Next.js的文章</a>，以及<a class="ae ls" href="https://serverless.com/blog/serverless-api-gateway-domain/" rel="noopener ugc nofollow" target="_blank">这篇关于无服务器域管理器的教程</a>。</p><p id="78f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">希望你们喜欢读这篇文章，就像我喜欢写这篇文章一样。如果你喜欢，拍一下那个小小的拍手，这样HackerNoon上的更多人会看到这个教程。下次见，保持好奇，玩得开心。</p></div><div class="ab cl nb nc hc nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="hn ho hp hq hr"><p id="8c44" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ld">原载于</em><a class="ae ls" href="https://dev.to/adnanrahic/a-crash-course-on-serverless-side-rendering-with-reactjs-nextjs-and-aws-lambda-13ed" rel="noopener ugc nofollow" target="_blank"><em class="ld">dev . to</em></a><em class="ld">。</em></p></div></div>    
</body>
</html>