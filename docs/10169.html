<html>
<head>
<title>How I built a Telegram Reminder Bot with Node JS, the IBM Watson API and Firebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何用Node JS、IBM Watson API和Firebase构建了一个电报提醒机器人</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-i-built-a-telegram-reminder-bot-with-node-js-the-ibm-watson-api-and-firebase-7128c778e3d7?source=collection_archive---------3-----------------------#2018-12-18">https://medium.com/hackernoon/how-i-built-a-telegram-reminder-bot-with-node-js-the-ibm-watson-api-and-firebase-7128c778e3d7?source=collection_archive---------3-----------------------#2018-12-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/48147c6ed3b1bd9d93b71cdbe33796f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h89l_KJR8w2NrzQXtPCAmw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/R4WCbazrD1g?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Rock’n Roll Monkey</a> on <a class="ae jg" href="https://unsplash.com/search/photos/bot?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fe24" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">目录</strong></p><ol class=""><li id="4e45" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">介绍</li><li id="15d9" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">先决条件</li><li id="e3f8" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">用节点JS创建bot</li><li id="e7e4" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">将机器人连接到实时数据库(Firebase)</li><li id="248e" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">运行Cron作业</li><li id="d6f4" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">连接到IBM Watson API的脚本</li><li id="6cc8" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">部署到故障</li><li id="7289" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">结论</li></ol></div><div class="ab cl kt ku hc kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hn ho hp hq hr"><h1 id="f806" class="la lb hu bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx dt translated">介绍</h1><p id="e65d" class="pw-post-body-paragraph jh ji hu jj b jk ly jm jn jo lz jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">这个电报机器人只需要三个命令。</p><ul class=""><li id="de94" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke md kl km kn dt translated">/start —初始化我们的bot。</li><li id="6777" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke md kl km kn dt translated">/save —保存我们希望以后提醒的字符串。</li><li id="359f" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke md kl km kn dt translated">/time —节省我们希望执行此任务的时间。</li></ul><p id="92a0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，将这些数据保存到firebase，并初始化一个cron作业，该作业将在设定的时间运行。这个cron作业向用户发送文本提醒，然后使用文本到语音IBM Watson API将其转换为音频文件，并发送给用户。</p><h1 id="cea0" class="la lb hu bd lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx dt translated">先决条件</h1><ul class=""><li id="b3de" class="kf kg hu jj b jk ly jo lz js mj jw mk ka ml ke md kl km kn dt translated">一个电报机器人，这个机器人可以通过向电报上的<a class="ae jg" href="https://web.telegram.org/#/im?p=@BotFather" rel="noopener ugc nofollow" target="_blank">机器人父亲</a>账户发送“/开始”消息来创建。还应该获得bot令牌。</li><li id="d8eb" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke md kl km kn dt translated">一个<a class="ae jg" href="https://idaas.iam.ibm.com" rel="noopener ugc nofollow" target="_blank"> IBM沃森</a>账户(免费)。</li><li id="9b7f" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke md kl km kn dt translated">一个实时数据库，<a class="ae jg" href="https://firebase.google.com/" rel="noopener ugc nofollow" target="_blank"> firebase / firestore </a>。</li><li id="9e85" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke md kl km kn dt translated">一个<a class="ae jg" href="https://glitch.com/" rel="noopener ugc nofollow" target="_blank"> Glitch账号</a>，正好需要你的Github账号。</li><li id="2ecf" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke md kl km kn dt translated">一点点regex和bash(没什么好担心的)。</li></ul><h1 id="e1a5" class="la lb hu bd lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx dt translated">用节点JS创建一个bot</h1><p id="cee3" class="pw-post-body-paragraph jh ji hu jj b jk ly jm jn jo lz jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">好的，首先，我们需要安装我们需要的模块。因此，从我们的目录中，我们将在终端中运行:</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="6f75" class="mv lb hu mr b fv mw mx l my mz">$ mkdir telegramBot &amp;&amp; cd telegramBot<br/>$ npm init<br/>$ npm install node-telegram-bot-api node-cron firebase-admin shelljs</span></pre><p id="9c15" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将使用<strong class="jj hv">节点电报机器人api </strong>作为包装器。首先，我们将在我们的目录中创建一个<strong class="jj hv"> index.js </strong>文件。我们将在index.js文件中添加以下几行:</p><figure class="mm mn mo mp fq iv"><div class="bz el l di"><div class="na nb l"/></div></figure><p id="b987" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，我们用从机器人父亲帐户获得的令牌初始化机器人。第6行的轮询选项保持机器人和用户之间的通道活动。这是一个网络插座的事情。我们还声明了一个提醒变量，它保存我们希望被提醒的内容。</p><h1 id="0f49" class="la lb hu bd lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx dt translated">/开始</h1><p id="a48b" class="pw-post-body-paragraph jh ji hu jj b jk ly jm jn jo lz jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">然后，当用户输入“/start”命令时，我们将让服务器监听。因此，我们将在index.js文件中添加一个<strong class="jj hv"> onText </strong>监听器。</p><figure class="mm mn mo mp fq iv"><div class="bz el l di"><div class="na nb l"/></div></figure><p id="e9ce" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它侦听“/start”命令何时被传递，然后用一个包含“msg”对象的回调来响应，该对象包含聊天id、用户名等。</p><p id="657f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当这个条件被满足时，机器人向聊天id发送消息，询问用户，他希望被提醒什么。所以我们完成了第一个命令！</p><h1 id="4d37" class="la lb hu bd lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx dt translated">/保存</h1><p id="73d7" class="pw-post-body-paragraph jh ji hu jj b jk ly jm jn jo lz jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">这个命令将保存我们想要提醒的内容。传递“/start”命令后，将触发此侦听器。所以我们将通过这个函数，在承诺中返回(。然后)</p><figure class="mm mn mo mp fq iv"><div class="bz el l di"><div class="na nb l"/></div></figure><p id="8144" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以我们听当了。/save ',然后回调中的' match '变量返回一个包含匹配内容的数组。</p><p id="2cfc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果用户输入<strong class="jj hv"><em class="nc">/保存‘洗我的衣服’</em></strong>，那么‘洗我的衣服’字符串将具有数组中的第一个索引，即['/保存‘洗我的衣服’，‘洗我的衣服']。当这个被获取并保存后，我们就发送一条消息来询问时间。我们完成了第二个命令！</p><h1 id="6e65" class="la lb hu bd lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx dt translated">/时间</h1><p id="d56b" class="pw-post-body-paragraph jh ji hu jj b jk ly jm jn jo lz jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">现在，我们将节省时间。这应该输入到save命令的承诺链中。我们希望保存格式为<strong class="jj hv"> HH:MM:SS:(AM或PM) </strong>的命令。所以我们的时间函数应该是这样的:</p><figure class="mm mn mo mp fq iv"><div class="bz el l di"><div class="na nb l"/></div></figure><p id="7b43" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以正则表达式匹配格式，然后我们通过拆分匹配响应得到时间。匹配变量如下所示:</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="7625" class="mv lb hu mr b fv mw mx l my mz">[ '/time 06:33:33:PM',<br/>  '06',<br/>  '33:33',<br/>  'PM',<br/>  index: 0,<br/>  input: '/time 06:33:33:PM' ]</span></pre><p id="5ca3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以拆分数组中的第一项，我们得到<strong class="jj hv"> 06:33:33:PM </strong>，然后我们发送一条感谢消息。但是我们的机器人实际上并没有保存用户的请求，当然也没有提醒用户。所以我们需要解决这个问题。</p><p id="0e7b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这个阶段，我们的index.js文件应该如下所示:</p><figure class="mm mn mo mp fq iv"><div class="bz el l di"><div class="na nb l"/></div></figure><p id="4165" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们与机器人的交互应该是这样的:</p><figure class="mm mn mo mp fq iv fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/05d72a32fdcb86c505ed17f13895277d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*t3gr-2LSy6gjJ_VwWHZFrA.png"/></div></figure><h1 id="e9ea" class="la lb hu bd lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx dt translated">将机器人连接到实时数据库(Firebase)</h1><p id="ec5d" class="pw-post-body-paragraph jh ji hu jj b jk ly jm jn jo lz jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">现在，我们将在目录的根目录下创建一个<strong class="jj hv"> database.js </strong>文件，它将处理我们到firestore db的连接。我们的database.js文件应该如下所示:</p><figure class="mm mn mo mp fq iv"><div class="bz el l di"><div class="na nb l"/></div></figure><p id="05c8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我们可以在index.js文件的顶部导入database.js文件。</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="8e0b" class="mv lb hu mr b fv mw mx l my mz">const db = require('./database').database;</span></pre><p id="3fd9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们还想用用户的聊天名保存用户的请求，但是如果用户不止一次请求，就会是重复的。因此，我们可以在firestore上存储的每个文档中附加一个随机字符串。为此，我们将在我们的根目录下创建一个<strong class="jj hv"> helper.js </strong>文件，它看起来像这样:</p><figure class="mm mn mo mp fq iv"><div class="bz el l di"><div class="na nb l"/></div></figure><p id="ba97" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这将返回我们传递的任意长度的字符串。我们也可以在index.js文件的顶部导入这个文件。</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="9077" class="mv lb hu mr b fv mw mx l my mz">const generator = require('./helper');</span></pre><p id="023e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，我们将返回到处理我们的<strong class="jj hv"> <em class="nc"> /time </em> </strong>命令的函数，然后在发送“谢谢”回复之前，我们添加以下内容:</p><figure class="mm mn mo mp fq iv"><div class="bz el l di"><div class="na nb l"/></div></figure><p id="09b1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最初，我在我的数据库上创建了一个名为“提醒”的集合。然后我使用<strong class="jj hv"> <em class="nc">传递有效载荷。将</em> </strong>命令设置为集合。现在，有一个<strong class="jj hv"> hasUserBeenReminded </strong>键，帮助我们跟踪用户是否被提醒了某项任务。</p><p id="dc19" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们再次与我们的bot交互，在运行了<strong class="jj hv"> <em class="nc"> /time </em> </strong>命令之后，我们的db应该是这样的:</p><figure class="mm mn mo mp fq iv fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/c99ecdbbee4f29b96b606f6dac4fcdd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*MmqNgTHj3m4l4yaEE9l2Jg.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">firestore db</figcaption></figure><p id="3055" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果工作正常，我们就可以运行一个cron作业，在设定的时间提醒用户。我们可以在index.js文件的顶部添加依赖关系。</p><h1 id="28f6" class="la lb hu bd lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx dt translated">运行Cron作业</h1><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="a6bf" class="mv lb hu mr b fv mw mx l my mz">const cron = require("node-cron");</span></pre><p id="0330" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后，我们可以继续听我们的<strong class="jj hv"> <em class="nc"> /time </em> </strong>命令的功能。</p><figure class="mm mn mo mp fq iv"><div class="bz el l di"><div class="na nb l"/></div></figure><p id="0efc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以我们基本上是获取用户希望被提醒某个任务的小时和分钟，然后用cron依赖关系来调度它。通常，cron调度程序有一个模式:</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="847c" class="mv lb hu mr b fv mw mx l my mz"><strong class="mr hv">* * * * * *</strong></span></pre><p id="7eba" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这些星号分别代表秒(可选)、分钟、小时、日、月和年。所以我们忽略了第二个选项，选择了小时和分钟。到时间了，事件被触发，提醒被发送，<strong class="jj hv"> hasUserBeenReminded </strong>键也被设置为true。</p><figure class="mm mn mo mp fq iv fe ff paragraph-image"><div class="fe ff nf"><img src="../Images/0ed8186e0caa8f2b7cc79a26c57b5cfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*mhYOHFBPCYB_a16RD0pM-Q.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">We should have a message like this, when the time comes.</figcaption></figure><h1 id="3bb3" class="la lb hu bd lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx dt translated">连接到IBM Watson API的脚本</h1><p id="6f35" class="pw-post-body-paragraph jh ji hu jj b jk ly jm jn jo lz jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">我们还希望机器人发送一个语音提示我们的提醒。类似于<strong class="jj hv"> <em class="nc">【洗衣服】</em> </strong>这样的就可以了。为此，我们将使用IBM Watson API上的文本到语音服务。这将把文件转换成我们想要的格式的音频文件(电报接受<strong class="jj hv">)。ogg </strong>格式)<strong class="jj hv"> </strong>然后上传。</p><p id="c260" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为此，我们将编写一个简单的shell脚本。我们将该文件命名为textToAudio.sh，它应该是这样的:</p><figure class="mm mn mo mp fq iv"><div class="bz el l di"><div class="na nb l"/></div></figure><p id="e2ee" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当命令运行时，“$1”获取第一个参数。这将是我们的文本。然后如果参数不为空，用curl做一个post请求，否则显示一个字符串<strong class="jj hv"><em class="nc">‘无参数’</em></strong>。如果运行成功，输出<strong class="jj hv"><em class="nc">reminders ss . ogg</em></strong>将被添加到根目录。</p><p id="f9ab" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以在终端中用sh命令运行它，但是要在node中运行它，我们需要在index.js文件的顶部添加一个依赖项。</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="a61d" class="mv lb hu mr b fv mw mx l my mz">const shell = require('shelljs')</span></pre><p id="d088" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以现在，我们将使用<strong class="jj hv"> <em class="nc"> shell.exec </em> </strong>命令运行这个命令，然后第一个参数将是我们希望被提醒的内容。</p><figure class="mm mn mo mp fq iv"><div class="bz el l di"><div class="na nb l"/></div></figure><p id="3c9d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这将执行shell脚本，然后将提醒作为第一个参数传递。然后我们把音频发给用户！</p><p id="5777" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们与电报机器人的交互现在应该是这样的:</p><figure class="mm mn mo mp fq iv fe ff paragraph-image"><div class="fe ff ng"><img src="../Images/eefc95a8d3b29ca9b526218d4ecadb66.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*VKd2nLnk6V-jIAjbfZVmaA.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Audio file sent</figcaption></figure><h1 id="dee2" class="la lb hu bd lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx dt translated">部署到故障</h1><p id="20ff" class="pw-post-body-paragraph jh ji hu jj b jk ly jm jn jo lz jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">好吧，这真的只是即插即用。在glitch上创建一个项目后，只需将代码复制并粘贴到那里，就可以开始了。</p><h1 id="312f" class="la lb hu bd lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt mi lv lw lx dt translated">结论</h1><p id="761c" class="pw-post-body-paragraph jh ji hu jj b jk ly jm jn jo lz jq jr js ma ju jv jw mb jy jz ka mc kc kd ke hn dt translated">这个项目仍然有许多不完善的地方，其中之一就是排队，因为它一次只处理一个请求。如果你需要澄清，有一个<a class="ae jg" href="https://github.com/obbap1/telegram_bot" rel="noopener ugc nofollow" target="_blank">存储库</a>可以提供。</p><p id="d5f9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">非常感谢你的阅读，如果你喜欢，请鼓掌。如有任何问题或需要进一步澄清，可以留言或发邮件(paschalobba@yahoo.com)。</p></div></div>    
</body>
</html>