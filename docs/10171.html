<html>
<head>
<title>Creating a Python Ethereum Interface: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建Python以太坊接口:第1部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/creating-a-python-ethereum-interface-part-1-4d2e47ea0f4d?source=collection_archive---------5-----------------------#2018-12-18">https://medium.com/hackernoon/creating-a-python-ethereum-interface-part-1-4d2e47ea0f4d?source=collection_archive---------5-----------------------#2018-12-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/98e5e81abaad6c1ba4db9ced1afccb6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yMp3qTO1wsLUlLbuL0Qq6g.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/REZp_5-2wzA?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Leonel Fernandez</a> on <a class="ae jg" href="https://unsplash.com/search/photos/buttons?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6574" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt kf translated">来自Python背景的我最初有点沮丧地发现缺少使用Python与以太坊区块链交互的教程。然而，在阅读了<a class="ko kp gr" href="https://medium.com/u/98948c525eb6?source=post_page-----4d2e47ea0f4d--------------------------------" rel="noopener" target="_blank"> Nick Williams </a>(优秀)<a class="ae jg" href="https://hackernoon.com/ethereum-smart-contracts-in-python-a-comprehensive-ish-guide-771b03990988" rel="noopener ugc nofollow" target="_blank"> guide </a>并好好看看以太坊自己的<a class="ae jg" href="https://web3py.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank"> web3.py </a>的丰富功能集后，我决心写点自己的东西。我想要一种简洁的方式来编译、部署和交互来自Python的契约。我最终编写了一个方便的接口，它收集并抽象了许多web3.py方法，因此可以很容易地导入到不同的Python模块中。</p><p id="777b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我先介绍一下Python、Solidity和以太坊区块链的工作知识。我还建议您尝试阅读Nick的上述指南，并浏览web3.py。另一个很好的资源是Python / Ethereum生态系统的<a class="ae jg" rel="noopener" href="/@pipermerriam/the-python-ethereum-ecosystem-101bd9ba4de7">概述</a>，它总结了<a class="ko kp gr" href="https://medium.com/u/8bb8b999b3b8?source=post_page-----4d2e47ea0f4d--------------------------------" rel="noopener" target="_blank"> Piper Merriam </a>、<a class="ko kp gr" href="https://medium.com/u/d9a8ea9bbef6?source=post_page-----4d2e47ea0f4d--------------------------------" rel="noopener" target="_blank"> Jason Carver </a>和其他人在这个领域的惊人工作。</p><p id="72bf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们开始之前，首先需要在您的系统上设置一些要求:</p><ul class=""><li id="216c" class="kq kr hu jj b jk jl jo jp js ks jw kt ka ku ke kv kw kx ky dt translated"><a class="ae jg" rel="noopener" href="/@richardkall/installing-node-js-using-node-version-manager-nvm-c21546a613bc">节点/npm </a></li><li id="cbb6" class="kq kr hu jj b jk kz jo la js lb jw lc ka ld ke kv kw kx ky dt translated">python2/pip(需要在下面构建ganache-cli)</li><li id="7e69" class="kq kr hu jj b jk kz jo la js lb jw lc ka ld ke kv kw kx ky dt translated">python3/pip3</li><li id="f9ad" class="kq kr hu jj b jk kz jo la js lb jw lc ka ld ke kv kw kx ky dt translated"><a class="ae jg" href="https://solidity.readthedocs.io/en/latest/installing-solidity.html" rel="noopener ugc nofollow" target="_blank"> solc </a>，solidity编译器(<strong class="jj hv">不是</strong>来自npm的solc-js)</li><li id="6941" class="kq kr hu jj b jk kz jo la js lb jw lc ka ld ke kv kw kx ky dt translated"><a class="ae jg" href="https://web3py.readthedocs.io/en/stable/quickstart.html" rel="noopener ugc nofollow" target="_blank"> web3-py </a></li><li id="671f" class="kq kr hu jj b jk kz jo la js lb jw lc ka ld ke kv kw kx ky dt translated">加纳切-cli ，我们的发展区块链</li><li id="d7a0" class="kq kr hu jj b jk kz jo la js lb jw lc ka ld ke kv kw kx ky dt translated"><a class="ae jg" href="https://pypi.org/project/py-solc-x/" rel="noopener ugc nofollow" target="_blank"> py-solc-x </a></li></ul><p id="260d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请按照上面的链接获取安装说明。还要注意的是，py-solc-x是Solc v0.5.x官方回购的一个分支。就像你放在机器上的任何软件一样，不要只相信我的话，它是安全和有效的！我鼓励你做你自己的尽职调查，因为我不维护上述包。</p><p id="9958" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我还想先说一句，我的所有东西都是在Ubuntu上写的，如果你在Windows或OS X上遇到问题，我会尽我所能帮助你。H <em class="le">然而，</em>如果你想在<a class="ae jg" href="https://www.vagrantup.com/" rel="noopener ugc nofollow" target="_blank">流浪者</a>或<a class="ae jg" href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" rel="noopener ugc nofollow" target="_blank"> WSL </a>中启动一个新的Ubuntu虚拟机，我也有一个可爱的<a class="ae jg" href="https://github.com/pryce-turner/web3_python_tutorials/blob/master/provision_vm.sh" rel="noopener ugc nofollow" target="_blank">配置脚本</a>。</p></div><div class="ab cl lf lg hc lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hn ho hp hq hr"><h1 id="6ad3" class="lm ln hu bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj dt translated">设置</h1><p id="b8fd" class="pw-post-body-paragraph jh ji hu jj b jk mk jm jn jo ml jq jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">让我们开始吧。继续在一个新目录中打开一个终端和<code class="eh mp mq mr ms b">git clone</code>项目<a class="ae jg" href="https://github.com/pryce-turner/web3_python_tutorials.git" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="8eea" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我使用的契约是无处不在的“欢迎者”契约，带有继承的访问控制契约。然而，该界面被设计为与合同无关，所以如果您正在进行自己的项目，请随意跟进。我们将使用python包装的solc编译器来编译我们的契约，使用web3.py来与区块链交互。我使用ganache-cli开发了这个工具——理论上它应该适用于任何客户端，但是我还没有对它们进行测试。</p><p id="65a3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在单独的选项卡或终端窗口中，使用<code class="eh mp mq mr ms b">ganache-cli</code>命令启动ganache。您应该会看到类似下面这样的输出:</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="9d15" class="nb ln hu ms b fv nc nd l ne nf">Ganache CLI v6.1.8 (ganache-core: 2.2.1)</span><span id="05f5" class="nb ln hu ms b fv ng nd l ne nf">Available Accounts<br/>==================<br/>(0) 0xf52cef744ccdd52e66856057d820d2b6677af63c (~100 ETH)<br/>(1) 0x6be3a04dcce9d82bf36b71b20831553e6d9e154e (~100 ETH)<br/>(2) 0xd9b6e69094f7ed37eaa724b9c0141a269513fdcf (~100 ETH)<br/>(3) 0xc9ec9a79be055bbaf88dd2ebefd4d0d6230a30de (~100 ETH)<br/>...</span></pre><p id="d27e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，打开<code class="eh mp mq mr ms b">walkthrough.py</code>,在文件顶部设置你的导入文件:</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="1b1c" class="nb ln hu ms b fv nc nd l ne nf">import os<br/>from web3 import Web3, HTTPProvider<br/>from interface import ContractInterface</span></pre><p id="15c5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这将从web3.py库中导入一些方法，并从interface.py中导入ContractInterface类。</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="87ba" class="nb ln hu ms b fv nc nd l ne nf">w3 = Web3(HTTPProvider('http://127.0.0.1:8545'))</span></pre><p id="9342" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这些是ganache的默认主机和端口。现在，您可以通过python与您的节点进行交互。在python解释器中随意运行上述命令，比如:</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="e13c" class="nb ln hu ms b fv nc nd l ne nf">&gt;&gt;&gt; from web3 import Web3, HTTPProvider<br/>&gt;&gt;&gt; w3 = Web3(HTTPProvider('http://127.0.0.1:8545'))<br/>&gt;&gt;&gt; w3.eth.accounts[0] #should return:<br/>&gt;&gt;&gt; 0xf52cef744ccdd52e66856057d820d2b6677af63c #account 0 from above</span></pre><p id="539d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="le">俏皮。</em></p><p id="4f5a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在下一行中，设置存放合同的path变量，如果您只是使用包含的合同，将如下所示:</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="3848" class="nb ln hu ms b fv nc nd l ne nf">contract_dir = os.path.abspath('./contracts/')</span></pre><p id="3be7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，您需要创建一个接口实例，包括:</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="a7d1" class="nb ln hu ms b fv nc nd l ne nf">greeter_interface = ContractInterface(w3, 'Greeter', contract_dir)</span></pre><p id="3fdf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里是你希望为其创建界面的合同的名称。因为Greeter.sol继承自Owned.sol，所以您可以从Greeter接口访问Owned中的所有方法。</p><p id="bdc0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们用下面的代码简单地运行一下<code class="eh mp mq mr ms b">walkthrough.py</code>,以确保我们在初始化时不会出现任何错误:</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="effc" class="nb ln hu ms b fv nc nd l ne nf">python3 -i walkthrough.py<br/>&gt;&gt;&gt; type(greeter_interface)</span></pre><p id="6ddc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">应返回<code class="eh mp mq mr ms b">&lt;class 'interface.ContractInterface'&gt;</code></p><p id="bc75" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此外，如果您需要任何接口方法的快速参考，您可以运行<code class="eh mp mq mr ms b">&gt;&gt;&gt; help(ContractInterface)</code>获得docstring输出。</p></div><div class="ab cl lf lg hc lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hn ho hp hq hr"><h1 id="9b98" class="lm ln hu bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj dt translated">编制</h1><p id="42bd" class="pw-post-body-paragraph jh ji hu jj b jk mk jm jn jo ml jq jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">Solc对于编译没有显式传递的依赖项非常严格(这是正确的)。使用Truffle时，一切都编译得很好，但是Solc做了一些修改。如果您正在导入合同，请确保在您的<code class="eh mp mq mr ms b">pragma</code>下方使用这个特定的格式<code class="eh mp mq mr ms b">import "./contract.sol";</code>。编译器应该负责剩下的工作。继续将以下内容添加到<code class="eh mp mq mr ms b">walkthrough.py</code>:</p><p id="b84b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh mp mq mr ms b">greeter_interface.compile_source_files()</code></p><p id="fc6f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此时，<code class="eh mp mq mr ms b">walkthrough</code>应该是什么样子</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="a704" class="nb ln hu ms b fv nc nd l ne nf"># Put your imports here<br/>import os<br/>from interface import ContractInterface<br/>from web3 import HTTPProvider, Web3</span><span id="2a9f" class="nb ln hu ms b fv ng nd l ne nf"># Initialize your web3 object<br/>w3 = Web3(HTTPProvider('<a class="ae jg" href="http://127.0.0.1:8545'" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8545'</a>))</span><span id="e238" class="nb ln hu ms b fv ng nd l ne nf"># Create a path object to your Solidity source files<br/>contract_dir = os.path.abspath('./contracts/')</span><span id="3619" class="nb ln hu ms b fv ng nd l ne nf"># Initialize your interface<br/>greeter_interface = ContractInterface(w3, 'Greeter', contract_dir)</span><span id="745c" class="nb ln hu ms b fv ng nd l ne nf"># Compile contracts below<br/>greeter_interface.compile_source_files()</span></pre><p id="22f0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们更详细地看看<code class="eh mp mq mr ms b">compile_source_files()</code>方法:</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="ecf4" class="nb ln hu ms b fv nc nd l ne nf">deployment_list = []</span><span id="3fe6" class="nb ln hu ms b fv ng nd l ne nf">for contract in os.listdir(self.contract_directory):<br/>    deployment_list.append(<br/>        os.path.join(self.contract_directory,  contract)<br/>    )</span><span id="a71a" class="nb ln hu ms b fv ng nd l ne nf">self.all_compiled_contracts = compile_files(deployment_list)</span><span id="7145" class="nb ln hu ms b fv ng nd l ne nf">print('Compiled contract keys:\n{}'.format(<br/>        '\n'.join(self.all_compiled_contracts.keys())<br/>    ))</span></pre><p id="3188" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个方法只是创建了一个要传递给py-solc的<code class="eh mp mq mr ms b">compile_files</code>的绝对路径列表。然后，编译器输出被保存到实例属性中，供以后使用。如果您现在运行<code class="eh mp mq mr ms b">walkthrough</code>，您应该会看到编译后的合同密钥打印出来。</p></div><div class="ab cl lf lg hc lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hn ho hp hq hr"><h1 id="8c49" class="lm ln hu bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj dt translated">部署</h1><p id="6c15" class="pw-post-body-paragraph jh ji hu jj b jk mk jm jn jo ml jq jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">让我们用以下代码行将部署方法添加到<code class="eh mp mq mr ms b">walkthrough</code>:</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="9112" class="nb ln hu ms b fv nc nd l ne nf">greeter_interface.deploy_contract()</span></pre><p id="3b82" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此方法首先检查协定是否已编译，如果没有，则使用以下代码重新编译它们:</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="9116" class="nb ln hu ms b fv nc nd l ne nf">try:<br/>    self.all_compiled_contracts is not None<br/>except AttributeError:<br/>    print("Source files not compiled, compiling now and trying again...")<br/>    self.compile_source_files()</span></pre><p id="c372" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">接下来，它将在一个编译器输出键中找到我们之前指定要部署的契约的名称。然后，它使用该契约的应用程序二进制接口(ABI)和字节码(BIN)创建一个部署实例:</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="462e" class="nb ln hu ms b fv nc nd l ne nf">for compiled_contract_key in self.all_compiled_contracts.keys():<br/>    if self.contract_to_deploy in compiled_contract_key:<br/>        deployment_compiled = self.all_compiled_contracts[<br/>            compiled_contract_key<br/>        ]</span><span id="d8d8" class="nb ln hu ms b fv ng nd l ne nf">deployment = self.web3.eth.contract(<br/>    abi=deployment_compiled['abi'],<br/>    bytecode=deployment_compiled['bin']<br/>    )</span></pre><p id="9b80" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是我们第一次看到web3.py库的运行。web3.eth.contract是一个准备在区块链上部署的协定类。接下来，我们将估计部署的气体使用量，如果低于初始化时设置的值，就进行部署。</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="e44d" class="nb ln hu ms b fv nc nd l ne nf">deployment_estimate = deployment.constructor().estimateGas(<br/>    transaction=deployment_params)</span><span id="cb1e" class="nb ln hu ms b fv ng nd l ne nf">if deployment_estimate &lt; self.max_deploy_gas:<br/>    tx_hash = deployment.constructor().transact(<br/>        transaction=deployment_params)</span></pre><p id="257d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里发生了一些事情。<code class="eh mp mq mr ms b">constructor()</code>方法构建给定<code class="eh mp mq mr ms b"><a class="ae jg" href="http://deployment_estimate = deployment.constructor().estimateGas(transaction=deployment_params)                  if deployment_estimate &lt; self.max_deploy_gas:                     tx_hash = deployment.constructor().transact(transaction=deployment_params)" rel="noopener ugc nofollow" target="_blank">deployment_params</a></code>的部署事务。这是一个有许多缺省值的字典，如果需要可以重载。<code class="eh mp mq mr ms b">max_deploy_gas</code>在<code class="eh mp mq mr ms b">__init__</code>期间被设置为默认值，实际上只是一个意外部署气体使用的安全特性。如果通过，使用<code class="eh mp mq mr ms b">constructor().transact</code>部署契约，并返回事务散列(<code class="eh mp mq mr ms b">tx_hash</code>)。</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="61a1" class="nb ln hu ms b fv nc nd l ne nf">tx_receipt = self.web3.eth.waitForTransactionReceipt(tx_hash)<br/>contract_address = tx_receipt['contractAddress']</span></pre><p id="fc88" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这两行等待事务被挖掘，返回收据，并从中提取合同的地址。我们将使用以下内容将其写入文件:</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="426e" class="nb ln hu ms b fv nc nd l ne nf">vars = {<br/>    'contract_address' : contract_address,<br/>    'contract_abi' : deployment_compiled['abi']<br/>}</span><span id="79c3" class="nb ln hu ms b fv ng nd l ne nf">with open (self.deployment_vars_path, 'w') as write_file:<br/>    json.dump(vars, write_file, indent=4)</span></pre><p id="0adc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这将收集部署地址和契约的ABI，并将它们保存到位于<code class="eh mp mq mr ms b">deployment_vars_path</code>中指定路径的JSON文件中。我们将在下一节看到原因。</p><p id="00d3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，如果您运行<code class="eh mp mq mr ms b">walkthrough</code>，您应该会看到编译合同的输出，一些合同部署输出和一行告诉您那些变量保存在哪里的内容。</p></div><div class="ab cl lf lg hc lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hn ho hp hq hr"><h1 id="dfd8" class="lm ln hu bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj dt translated">获取实例</h1><p id="a547" class="pw-post-body-paragraph jh ji hu jj b jk mk jm jn jo ml jq jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">一旦我们将合同部署到区块链，它将无限期地存在下去(至少在理论上是这样)。我们不希望每次想要与它交互时都要重新编译和重新部署。这就是为什么我们在最后一节将合同的地址和ABI保存在JSON文件中。将以下内容添加到<code class="eh mp mq mr ms b">walkthrough</code>:</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="c6ec" class="nb ln hu ms b fv nc nd l ne nf">greeter_interface.get_instance()</span></pre><p id="5242" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个方法的第一部分将打开JSON，检查它是否有一个地址，然后检查在那个地址上是否部署了一些东西:</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="755f" class="nb ln hu ms b fv nc nd l ne nf">with open (self.deployment_vars_path, 'r') as read_file:<br/>    vars = json.load(read_file)</span><span id="bce5" class="nb ln hu ms b fv ng nd l ne nf">try:<br/>    self.contract_address = vars['contract_address']<br/>except ValueError(<br/>    "No address found in {}, please call 'deploy_contract' and <br/>    try again.".format(self.deployment_vars_path)<br/>    ):<br/>    raise</span><span id="6b23" class="nb ln hu ms b fv ng nd l ne nf">contract_bytecode_length = len(self.web3.eth.getCode(<br/>     self.contract_address).hex())</span><span id="51a6" class="nb ln hu ms b fv ng nd l ne nf">try:<br/>    assert (contract_bytecode_length &gt; 4), "Contract not deployed <br/>    at {}.".format(self.contract_address)<br/>except AssertionError as e:<br/>    print(e)<br/>    raise<br/>else:<br/>    print('Contract deployed at {}. This function returns <br/>          an instance object.'.format(self.contract_address))</span></pre><p id="2531" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦这些检查完成，我们将再次构建契约实例，这次使用地址并返回该实例。</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="e92f" class="nb ln hu ms b fv nc nd l ne nf">self.contract_instance = self.web3.eth.contract(<br/>     abi = vars['contract_abi'],<br/>     address = vars['contract_address']<br/>     )</span><span id="cc48" class="nb ln hu ms b fv ng nd l ne nf">return self.contract_instance</span></pre><p id="1bd7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个部署的实例公开了您的契约的属性和方法，如<a class="ae jg" href="http://self.contract_instance = self.web3.eth.contract(             abi = vars['contract_abi'],             address = vars['contract_address']         )          return self.contract_instance" rel="noopener ugc nofollow" target="_blank">文档</a>中所述。举个例子，</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="545f" class="nb ln hu ms b fv nc nd l ne nf">&gt;&gt;&gt;instance = greeter_interface.get_instance()<br/>&gt;&gt;&gt;instance.functions.greet().call()<br/>&gt;&gt;&gt;b'Hello'\x00\x00\x00\x00...</span></pre><p id="4361" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">问候语这样显示是因为它在<code class="eh mp mq mr ms b">Greeter.sol</code>中被设置为类型<code class="eh mp mq mr ms b">bytes32</code>。我们将在本教程的第2部分中探讨我为什么使用字节，以及处理事件和清理输出！然而，对于许多人来说，这个契约实例足以满足他们的需求。</p></div><div class="ab cl lf lg hc lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hn ho hp hq hr"><h1 id="7ea1" class="lm ln hu bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj dt translated">包裹</h1><p id="945c" class="pw-post-body-paragraph jh ji hu jj b jk mk jm jn jo ml jq jr js mm ju jv jw mn jy jz ka mo kc kd ke hn dt translated">我编写这个小接口是因为我想要一种简洁的方式来编译、部署Python中的智能契约并与之交互。这对我来说是一次很大的学习经历，也是大量修补的结果——我希望它对你们中的一些人有所帮助。然而，它相当固执己见，当然也不像我希望的那样健壮。这是一项正在进行的工作，我乐于接受批评和改进。同样，再次，如果你需要任何帮助，留下评论，我会尽力而为！</p></div></div>    
</body>
</html>