<html>
<head>
<title>Building a Development Environment for Golang with Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Docker构建Golang开发环境</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-development-environment-for-golang-with-docker-3ccc620c4920?source=collection_archive---------1-----------------------#2018-12-19">https://medium.com/hackernoon/building-a-development-environment-for-golang-with-docker-3ccc620c4920?source=collection_archive---------1-----------------------#2018-12-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="2b65" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">关注开发人员的幸福</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/9074df53b3652fb5205f423e503744fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JfSp7LWmVE1nj15IrxWSWQ.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">A whale and a Gopher go to the bar</figcaption></figure><p id="2c81" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">几个月前，当我发现JavaScript对我来说变得有点笨拙时，我开始了在<a class="ae kv" href="https://hackernoon.com/tagged/golang" rel="noopener ugc nofollow" target="_blank"> Golang </a>的旅程。TypeScript解决了一些问题，但是它使得JavaScript和Java一样冗长。无论如何，我已经写了将近五年的JavaScript，我认为用不同的思维模式和<a class="ae kv" href="https://hackernoon.com/tagged/development" rel="noopener ugc nofollow" target="_blank">开发</a>范式学习一门不同的语言会很好。</p><p id="220b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">刚开始，我在Golang遇到的最大问题是缺乏工具和现在臭名昭著的<code class="eh kw kx ky kz b">GOPATH</code>需求。后者是谷歌工程师的个人喜好问题，但前者是可以解决的。</p><p id="edcd" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我一直在寻找能够让我在开发中轻松运行Golang服务的工具，就像我可以运行基于Node.js的应用程序一样，但我没有找到一个符合我需求的工具，所以我决定创建一个。</p><p id="c53c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">它使用Docker运行，Docker解决了环境和版本管理问题，并使用Makefiles作为工具，它以映像的形式出现，基本上包含简单的shell脚本，有助于:</p><ol class=""><li id="4979" class="la lb hu kb b kc kd kf kg ki lc km ld kq le ku lf lg lh li dt translated">启动项目</li><li id="cd9a" class="la lb hu kb b kc lj kf lk ki ll km lm kq ln ku lf lg lh li dt translated">测试和应用的实时重载</li><li id="4b76" class="la lb hu kb b kc lj kf lk ki ll km lm kq ln ku lf lg lh li dt translated">依赖关系的自动更新</li><li id="e248" class="la lb hu kb b kc lj kf lk ki ll km lm kq ln ku lf lg lh li dt translated">静态链接二进制编译</li><li id="de85" class="la lb hu kb b kc lj kf lk ki ll km lm kq ln ku lf lg lh li dt translated">打包成暂存Docker映像</li></ol><p id="e91a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我称之为Go Develop，你可以在我的GitHub库找到它:</p><div class="lo lp fm fo lq lr"><a href="https://github.com/zephinzer/golang-dev" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab ej"><div class="lt ab lu cl cj lv"><h2 class="bd hv fv z el lw eo ep lx er et ht dt translated">泽芬策/戈朗-德夫</h2><div class="ly l"><h3 class="bd b fv z el lw eo ep lx er et ek translated">通过在GitHub上创建一个帐户来为zephinzer/golang-dev开发做贡献。</h3></div><div class="lz l"><p class="bd b gc z el lw eo ep lx er et ek translated">github.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf jt lr"/></div></div></a></div><p id="85e2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">下面是一篇关于我经历的简短帖子，以及这个项目如何解决我在进入Golang世界时所面临的问题。</p><p id="7c70" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">作为我试图复制的环境的参考，我使用以下JavaScript工具来提高我的工作效率:</p><ol class=""><li id="bd8d" class="la lb hu kb b kc kd kf kg ki lc km ld kq le ku lf lg lh li dt translated"><a class="ae kv" href="https://github.com/creationix/nvm" rel="noopener ugc nofollow" target="_blank"> NVM </a>用于管理节点版本</li><li id="8c88" class="la lb hu kb b kc lj kf lk ki ll km lm kq ln ku lf lg lh li dt translated"><a class="ae kv" href="https://yarnpkg.com/en/" rel="noopener ugc nofollow" target="_blank">纱</a>用于管理依赖关系</li><li id="1edc" class="la lb hu kb b kc lj kf lk ki ll km lm kq ln ku lf lg lh li dt translated"><a class="ae kv" href="https://github.com/remy/nodemon" rel="noopener ugc nofollow" target="_blank"> Nodemon </a>用于实时重新加载我的应用程序和测试</li><li id="50cf" class="la lb hu kb b kc lj kf lk ki ll km lm kq ln ku lf lg lh li dt translated"><a class="ae kv" href="https://github.com/prettier/prettier-eslint" rel="noopener ugc nofollow" target="_blank">ESLint+beauty</a>用于自动代码格式化和实时林挺</li><li id="18f6" class="la lb hu kb b kc lj kf lk ki ll km lm kq ln ku lf lg lh li dt translated"><a class="ae kv" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank"> Docker多阶段构建</a>用于打包和部署应用程序</li></ol><h1 id="5a33" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">助推围棋项目</h1><p id="1878" class="pw-post-body-paragraph jz ka hu kb b kc my iv ke kf mz iy kh ki na kk kl km nb ko kp kq nc ks kt ku hn dt translated">当启动任何项目时，通常归结为几件事:</p><ol class=""><li id="3fa8" class="la lb hu kb b kc kd kf kg ki lc km ld kq le ku lf lg lh li dt translated">任务运行者(task runner)——在浏览了Go中一些项目的源代码后，Makefiles似乎是普遍接受的方式。</li><li id="ea9b" class="la lb hu kb b kc lj kf lk ki ll km lm kq ln ku lf lg lh li dt translated"><strong class="kb hv">一个依赖管理器</strong> —在Go 1.11之前，有Glide、Dep和Godep。Go 1.11推出了<code class="eh kw kx ky kz b">go mod</code>似乎是要走的路。</li><li id="fbea" class="la lb hu kb b kc lj kf lk ki ll km lm kq ln ku lf lg lh li dt translated"><strong class="kb hv">管理版本的一种方式</strong> —似乎普遍接受的方式是通过Git标签。由于<code class="eh kw kx ky kz b">go mod</code>有点新，我坚持使用Git标签。</li><li id="a7f8" class="la lb hu kb b kc lj kf lk ki ll km lm kq ln ku lf lg lh li dt translated"><strong class="kb hv">投入生产的一种方式</strong> —我处理过的Go应用程序一般都是云原生的，打包通常通过Docker容器完成。</li></ol><p id="e31b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">因此，使用Go Develop的推荐方式是通过Makefile，其中的<code class="eh kw kx ky kz b">init</code>脚本为开发和发布提供了一个目录。它还包含了一些脚本，以一种semver兼容的方式撞击您的Git标签。</p><h1 id="fd68" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">Go版本的管理</h1><p id="ad37" class="pw-post-body-paragraph jz ka hu kb b kc my iv ke kf mz iy kh ki na kk kl km nb ko kp kq nc ks kt ku hn dt translated">几乎在每一种现代语言中，总有惯用的<code class="eh kw kx ky kz b">xVM</code>(其中<code class="eh kw kx ky kz b">x</code>是你正在使用的语言/运行时的第一个字母)。Ruby有RVM，Node有NVM，Go有GVM。然而，GVM修改了你的<code class="eh kw kx ky kz b">GOPATH</code>。虽然一开始我并不介意，但在使用GVM的<code class="eh kw kx ky kz b">linkthis</code>子命令处理不同的项目时，我很快就遇到了问题。那是我开始研究这个问题的时候，而且…这显然是许多人持续的抱怨:</p><div class="lo lp fm fo lq lr"><a href="https://github.com/moovweb/gvm/issues/189" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab ej"><div class="lt ab lu cl cj lv"><h2 class="bd hv fv z el lw eo ep lx er et ht dt translated">不要管$GOPATH，请发出#189 moovweb/gvm</h2><div class="ly l"><h3 class="bd b fv z el lw eo ep lx er et ek translated">当我切换到不同版本的Go时，我不希望我的$GOPATH被更改。$ go版本&gt; go版本go1.4.3…</h3></div><div class="lz l"><p class="bd b gc z el lw eo ep lx er et ek translated">github.com</p></div></div><div class="ma l"><div class="nd l mc md me ma mf jt lr"/></div></div></a></div><p id="07c9" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">使用Docker，我们甚至不需要在你的机器上安装Golang。只需参考我们想要的Golang版本就可以开始了！(Go Develop从1.11.2开始，如果需要更早的1.11.x版本，我会添加对它们的支持——<a class="ae kv" href="https://github.com/zephinzer/golang-dev/issues/new" rel="noopener ugc nofollow" target="_blank">在GitHub上给我投个问题</a>)。</p><p id="23da" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">作为一个好的副作用，这也意味着您不再需要在本地机器上配置<code class="eh kw kx ky kz b">GOPATH</code>，只要它在映像中被正确定义。</p><h1 id="a607" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">代码的自动格式化</h1><p id="b4d8" class="pw-post-body-paragraph jz ka hu kb b kc my iv ke kf mz iy kh ki na kk kl km nb ko kp kq nc ks kt ku hn dt translated">像许多从事网络相关软件工作的人一样，我称<a class="ae kv" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> Visual Studio Code </a>为我选择的IDE，它已经有了一个<a class="ae kv" href="https://code.visualstudio.com/docs/languages/go" rel="noopener ugc nofollow" target="_blank">令人惊讶的体面插件</a>，只需在你的市场中搜索“go”即可！</p><p id="79e6" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当Go语言服务器打开时，智能感知会产生奇迹，由<code class="eh kw kx ky kz b">gofmt</code>执行的自动格式化会很好地完成工作。实际上，我发现它比ESLint+prettle组合更好——但这可能是因为Go本身在编译之前会强制格式化。</p><h1 id="daca" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">应用程序的实时重载</h1><p id="9725" class="pw-post-body-paragraph jz ka hu kb b kc my iv ke kf mz iy kh ki na kk kl km nb ko kp kq nc ks kt ku hn dt translated">用了<code class="eh kw kx ky kz b">nodemon</code>之后，就很难再回到手动重装了。Golang社区有它自己的产品，比如<a class="ae kv" href="https://github.com/oxequa/realize" rel="noopener ugc nofollow" target="_blank"> Realize </a>，我在我的专业工作中使用了一段时间。然而，它不能与主服务一起运行测试，如果您希望在编写代码和破坏东西的同时运行测试，这是很麻烦的。我仍然不得不手动运行<code class="eh kw kx ky kz b">go test</code>。</p><p id="4c1c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然后<code class="eh kw kx ky kz b">go mod</code>在1.11来了，打破了Realize。一旦有了一个<code class="eh kw kx ky kz b">go.mod</code>文件，实时重装甚至不会启动。这个问题仍然存在(而且不仅仅发生在Windows上):</p><div class="lo lp fm fo lq lr"><a href="https://github.com/oxequa/realize/issues/217" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab ej"><div class="lt ab lu cl cj lv"><h2 class="bd hv fv z el lw eo ep lx er et ht dt translated">无法在windows下使用go mod对go1.11执行“运行”操作。问题#217 oxequa/realize</h2><div class="ly l"><h3 class="bd b fv z el lw eo ep lx er et ek translated">目录:- main.go - go.mod main.go:包main导入" fmt" func main() { fmt。Println("hello") }开始实现…</h3></div><div class="lz l"><p class="bd b gc z el lw eo ep lx er et ek translated">github.com</p></div></div><div class="ma l"><div class="ne l mc md me ma mf jt lr"/></div></div></a></div><p id="3f73" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在Go Develop中，我使用了<code class="eh kw kx ky kz b"><a class="ae kv" href="https://linux.die.net/man/1/inotifywait" rel="noopener ugc nofollow" target="_blank">inotifywait</a></code>来观察所有的<code class="eh kw kx ky kz b">*.go</code>文件，并对文件变化进行构建/更新deps/kill/run循环。然而，这意味着它不能在OS X或Windows上运行，但由于Docker抽象了操作系统层，这不是问题，这就是为什么从容器中运行Go应用程序对我来说有意义。</p><h1 id="4748" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">测试的实时重载</h1><p id="fb26" class="pw-post-body-paragraph jz ka hu kb b kc my iv ke kf mz iy kh ki na kk kl km nb ko kp kq nc ks kt ku hn dt translated">现有的工具对测试的实时重载也不公平。GoConvey 听起来很棒——除了我不想切换到浏览器来查看我的测试结果。我更喜欢CLI。GoConvey <a class="ae kv" href="https://github.com/smartystreets/goconvey/wiki/Auto-test" rel="noopener ugc nofollow" target="_blank">有自动重新加载测试</a>的CLI模式，但是，失败不会将错误日志转储到终端，这让我很恼火。</p><p id="176a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">Go Develop使用与应用程序相同的<code class="eh kw kx ky kz b">inotifywait</code>机制来运行测试。更多信息可在文档中找到<a class="ae kv" href="https://github.com/zephinzer/golang-dev#live-reload-live-dependency-update-live-testing-development" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="342c" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">依赖关系的自动更新</h1><p id="65ab" class="pw-post-body-paragraph jz ka hu kb b kc my iv ke kf mz iy kh ki na kk kl km nb ko kp kq nc ks kt ku hn dt translated">我在其他实时重载工具上遇到的另一个问题是，在我对新的东西做了一个<code class="eh kw kx ky kz b">import</code>之后，我不得不切换我的终端并单独安装新的包。</p><p id="1e40" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">虽然这在过去是不可能的，因为不同的项目使用不同的依赖管理器，但Go 1.11的发布看到了官方包含了<code class="eh kw kx ky kz b">go mod</code>，这似乎是未来的方向(哈哈)。</p><p id="ad93" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在Go Develop中，<code class="eh kw kx ky kz b">go mod</code>的使用被强制执行，这简化了其他依赖项管理器面临的问题，比如版本选择。<code class="eh kw kx ky kz b">go mod</code>还有<a class="ae kv" href="https://github.com/golang/go/wiki/Modules#automatic-migration-from-prior-dependency-managers" rel="noopener ugc nofollow" target="_blank">包括与其他依赖管理器</a>的向后兼容性，这让我确信它是我们的选择。</p><h1 id="1720" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">二进制编译和生产打包</h1><p id="d686" class="pw-post-body-paragraph jz ka hu kb b kc my iv ke kf mz iy kh ki na kk kl km nb ko kp kq nc ks kt ku hn dt translated">大多数用Go编写的应用程序似乎注定要打包成Docker映像。在我的工作中，我也必须这样做。那么，为什么不建立一个包含电池的构建机制呢？</p><p id="a52d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">Go Develop就是在这种情况下编写的。在映像中运行<code class="eh kw kx ky kz b">build</code>脚本会产生一个静态链接的二进制文件，可以用在临时Docker映像(没有指定操作系统的Docker映像)中，这大大减小了映像的大小。</p><p id="b2e2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果静态链接和容器化不适合你，Go Develop还允许你通过提供<code class="eh kw kx ky kz b">GOOS</code>和<code class="eh kw kx ky kz b">GOARCH</code>环境变量来运行你自己的操作系统。<a class="ae kv" href="https://github.com/zephinzer/golang-dev#building-a-binary" rel="noopener ugc nofollow" target="_blank">查看文档，了解如何执行此操作</a>。</p><h1 id="8258" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">遗言</h1><p id="63cf" class="pw-post-body-paragraph jz ka hu kb b kc my iv ke kf mz iy kh ki na kk kl km nb ko kp kq nc ks kt ku hn dt translated">我希望这个项目像对我自己一样对其他人有益——它被许可了麻省理工学院的许可，所以你可以用它做任何你想做的事情。</p><p id="241f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果它确实在某种程度上帮助了你，帮我一个忙，看看这个库，表明你已经发现它在你的开发之旅中是有益的。反馈也是非常受欢迎的(我仍然是一个围棋新手，我对工具的任何改进都会有所帮助！)</p><p id="6505" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">您可以在DockerHub上找到Docker图片，网址为:</p><div class="lo lp fm fo lq lr"><a href="https://hub.docker.com/r/zephinzer/golang-dev/" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab ej"><div class="lt ab lu cl cj lv"><h2 class="bd hv fv z el lw eo ep lx er et ht dt translated">码头枢纽</h2><div class="ly l"><h3 class="bd b fv z el lw eo ep lx er et ek translated">编辑描述</h3></div><div class="lz l"><p class="bd b gc z el lw eo ep lx er et ek translated">hub.docker.com</p></div></div></div></a></div><p id="8bd4" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">感谢阅读！</p></div><div class="ab cl nf ng hc nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="hn ho hp hq hr"><p id="09c1" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">最后，我的工作团队正在扩大，如果你在新加坡，想和我一起工作，请随时打电话到<a class="ae kv" href="mailto:joseph_goh@tech.gov.sg" rel="noopener ugc nofollow" target="_blank">joseph_goh@tech.gov.sg</a>找我(:</p><h1 id="a7dd" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">欢呼<strong class="ak">😎</strong></h1><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nm nn l"/></div></figure></div></div>    
</body>
</html>