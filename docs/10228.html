<html>
<head>
<title>How to Make Your App Faster with Webpack Dynamic Imports</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过Webpack动态导入让您的应用更快</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-make-your-app-faster-with-webpack-dynamic-imports-c46dc9602e8f?source=collection_archive---------28-----------------------#2018-12-19">https://medium.com/hackernoon/how-to-make-your-app-faster-with-webpack-dynamic-imports-c46dc9602e8f?source=collection_archive---------28-----------------------#2018-12-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><a href="https://blog.jscrambler.com/how-to-make-your-app-faster-with-webpack-dynamic-imports/?utm_source=medium.com&amp;utm_medium=referral"><div class="fe ff ir"><img src="../Images/ed2954ef629fff6a8b8ff06854ec8a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f0EVNRKinZjBQNJG.jpg"/></div></a></figure><h1 id="4df5" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">由<a class="ae jw" href="http://webpack.jakoblind.no/" rel="noopener ugc nofollow" target="_blank">雅各布·林德</a>，<a class="ae jw" href="https://twitter.com/karljakoblind" rel="noopener ugc nofollow" target="_blank"> @karljakoblind </a>。</h1><p id="fd28" class="pw-post-body-paragraph jx jy hu jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">有多少用户访问你的应用程序的每一个页面，或者使用你的网站的每一个功能？</p><p id="eb0f" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">大概<strong class="jz hv">只有你和你的集成测试</strong>。</p><p id="2d30" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">你的大多数用户都有一个明确的目标。例如，一个用户可能只想浏览您的产品目录，看看您的网上商店有什么。他还没有准备好购买，也不会看到你的结账。他也不会点击产品页面上的“显示评论”标签。</p><p id="9cfb" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">对于整个应用程序的一个包，这个用户必须下载他<em class="la">永远不会运行</em>的代码。</p><p id="2291" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">如果你想创建快速的网站，你必须向浏览器发送尽可能少的JavaScript代码。不仅下载JavaScript包需要时间，浏览器还必须提取代码并<em class="la">解析它</em>——这也需要很多时间。</p><p id="26f6" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">慢网站让用户离开。这也不利于SEO — <a class="ae jw" href="https://web.dev/fast" rel="noopener ugc nofollow" target="_blank">谷歌奖励快捷网站</a>。</p><p id="89f8" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">您应该做的是只发送用户查看和与他访问的页面交互所需的JavaScript不多也不少。这样的话，网站的加载速度会更快，你的用户会得到更好的体验。</p><p id="97cd" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">嗯，你猜怎么着——有了webpack和动态导入，这是可能的。</p><p id="dc00" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">当您使用动态导入时，您只需在页面加载时提供最少的JavaScript，当(如果)用户需要时，动态地提供其余的JavaScript。</p><h1 id="133c" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">如何配置webpack动态导入</h1><p id="d3c6" class="pw-post-body-paragraph jx jy hu jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">动态加载听起来不错，但是如何配置webpack项目来支持它呢？</p><p id="ee85" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">实际上根本不涉及webpack配置，因为动态导入在webpack 2和更高版本中是开箱即用的(如果您还在使用webpack 1，现在是升级的好时机)。您不需要在您的<code class="eh lb lc ld le b">webpack.config.js</code>中做任何配置就可以让它工作。</p><p id="fd69" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">然而你需要做的是配置Babel。您还需要用稍微新一点的语法编写处理导入的代码。我们稍后将回到那个语法。首先，我们来看看巴别塔。</p><p id="a00b" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">动态导入是阶段3中的TC39提案。阶段4是“完成”阶段，所以它非常接近成为一个标准。因为它仍然是一个提议，浏览器还不支持它。因此，要让它工作，您需要配置Babel来传输您的动态导入。</p><p id="2064" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">为此，您首先需要安装Babel插件<code class="eh lb lc ld le b">plugin-syntax-dynamic-import</code>:</p><pre class="lf lg lh li fq lj le lk ll aw lm dt"><span id="8b3e" class="ln iz hu le b fv lo lp l lq lr">npm install --save-dev @babel/plugin-syntax-dynamic-import</span></pre><p id="6222" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">然后在<code class="eh lb lc ld le b">.babelrc</code>文件中使用它:</p><pre class="lf lg lh li fq lj le lk ll aw lm dt"><span id="8770" class="ln iz hu le b fv lo lp l lq lr">{<br/>  "plugins": ["<a class="ae jw" href="http://twitter.com/babel/plugin-syntax-dynamic-imp" rel="noopener ugc nofollow" target="_blank">@babel/plugin-syntax-dynamic-imp</a>ort"]<br/>}</span></pre><h1 id="ae6b" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">动态导入的语法</h1><p id="0b50" class="pw-post-body-paragraph jx jy hu jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在您已经配置了Babel，您可以在您的项目中使用动态导入。在我描述如何做到这一点之前，让我们看一下不是动态导入的导入是什么样子的。</p><pre class="lf lg lh li fq lj le lk ll aw lm dt"><span id="45c9" class="ln iz hu le b fv lo lp l lq lr">import Text from "./Text"</span></pre><p id="9c30" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">这行代码你应该很熟悉了。当您以这种方式导入时，您可以使用新变量<code class="eh lb lc ld le b">Text</code>访问<code class="eh lb lc ld le b">./Text.js</code>中的模块。导入后，您可以访问模块中的任何功能。</p><p id="8ec5" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">对于动态导入，该语句看起来略有不同。</p><pre class="lf lg lh li fq lj le lk ll aw lm dt"><span id="e61d" class="ln iz hu le b fv lo lp l lq lr">import("./Text").then(Text =&gt; {<br/>  // you can access Text inside here.<br/>})</span></pre><p id="9258" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">我们仍然使用import关键字，但是我们不像以前那样用from关键字将它赋给一个变量。相反，<code class="eh lb lc ld le b">import("./Text")</code>回报一个承诺。在这个承诺里，你可以使用这个模块。</p><p id="8c8d" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">幕后发生的事情是，当您调用<code class="eh lb lc ld le b">import("Text")</code>时，它发出一个Ajax请求，只获取您的包中包含包文本的部分。在看到这个语句之前，应用程序不会加载这个包。</p><p id="4a15" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">这意味着，如果你把这个代码放到一个<code class="eh lb lc ld le b">onClick</code>处理程序中，这个模块的代码直到用户按下那个按钮才会被获取。</p><h1 id="1fe9" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">动态导入的一个例子</h1><p id="e563" class="pw-post-body-paragraph jx jy hu jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们看看如何在一个示例应用程序中使用它。我们将使用React作为例子，但是同样的原理可以应用于任何框架或者根本不应用框架。首先，我们在<code class="eh lb lc ld le b">Text.js</code>中创建<code class="eh lb lc ld le b">Text</code>组件:</p><pre class="lf lg lh li fq lj le lk ll aw lm dt"><span id="b92a" class="ln iz hu le b fv lo lp l lq lr">import React from "react";<br/>export default () =&gt; &lt;div&gt;This text is loaded dynamically&lt;/div&gt;</span></pre><p id="0ab1" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">接下来，我们将在<code class="eh lb lc ld le b">index.js</code>中使用它。我们将在根组件内部动态导入它，而不是像通常那样在文件的顶部导入它:</p><pre class="lf lg lh li fq lj le lk ll aw lm dt"><span id="d6a7" class="ln iz hu le b fv lo lp l lq lr">class App extends React.Component {<br/>    constructor(props) {<br/>        super(props);<br/>        this.state = {<br/>            Text: null<br/>        }<br/>        this.loadComponent = this.loadComponent.bind(this);<br/>    }<br/>    loadComponent() {<br/>        import("./Text").then(Text =&gt; this.setState({Text: Text.default}));<br/>    }<br/>    render() {<br/>        let { Text } = this.state;<br/>        return (<br/>            &lt;div&gt;<br/>                &lt;button onClick={this.loadComponent}&gt;Load component&lt;/button&gt;<br/>                {Text ? &lt;Text/&gt; : null}<br/>            &lt;/div&gt;<br/>        )<br/>    }<br/>}</span></pre><p id="3973" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">当用户点击按钮时，<code class="eh lb lc ld le b">Text</code>组件将被动态导入并进入组件状态。<code class="eh lb lc ld le b">App</code>渲染<code class="eh lb lc ld le b">render</code>函数中的<code class="eh lb lc ld le b">Text</code>组件。</p><p id="6940" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">如果您查看浏览器的网络选项卡，您可以看到包含<code class="eh lb lc ld le b">Text</code>组件的块只有在您按下按钮时才会加载。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/40c9c249317a89310796dd7c3df176a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*QyzIk6r7JecM_0kx.gif"/></div></figure><p id="a740" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">在页面加载时获取的代码更少，这意味着更快的加载速度！</p><p id="7464" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">现在，在你自己的项目中尝试一下。看看是否可以使用动态导入来减小入口点包的大小。</p><h1 id="080a" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">对您的应用进行更多优化</h1><p id="5729" class="pw-post-body-paragraph jx jy hu jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">Webpack是一个非常棒的工具，它给了作为开发者的你力量。这很棒，因为你有能力创建用户需要的应用程序。但这也意味着，如果你的网站开始变慢，你不能责怪别人。</p><p id="31fe" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">有这么多的事情可以做，以减少包的大小，它变得势不可挡。有数以百万计的优化。哪一个适合你？哪一个能给你最大的回报？</p><p id="9dce" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">我创建了一个工具,它可以给你一个定制的报告，告诉你应该为你的webpack项目做哪些优化和改进。这给了你一些关于从哪里开始优化的想法，这样你就不用花太多时间去谷歌和RTFM了。</p><p id="2091" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated">请务必为您的项目试用<a class="ae jw" href="https://webpack.jakoblind.no/optimize" rel="noopener ugc nofollow" target="_blank"> webpack优化工具</a>。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><a href="https://blog.jscrambler.com/protectyourcodewhileusingwebpack/?utm_source=medium.com&amp;utm_medium=referral&amp;utm_campaign=protect-webpack"><div class="fe ff lt"><img src="../Images/46eaa6ff96327eda5f598dbdf17787e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N8UmluzvWlswWrmH.jpg"/></div></a></figure></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><p id="d268" class="pw-post-body-paragraph jx jy hu jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hn dt translated"><em class="la">原载于</em><a class="ae jw" href="https://blog.jscrambler.com/how-to-make-your-app-faster-with-webpack-dynamic-imports/?utm_source=medium.com&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"><em class="la"/></a><em class="la">由</em> <a class="ae jw" href="https://blog.jscrambler.com/author/jakob-lind" rel="noopener ugc nofollow" target="_blank"> <em class="la">雅各布林德</em> </a> <em class="la">。</em></p></div></div>    
</body>
</html>