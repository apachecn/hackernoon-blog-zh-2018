<html>
<head>
<title>A Fairy Tale of F# and Durable Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">F#和持久函数的童话</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-fairy-tale-of-f-and-durable-functions-975ccc4d46b8?source=collection_archive---------4-----------------------#2018-12-20">https://medium.com/hackernoon/a-fairy-tale-of-f-and-durable-functions-975ccc4d46b8?source=collection_archive---------4-----------------------#2018-12-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1ce6037477db73ebdaf1714ef21fae4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yFDgRJgySJ1lnnJnP2Lysw.jpeg"/></div></div></figure><p id="84de" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">该帖子是</em> <a class="ae kb" href="https://sergeytihon.com/2018/10/22/f-advent-calendar-in-english-2018/" rel="noopener ugc nofollow" target="_blank"> <em class="ka"> F#降临节日历2018 </em> </a> <em class="ka">的一部分。圣诞节到了！</em></p><p id="c4d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">今年夏天，我受雇于圣诞老人办公室。圣诞老人不仅仅是一个童话人物，他领导着一个大型组织，为全球数百万儿童提供礼物和快乐。像任何大型组织一样，圣诞老人的办公室雇佣了数量惊人的IT系统。</p><p id="e7ed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为IT现代化工作的一部分，North Pole HQ重组了整个圣诞礼物供应链。许多遗留组件从北极的自我管理数据中心转移到Azure cloud，尽管那里的冷却成本非常低。由于圣诞老人的技术精灵使用Office 365、SharePoint和。NET开发堆栈。</p><p id="28c1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">重新设计的目标之一是尽可能利用托管云服务和无服务器架构。圣诞老人没有多余的精灵来继续改造它的轮子。</p><h1 id="3806" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">愿望实现服务</h1><p id="97ff" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">我的任务是重新设计<strong class="je hv">愿望实现</strong>服务。该服务接收来自客户(他们称孩子为“客户”)的愿望列表:</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lf"><img src="../Images/90d73ac3f5db2a853373cf64d21f68ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EdAqPhPw7q3jhJxyxMyqWg.png"/></div></div><figcaption class="lk ll fg fe ff lm ln bd b be z ek">Christmas Card with a Wish List © my son Tim</figcaption></figure><p id="9c9c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是，这个列表已经被其他服务解析过了，并且还包含了关于孩子背景(年龄、性别等等)和偏好的元数据。</p><p id="72e9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于列表中的每一项，我们的服务都调用匹配服务，该服务使用机器学习、Azure认知服务和一点魔法来确定最符合客户表达的愿望和特征的实际产品(他们将礼物称为“产品”)。例如，我儿子对“乐高德拉克”的愿望与“斯宾吉祖·第一伯恩红龙的乐高·宁加戈大师”相匹配。你明白了。</p><p id="334b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每个想要的项目可能有几个匹配，每个结果都有一个估计，即满足最初要求并让孩子开心的可能性有多大。</p><p id="398d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有匹配的产品被组合起来，并被发送到<strong class="je hv">礼品挑选</strong>服务。挑选礼物会根据价格、需求、信心水平和客户的淘气或乖分数来选择其中一个。</p><p id="ef22" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">工作流程的最后一步是<strong class="je hv">在仓库和运输系统中预留</strong>选定的礼物，该系统称为“圣诞老人的产品档案”，也称为SAP。</p><p id="a0e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是一张图中的整个流程:</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lo"><img src="../Images/92dcb9a36c36a760a34abae6ab01bafd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QbVCfZFJISaizBhR.png"/></div></div><figcaption class="lk ll fg fe ff lm ln bd b be z ek">Gift Fulfillment Workflow</figcaption></figure><p id="e657" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们应该如何实现这项服务？</p><h1 id="2fc1" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">原设计</h1><p id="6f41" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">愿望实现服务应该运行在云中，并与其他服务集成。它应该能够在12月处理数百万个请求，并在今年剩下的时间里保持非常低廉的运行成本。我们决定在<a class="ae kb" href="https://azure.microsoft.com/en-us/pricing/details/functions/" rel="noopener ugc nofollow" target="_blank">消费计划</a>上利用具有<a class="ae kb" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview" rel="noopener ugc nofollow" target="_blank"> Azure功能</a>的无服务器架构。无服务器功能包括:</p><ul class=""><li id="e7e5" class="lp lq hu je b jf jg jj jk jn lr jr ls jv lt jz lu lv lw lx dt translated"><strong class="je hv">完全托管</strong>:云提供商提供资源，根据负载进行扩展，保证正常运行时间和可靠性；</li><li id="2058" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated"><strong class="je hv">事件驱动</strong>:对于每个无服务器函数，你必须定义一个特定的触发器——导致它运行的事件类型，可以是HTTP端点，也可以是队列消息；</li><li id="8711" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated"><strong class="je hv">每次执行更改</strong>:如果没有使用，运行应用程序不需要任何成本，繁忙应用程序的成本与实际资源利用率成正比。</li></ul><p id="0884" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是原始设计的图表:</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff md"><img src="../Images/416eaa14f001f232f7688bbc2bf768fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Nvfq_-6oe4KQL8pC.png"/></div></div><figcaption class="lk ll fg fe ff lm ln bd b be z ek">Workflow Design with Azure Functions and Storage Queues</figcaption></figure><p id="7f5e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们使用Azure存储队列来保持整个流程的异步性，并对故障和负载波动具有更强的弹性。</p><p id="b242" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种设计基本上是可行的，但是我们发现了一些问题:</p><ul class=""><li id="a679" class="lp lq hu je b jf jg jj jk jn lr jr ls jv lt jz lu lv lw lx dt translated">这些功能是通过存储队列和相应的绑定手动连接的。工作流分散在基础设施定义中，因此很难掌握。</li><li id="c173" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated">我们必须将每个愿望列表的所有项目传递到一个匹配函数的调用中，否则组合来自多个队列消息的匹配结果会很棘手。</li><li id="4d17" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated">虽然不在最初版本的范围内，但有计划为不匹配的项目添加手动elf干预。这个特性需要改变流程设计:让长时间运行的流程适合管道并不是一件小事。</li></ul><p id="ff31" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了改进这些点，我们决定尝试<a class="ae kb" href="https://docs.microsoft.com/azure/azure-functions/durable/durable-functions-overview" rel="noopener ugc nofollow" target="_blank">持久函数</a>——一个将工作流编排引入Azure函数的库。它引入了几个<a class="ae kb" href="https://hackernoon.com/tagged/tools" rel="noopener ugc nofollow" target="_blank">工具</a>来定义有状态的、可能长期运行的操作，并在幕后处理大量可靠通信和状态管理的机制。</p><p id="cde0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想知道更多关于什么是持久函数以及为什么它们可能是一个好主意，我邀请你阅读我的文章<a class="ae kb" href="https://mikhail.io/2018/12/making-sense-of-azure-durable-functions/" rel="noopener ugc nofollow" target="_blank">理解Azure持久函数</a> (20分钟阅读)。</p><p id="1f77" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章的剩余部分，我将带你通过Azure持久功能实现愿望实现工作流。</p><h1 id="1924" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">领域模型</h1><p id="d766" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">一个好的设计从一个合适的领域模型开始。幸运的是，这个项目是用F#构建的，F #是。网络生态系统。</p><h2 id="60ed" class="me kd hu bd ke mf mg mh ki mi mj mk km jn ml mm kq jr mn mo ku jv mp mq ky mr dt translated">类型</h2><p id="1b02" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">我们的服务是用一个愿望列表作为输入参数调用的，所以让我们从类型<code class="eh ms mt mu mv b">WishList</code>开始:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="eb64" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它包含关于列表作者和已识别的“订单”项目的信息。<code class="eh ms mt mu mv b">Customer</code>是自定义类型；现在，里面有什么并不重要。</p><p id="50c2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于每个愿望，我们希望生成一个可能匹配的列表:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="48a8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该产品是圣诞老人目录中的一个特定礼物选项，信心是从<code class="eh ms mt mu mv b">0.0</code>到<code class="eh ms mt mu mv b">1.0</code>的一个数字，表示匹配有多强。</p><p id="9046" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们服务的最终目标是生产一个<code class="eh ms mt mu mv b">Reservation</code>:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="a8a3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它代表了特定儿童的确切产品选择。</p><h2 id="f524" class="me kd hu bd ke mf mg mh ki mi mj mk km jn ml mm kq jr mn mo ku jv mp mq ky mr dt translated">功能</h2><p id="24a3" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">愿望实现服务需要执行三个动作，可以用三个强类型异步函数来建模。</p><p id="d0cf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">注意:在整篇文章中，我对F#函数使用小写的“function ”,对Azure函数使用大写的“Function ”,以减少混淆。</em></p><p id="ee7a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">第一个动作</strong>为每个愿望寻找匹配:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="866f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我的所有函数片段的第一行显示了函数类型。在这种情况下，这是从孩子的愿望文本(<code class="eh ms mt mu mv b">string</code>)到匹配列表(<code class="eh ms mt mu mv b">Match list</code>)的映射。</p><p id="90f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">第二个动作</strong>取所有愿望的所有匹配的<em class="ka">组合</em>列表并选择一个。它的实际实现是圣诞老人的秘密酱，但我的模型只选择了置信度最高的一个:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="c5fe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">给定picked <code class="eh ms mt mu mv b">gift</code>，预订仅仅是<code class="eh ms mt mu mv b">{ Kid = wishlist.Kid; Product = gift }</code>，不值得单独操作。</p><p id="78a1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">第三个动作</strong>在SAP系统中注册预订:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure><h2 id="4c41" class="me kd hu bd ke mf mg mh ki mi mj mk km jn ml mm kq jr mn mo ku jv mp mq ky mr dt translated">工作流程</h2><p id="1259" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">履行服务将这三个操作合并到一个工作流中:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="5460" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">工作流实现是对实际领域流的一个很好的简明的总结。</p><p id="4a2b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，匹配的服务被并行调用多次，然后借助于<code class="eh ms mt mu mv b">Async.Parallel</code> F#函数很容易地组合结果。</p><p id="f60a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么，我们如何将领域模型转化为无服务器持久功能之上的实际实现呢？</p><h1 id="64bd" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">经典持久函数API</h1><p id="592c" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">C#是持久函数的第一个目标语言；现在也完全支持Javascript。</p><p id="4540" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">F#最初并没有被官方声明为受支持的，但是因为F#运行在官方支持之上。NET运行时作为C#，它一直在工作。我有一篇关于F# 中的<a class="ae kb" href="https://mikhail.io/2018/02/azure-durable-functions-in-fsharp/" rel="noopener ugc nofollow" target="_blank"> Azure持久函数的博文，并且已经将</a><a class="ae kb" href="https://github.com/Azure/azure-functions-durable-extension/tree/master/samples/fsharp" rel="noopener ugc nofollow" target="_blank"> F# samples </a>添加到官方资源库中。</p><p id="6667" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是我的旧F#代码中的两个例子(它们与我们的礼物实现领域无关):</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="49f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这段代码工作正常，但看起来不像惯用的F#代码:</p><ul class=""><li id="78f6" class="lp lq hu je b jf jg jj jk jn lr jr ls jv lt jz lu lv lw lx dt translated">无强类型:活动函数通过名称和手动指定的类型来调用</li><li id="7da5" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated">功能没有具体化，所以局部应用很困难</li><li id="c5ac" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated">任何持久操作都需要传递<code class="eh ms mt mu mv b">context</code>对象</li></ul><p id="0955" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然这里没有显示，但是其他示例读取输入参数、处理错误和强制超时——看起来都太像C#-y了。</p><h1 id="c2e3" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">更持久的功能</h1><p id="935c" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">我们没有遵循次优路线，而是用更符合F#习惯的API实现了服务。我先展示代码，然后解释它的基础。</p><p id="1775" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">实现由三部分组成:</p><ul class=""><li id="dfa8" class="lp lq hu je b jf jg jj jk jn lr jr ls jv lt jz lu lv lw lx dt translated"><strong class="je hv">Activity</strong>Functions——来自域模型的每个动作一个</li><li id="416a" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated"><strong class="je hv"> Orchestrator </strong>功能定义工作流</li><li id="a1cd" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated"><a class="ae kb" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Azure函数绑定</strong> </a>指示如何在云中运行应用程序</li></ul><h2 id="ee9d" class="me kd hu bd ke mf mg mh ki mi mj mk km jn ml mm kq jr mn mo ku jv mp mq ky mr dt translated">活动功能</h2><p id="067a" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">每个活动功能定义了工作流的一个步骤:匹配、挑选和保留。我们只是在一行定义中引用这些操作的F#函数:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="3c32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每个活动都由一个名称和一个功能定义。</p><h2 id="6730" class="me kd hu bd ke mf mg mh ki mi mj mk km jn ml mm kq jr mn mo ku jv mp mq ky mr dt translated">管弦乐演奏家</h2><p id="58c2" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">Orchestrator调用活动函数来产生服务的预期结果。该代码使用自定义计算表达式:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="9333" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意它与我们的领域模型中的工作流定义的匹配程度:</p><figure class="lg lh li lj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/5590883763dbba44b791fc839941b237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E24vHuv-T2upFCxxte7Hew.png"/></div></div><figcaption class="lk ll fg fe ff lm ln bd b be z ek">Async function vs. Durable Orchestrator</figcaption></figure><p id="b14b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">唯一的区别是:</p><ul class=""><li id="f95d" class="lp lq hu je b jf jg jj jk jn lr jr ls jv lt jz lu lv lw lx dt translated"><code class="eh ms mt mu mv b">orchestrator</code>计算表达式被用来代替<code class="eh ms mt mu mv b">async</code>,因为在编排器中不允许多线程</li><li id="79ac" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated"><code class="eh ms mt mu mv b">Activity.call</code>取代直接调用函数</li><li id="cd39" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated"><code class="eh ms mt mu mv b">Activity.all</code>替补队员<code class="eh ms mt mu mv b">Async.Parallel</code></li></ul><h2 id="07c4" class="me kd hu bd ke mf mg mh ki mi mj mk km jn ml mm kq jr mn mo ku jv mp mq ky mr dt translated">托管层</h2><p id="75ff" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">Azure Function触发器需要被定义为托管任何一段代码作为云函数。这可以在<code class="eh ms mt mu mv b">function.json</code>中手动完成，或者通过从。网络属性。在我的例子中，我添加了以下四个定义:</p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="6f48" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些定义非常机械，而且是强类型的(除了函数名)。</p><h2 id="a2a0" class="me kd hu bd ke mf mg mh ki mi mj mk km jn ml mm kq jr mn mo ku jv mp mq ky mr dt translated">装运它！</h2><p id="910a" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">这些都是让我们的持久愿望实现服务启动和运行所需要的。从这一点出发，我们可以利用Azure功能的所有现有工具:</p><ul class=""><li id="818d" class="lp lq hu je b jf jg jj jk jn lr jr ls jv lt jz lu lv lw lx dt translated">用于开发和调试的Visual Studio和Visual Studio代码</li><li id="3c44" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated"><a class="ae kb" href="https://github.com/Azure/azure-functions-core-tools" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Azure功能核心工具</strong> </a>在本地运行应用并将其部署到Azure</li><li id="467b" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated">核心工具的最新版本有专门的命令来<a class="ae kb" href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-instance-management" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">管理持久函数</strong> </a>的实例</li></ul><p id="c528" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在采用无服务器架构的过程中有一个学习曲线。然而，像我们这样的小项目是学习的好方法。它使圣诞老人的It部门走上了成功之路，孩子们将更可靠地获得更好的礼物！</p><h1 id="76a2" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">耐久功能。FSharp</h1><p id="9009" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">以上代码是用库<a class="ae kb" href="https://github.com/mikhailshilkov/DurableFunctions.FSharp" rel="noopener ugc nofollow" target="_blank"> DurableFunctions实现的。FSharp </a>。我创建了这个库，作为一个瘦的F#友好的持久函数包装器。</p><p id="cf45" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">坦率地说，本文的全部目的就是介绍这个库，让您有足够的好奇心去尝试一下。耐久功能。FSharp的工具箱中有几个部分:</p><ul class=""><li id="61d4" class="lp lq hu je b jf jg jj jk jn lr jr ls jv lt jz lu lv lw lx dt translated"><code class="eh ms mt mu mv b">OrchestratorBuilder</code>和<code class="eh ms mt mu mv b">orchestrator</code>计算表达式，封装了<code class="eh ms mt mu mv b">DurableOrchestrationContext</code>的基于<code class="eh ms mt mu mv b">Task</code>的API的正确用法</li><li id="9151" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated"><code class="eh ms mt mu mv b">Activity</code>将活动定义为头等值的通用类型</li><li id="3095" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated"><code class="eh ms mt mu mv b">Activity</code>模块用助手函数调用活动</li><li id="c043" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated">用于<code class="eh ms mt mu mv b">Async</code>和<code class="eh ms mt mu mv b">Orchestrator</code>的Azure函数定义的适配器</li><li id="d817" class="lp lq hu je b jf ly jj lz jn ma jr mb jv mc jz lu lv lw lx dt translated">原始持久扩展的API仍然可用，因此如果需要，您可以使用它们</li></ul><p id="dd9d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我看来，F#是开发无服务器功能的绝佳语言。使用函数的简单性、默认的不变性、强类型系统、对数据管道的关注在事件驱动的云应用程序世界中都是有用的。</p><p id="2d78" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Azure Durable Functions带来了更高层次的抽象，用简单的构建块组成工作流。持续功能的目标。FSharp是为了让F#开发者的作品更加自然和有趣。</p><p id="f739" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kb" href="https://github.com/mikhailshilkov/DurableFunctions.FSharp#getting-started" rel="noopener ugc nofollow" target="_blank">开始使用</a>就像创建一个新的一样简单。NET核心项目并引用一个NuGet包。</p><p id="8a40" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望得到尽可能多的反馈！在下面留下评论，在<a class="ae kb" href="https://github.com/mikhailshilkov/DurableFunctions.FSharp" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>上创建问题，或者打开一个PR。这将是超级真棒！</p><p id="59c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编码快乐，圣诞快乐！</p></div><div class="ab cl mz na hc nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hn ho hp hq hr"><h2 id="01ad" class="me kd hu bd ke mf mg mh ki mi mj mk km jn ml mm kq jr mn mo ku jv mp mq ky mr dt translated">感谢</h2><p id="f172" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">非常感谢<a class="ae kb" href="https://twitter.com/kashimizMSFT" rel="noopener ugc nofollow" target="_blank">凯蒂清水</a>、<a class="ae kb" href="https://twitter.com/DevonBurriss" rel="noopener ugc nofollow" target="_blank">德文伯里斯</a>、<a class="ae kb" href="https://twitter.com/iwasdavid" rel="noopener ugc nofollow" target="_blank">戴夫洛</a>、<a class="ae kb" href="https://twitter.com/cgillum" rel="noopener ugc nofollow" target="_blank">克里斯吉勒姆</a>审阅本文草稿并提出宝贵的意见和建议。</p><p id="55ed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">最初发表于</em><a class="ae kb" href="https://mikhail.io/2018/12/fairy-tale-of-fsharp-and-durable-functions/" rel="noopener ugc nofollow" target="_blank"><em class="ka">Mikhail . io</em></a><em class="ka">。</em></p><figure class="lg lh li lj fq iv"><div class="bz el l di"><div class="ng mx l"/></div></figure></div></div>    
</body>
</html>