<html>
<head>
<title>Scala Object Serialization for MapR-DB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MapR-DB的Scala对象序列化</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/scala-object-serialization-for-mapr-db-792817d3962d?source=collection_archive---------23-----------------------#2018-12-20">https://medium.com/hackernoon/scala-object-serialization-for-mapr-db-792817d3962d?source=collection_archive---------23-----------------------#2018-12-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/f5d17ca82162b40012bf9b2b45b7ffb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*PpU03aViQ-ogkCGBExODiQ.png"/></div></figure><p id="5dad" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt jw translated">之前，我们已经讨论了MapR-DB的一些优势和特性。然而，这一次我们将在使用这个企业级数据库时动手。</p><p id="ee91" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当使用MapR-DB时，由于MapR-DB数据是使用JSON格式存储的，所以经常要在JSON之间序列化和反序列化我们的业务对象(通常称为POJO)。这些操作非常常见和频繁，所以我们将从Scala的角度来看看它们。</p><h2 id="8571" class="kf kg hu bd kh ki kj kk kl km kn ko kp jj kq kr ks jn kt ku kv jr kw kx ky kz dt translated">MapR-DB文档API</h2><p id="6e02" class="pw-post-body-paragraph iy iz hu ja b jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr le jt ju jv hn dt translated">创建新对象并将其插入MapR-DB需要遵循一系列步骤。让我们看看典型的工作流程。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="99d2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是插入MapR-DB的基本步骤。这个片段可以扩展为更复杂的用例，但本质上，它们看起来与这个非常相似。</p><p id="460b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这里有一个问题很容易识别。我们通过fluent API创建<code class="eh ll lm ln lo b">document</code>对象的方式很不方便。通常，我们希望传递一个POJO，而不是手动构建文档。</p><p id="d98d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在Java中，我们可以做以下事情。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="f518" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在上面的代码中，我们可以看到我们的类<code class="eh ll lm ln lo b">Link</code>用于创建将被保存到数据库的文档。MapR-DB将利用Java Beam对象来创建文档对象。</p><p id="2169" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，当使用Scala时，这个问题变得更加乏味，不管怎样，Scala应该是你的首选语言。</p><h2 id="10bf" class="kf kg hu bd kh ki kj kk kl km kn ko kp jj kq kr ks jn kt ku kv jr kw kx ky kz dt translated">Scala问题</h2><p id="5b4c" class="pw-post-body-paragraph iy iz hu ja b jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr le jt ju jv hn dt translated">使用Scala，我们也可以像在Java中一样使用Java Bean来创建所需的对象，但是其他问题很快就会出现。让我们看看之前使用的同一个例子，但是这次是在Scala中。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="f977" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果您尝试这样做，您会发现对象<code class="eh ll lm ln lo b">link</code>不能被转换成Java Bean，因为值<code class="eh ll lm ln lo b">_id</code>以<code class="eh ll lm ln lo b">_</code>开始。这可能看起来很小，但是所有插入MapR-DB的文档都应该有字段<code class="eh ll lm ln lo b">_id</code>，将这个最初的小问题转化为一个交易破坏者。</p><p id="024d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们总是可以回头对我们拥有的每个POJO对象使用手动对象构造，但是由于显而易见的原因，我们应该一想到这个想法就放弃。</p><p id="c948" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">另一种方法是研究将Scala对象转换成文档的机制。很明显，我们需要一个类型类来完成繁重的工作，并为转换系统带来灵活性。</p><p id="ad92" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们定义一个类型类来完成这项工作。因为没有更好的名字，就叫它<code class="eh ll lm ln lo b">MySerializer</code>吧。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="b306" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">正如我们所见，<code class="eh ll lm ln lo b">MySerializer</code>使用一种默认的方式，通过Jackson序列化将对象转换成文档。拥有一个默认的序列化器是一个很好的选择，因为大多数对象都会使用它，但是并不是每个人都是一样的，所以我们也需要专门化。</p><p id="5439" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，我们的代码将如下所示。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="7fca" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如前所述，有时默认的文档转换不起作用，例如，让我们看看下面的例子。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="be07" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当试图将生成的文档保存到数据库时，使用默认转换器和<code class="eh ll lm ln lo b">Person</code>会导致错误。如前所述，MapR-DB需要一个<code class="eh ll lm ln lo b">_id</code>作为文档键。在这种情况下，我们需要为类<code class="eh ll lm ln lo b">Person</code>定制一个转换器。</p><p id="83a6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这就是类型类机制的亮点。我们可以指定从Person创建文档的确切方式。让我们看看怎么做。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="45e3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">请注意，我们有两个选项，一个是使用默认的序列化程序，另一个是使用自定义的序列化程序来处理相关的特定对象。这允许一个细粒度的序列化机制，最终产生泛型，而无需放弃专门化。</p><p id="7cd8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">同时，序列化系统在对象本身之外。我们应该能够在完全不影响对象的情况下修改序列化的工作方式。最终，我们可以基于特定的上下文来重写序列化是如何完成的，同时根据需要为不同的情况使用不同的序列化机制。这在Java中几乎是不可能的，但是Scala是特别多态世界中的巨兽。</p><h1 id="c1a1" class="lp kg hu bd kh lq lr ls kl lt lu lv kp lw lx ly ks lz ma mb kv mc md me ky mf dt translated">结论</h1><p id="1b5f" class="pw-post-body-paragraph iy iz hu ja b jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr le jt ju jv hn dt translated">MapR-DB OJAI API很好，但是它不能很好地处理Scala对象，尤其是那些不符合Java Bean规范的对象。另一方面，Scala提供了像类型类这样的高级构造，允许我们在保持类型安全和支持特定多态性的同时解决许多互操作性问题。</p></div><div class="ab cl mg mh hc mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hn ho hp hq hr"><p id="d6a0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="mn">感谢</em> <a class="ae mo" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank"> <em class="mn"> Lombok项目</em> </a> <em class="mn">帮助我们写出更干净的Java代码。</em></p><p id="7ad1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="mn">感谢S</em><a class="ae mo" href="https://github.com/mpilquist/simulacrum" rel="noopener ugc nofollow" target="_blank"><em class="mn">imularum</em></a><em class="mn">在Scala中启用类型类，无需样板文件。</em></p></div></div>    
</body>
</html>