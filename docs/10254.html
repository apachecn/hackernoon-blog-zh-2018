<html>
<head>
<title>Asyncio, the invincible</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无敌阿辛西奥</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/asyncio-the-invincible-16f5c4924755?source=collection_archive---------25-----------------------#2018-12-20">https://medium.com/hackernoon/asyncio-the-invincible-16f5c4924755?source=collection_archive---------25-----------------------#2018-12-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="7dc7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当谈到多任务时，异步编程是新的热点。它因NodeJS而出名，但你可以在大多数主要语言中找到支持它的库。</p><p id="9d1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如在Python中，两个最著名的方法是使用Tornado Web服务器和内置库asyncio。今天我们将对后者做一个介绍，因为它最近经历了大量的迭代和改进，并且它已经准备好以其直观的方式吸引人们。</p><h1 id="6011" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">什么是异步编程？</h1><p id="cbd0" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">这是一种编程方法，当遇到“停滞时间”时，我们会保持警惕。例如，如果I/O正在发生(例如，我刚刚发送了一个GET请求，等待响应)，应用程序可以继续做其他事情。有人称之为，理想秘书效应。</p><p id="5123" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它可能不适合Python，但是本文中的文章<a class="ae ks" rel="noopener" href="/from-the-scratch/javascript-writing-your-own-non-blocking-asynchronous-functions-60091ceacc79">有一个很好的图表解释了潜在的异步流。</a></p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="ab fr cl ky"><img src="../Images/9adef840a469113fdd3c178468d3f44e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*7jfiG0JLMrTbgyg7nb0O0A.jpeg"/></div></figure><h1 id="96af" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">多线程有什么问题？</h1><p id="feaf" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">当有不同的线程来执行所需的任务时，程序就在使用多线程。这需要大量的关注、协调和主动性，因为线程至少需要不把彼此锁在共享资源之外(死锁)。更不用说额外的内存开销，因为线程需要访问自己的数据副本。</p><p id="6227" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae ks" href="https://stackoverflow.com/questions/1762418/what-resources-are-shared-between-threads" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以找到一个相关的StackOverflow线程。</p><p id="3644" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不是说多线程没用。相反，有些操作本质上是同步的。例如，从文件系统中删除一个巨大的文件。有些人可能会说，你可以通过使用基于流的方法来克服这一点，一次删除一小块，他们是对的，我只是试图证明一点。:-)</p><p id="741b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">异步编程虽然可以与多线程一起工作，但也可以只与一个线程一起有效地工作。大多数情况下，您无法区分性能上的差异(我将在以后的文章中讨论这个问题)。这里唯一的“开销”是要知道一个接一个地写命令并不意味着它们会以相同的顺序执行</p><h1 id="d22b" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">阿辛西奥——我选择你</h1><p id="fb00" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated"><a class="ae ks" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank"> asyncio </a>是一个使用async/await语法编写并发代码的库。这样，即使您编写了异步代码，您最终也会获得同步的视觉感受，这使得可维护性变得更容易一些。</p><p id="1f41" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，下面是如何用python编写异步代码，并用注释解释每一步</p><pre class="kt ku kv kw fq lb lc ld le aw lf dt"><span id="e2dd" class="lg jq hu lc b fv lh li l lj lk"># First import the library that provides all those bells and whistles<br/>import asyncio<br/><br/># Import datetime and calendar as our example is based on date handling<br/>import datetime<br/>import calendar<br/><br/><br/># Here is the important part. We declare a function as async. That means its execution<br/># will not block the application. For example, if you run the function outside<br/># of an async context it will print something like: <br/># &lt;coroutine object show_me_the_day at 0x7f89d55a0e60&gt; <br/># and not the result you would expect in a synchronous execution.<br/>async def show_me_the_day():<br/>    # Calendar is not asynchronous, so we duse asyncio.sleep to emulate the async nature<br/>    # If for any reason you want to block the execution while<br/>    # an async function is executed (eg you need the return value), use await.<br/>    # Await can only be used in async functions, and only inside async functions<br/>    await asyncio.sleep(1)<br/>    return calendar.day_name[datetime.date.today().weekday()]<br/><br/><br/>async def main():<br/>    # If for any reason you want to block the execution while<br/>    # an async function is executed (eg you need the return value), use await.<br/>    # Await can only be used in async functions, and only inside async functions<br/>    day = await show_me_the_day()<br/>    print('Yo, today is ', day)<br/>   <br/>asyncio.run(main())</span></pre><p id="1d9a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了一些样板文件，这就像你在阅读一个经典的连续脚本。经典的Python魔术。:)</p><h1 id="cb9f" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">不过要小心</h1><p id="b963" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">使用asyncio时有一个很大的注意事项。也就是说，当涉及到I/O时，我们必须依赖异步库。否则，收益可以忽略不计。</p><h1 id="348d" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">结论</h1><p id="78d9" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">感谢你阅读这篇文章，我希望你喜欢它。在上一个版本中，Python在处理异步编程的方式上做了很多改进。一如既往，欢乐和杰作在一起。我将带着一篇以性能为导向的文章回来，也许还有几个框架。</p><p id="d76d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果想深入挖掘，官方<a class="ae ks" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank">文档</a>很棒，请看一下。</p></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><p id="631f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="ls">原载于</em> <a class="ae ks" href="https://perigk.github.io/" rel="noopener ugc nofollow" target="_blank"> perigk.github.io </a> <em class="ls">。</em></p></div></div>    
</body>
</html>