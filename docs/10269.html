<html>
<head>
<title>Clojure &amp; Functional Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Clojure &amp;函数式编程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/clojure-functional-programming-38cc6a9298f5?source=collection_archive---------1-----------------------#2018-12-21">https://medium.com/hackernoon/clojure-functional-programming-38cc6a9298f5?source=collection_archive---------1-----------------------#2018-12-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d181e7a1bdd2dc8735404f1ac55a46c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eLqeIits5crU3G5b9LMEyg.png"/></div></div></figure><p id="084a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在长时间学习和使用面向对象编程之后，我退一步思考系统复杂性。</p><blockquote class="ka"><p id="b707" class="kb kc hu bd kd ke kf kg kh ki kj jz ek translated">“——约翰·奥特</p></blockquote><p id="e382" class="pw-post-body-paragraph jc jd hu je b jf ko jh ji jj kp jl jm jn kq jp jq jr kr jt ju jv ks jx jy jz hn dt translated">在做一些研究时，我发现了像不变性和纯函数这样的函数式编程概念。这些概念对于构建无副作用的功能是很大的优势，因此维护系统更容易——还有一些其他的<a class="ae kt" href="https://hackernoon.com/why-functional-programming-matters-c647f56a7691" rel="noopener ugc nofollow" target="_blank">好处</a>。</p><p id="745f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我将告诉你更多关于函数式编程的知识，以及一些重要的概念，并附有大量的代码示例。</p></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><p id="46fc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本文使用Clojure作为编程语言示例来解释函数式编程。如果你不喜欢LISP类型的语言，我也用JavaScript发表了同样的文章。看一看:<a class="ae kt" href="https://medium.freecodecamp.org/functional-programming-principles-in-javascript-1b8fc6c3563f" rel="noopener ugc nofollow" target="_blank"><strong class="je hv">Javascript中的函数式编程原理</strong> </a></p></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><h1 id="05da" class="lb lc hu bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly dt translated">什么是函数式编程？</h1><blockquote class="ka"><p id="3554" class="kb kc hu bd kd ke kf kg kh ki kj jz ek translated">函数式编程是一种编程范式——一种构建计算机程序的结构和元素的风格——将计算视为数学函数的评估，并避免改变状态和可变数据— <a class="ae kt" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><h1 id="0c12" class="lb lc hu bd ld le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly dt translated">纯函数</h1><figure class="mf mg mh mi fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff me"><img src="../Images/332b8332a2fa49dab5aa1f8afd737bf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FMur6URY7yAVjeuP"/></div></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">“water drop” by <a class="ae kt" href="https://unsplash.com/@martinmohan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mohan Murugesan</a> on <a class="ae kt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d9c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们想要理解函数式编程时，我们学习的第一个基本概念是<strong class="je hv">纯函数</strong>。但是这到底意味着什么呢？是什么使得一个函数是纯的？</p><p id="64bf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么我们如何知道一个函数是否是<code class="eh kk kl km kn b">pure</code>？这里有一个非常严格的纯度定义:</p><ul class=""><li id="2a60" class="mn mo hu je b jf jg jj jk jn mp jr mq jv mr jz ms mt mu mv dt translated">如果给定相同的参数，它将返回相同的结果(它也被称为<code class="eh kk kl km kn b">deterministic</code>)</li><li id="09c1" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated">它不会引起任何明显的副作用</li></ul><h2 id="66d9" class="nb lc hu bd ld nc nd ne lh nf ng nh ll jn ni nj lp jr nk nl lt jv nm nn lx no dt translated">如果给定相同的参数，它将返回相同的结果</h2><p id="30eb" class="pw-post-body-paragraph jc jd hu je b jf np jh ji jj nq jl jm jn nr jp jq jr ns jt ju jv nt jx jy jz hn dt translated">假设我们想要实现一个计算圆的面积的函数。一个不纯的函数将接收<code class="eh kk kl km kn b">radius</code>作为参数，然后计算<code class="eh kk kl km kn b">radius * radius * PI</code>。在Clojure中，操作符排在第一位，所以<code class="eh kk kl km kn b">radius * radius * PI</code>变成了<code class="eh kk kl km kn b">(* radius radius PI)</code>:</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="8484" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为什么这是一个不纯函数？因为它使用了一个没有作为参数传递给函数的全局对象。</p><p id="c5cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在想象一些数学家争论说<code class="eh kk kl km kn b">PI</code>的值实际上是<code class="eh kk kl km kn b"><a class="ae kt" href="https://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#Answer_to_the_Ultimate_Question_of_Life,_the_Universe,_and_Everything_(42)" rel="noopener ugc nofollow" target="_blank">42</a></code>并且改变了全局对象的值。</p><p id="9f27" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的不纯函数现在将导致<code class="eh kk kl km kn b">10 * 10 * 42</code> = <code class="eh kk kl km kn b">4200</code>。对于同一个参数(<code class="eh kk kl km kn b">radius = 10</code>，我们有不同的结果。让我们修理它！</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="ff0c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">哒哒🎉！现在我们总是将<code class="eh kk kl km kn b">PI</code>值作为参数传递给函数。所以现在我们只是访问传递给函数的参数。没有<code class="eh kk kl km kn b">external object</code>。</p><ul class=""><li id="4a89" class="mn mo hu je b jf jg jj jk jn mp jr mq jv mr jz ms mt mu mv dt translated">对于参数<code class="eh kk kl km kn b">radius = 10</code> &amp; <code class="eh kk kl km kn b">PI = 3.14</code>，我们将总是得到相同的结果:<code class="eh kk kl km kn b">314.0</code></li><li id="481c" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated">对于参数<code class="eh kk kl km kn b">radius = 10</code> &amp; <code class="eh kk kl km kn b">PI = 42</code>，我们将总是得到相同的结果:<code class="eh kk kl km kn b">4200</code></li></ul><h2 id="e449" class="nb lc hu bd ld nc nd ne lh nf ng nh ll jn ni nj lp jr nk nl lt jv nm nn lx no dt translated">读取文件</h2><p id="c0b9" class="pw-post-body-paragraph jc jd hu je b jf np jh ji jj nq jl jm jn nr jp jq jr ns jt ju jv nt jx jy jz hn dt translated">如果我们的函数读取外部文件，它就不是一个纯粹的函数——文件的内容可以改变。</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><h2 id="6807" class="nb lc hu bd ld nc nd ne lh nf ng nh ll jn ni nj lp jr nk nl lt jv nm nn lx no dt translated">随机数生成</h2><p id="54b2" class="pw-post-body-paragraph jc jd hu je b jf np jh ji jj nq jl jm jn nr jp jq jr ns jt ju jv nt jx jy jz hn dt translated">任何依赖于随机数生成器的函数都不可能是纯函数。</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><h2 id="92db" class="nb lc hu bd ld nc nd ne lh nf ng nh ll jn ni nj lp jr nk nl lt jv nm nn lx no dt translated">它不会引起任何明显的副作用</h2><p id="2928" class="pw-post-body-paragraph jc jd hu je b jf np jh ji jj nq jl jm jn nr jp jq jr ns jt ju jv nt jx jy jz hn dt translated">可观察到的副作用的例子包括修改全局对象或通过引用传递的参数。</p><p id="ab4f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们想实现一个函数来接收一个整数值并返回增加了1的值。</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="ee1b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们有了<code class="eh kk kl km kn b">counter</code>值。我们的非纯函数接收该值，并将该值加1重新分配给计数器。</p><p id="e076" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">观察</strong>:函数式编程不鼓励可变性。</p><p id="fc7a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们正在修改全局对象。但是我们如何让它成为<code class="eh kk kl km kn b">pure</code>？只需返回增加1的值。就这么简单。</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="8277" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看到我们的纯函数<code class="eh kk kl km kn b">increase-counter</code>返回2，但是<code class="eh kk kl km kn b">counter</code>值还是一样。该函数返回增加的值，而不改变变量的值。</p><p id="713f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们遵循这两条简单的规则，理解我们的程序就变得更容易了。现在，每个功能都是孤立的，无法影响我们系统的其他部分。</p><p id="4578" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">纯函数是稳定的、一致的和可预测的。给定相同的参数，纯函数将总是返回相同的结果。我们不需要考虑相同参数有不同结果的情况，因为这永远不会发生。</p><h2 id="94a2" class="nb lc hu bd ld nc nd ne lh nf ng nh ll jn ni nj lp jr nk nl lt jv nm nn lx no dt translated">纯功能优势</h2><p id="cfa2" class="pw-post-body-paragraph jc jd hu je b jf np jh ji jj nq jl jm jn nr jp jq jr ns jt ju jv nt jx jy jz hn dt translated">代码肯定更容易测试。我们不需要嘲笑任何东西。所以我们可以在不同的环境下对纯函数进行单元测试:</p><ul class=""><li id="2df6" class="mn mo hu je b jf jg jj jk jn mp jr mq jv mr jz ms mt mu mv dt translated">给定参数<code class="eh kk kl km kn b">A</code> →期望函数返回值<code class="eh kk kl km kn b">B</code></li><li id="bb64" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated">给定参数<code class="eh kk kl km kn b">C</code> →期望函数返回值<code class="eh kk kl km kn b">D</code></li></ul><p id="d563" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个简单的例子是一个接收数字集合的函数，并期望它递增这个集合的每个元素。</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="050b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们接收<code class="eh kk kl km kn b">numbers</code>集合，使用<code class="eh kk kl km kn b">map</code>和<code class="eh kk kl km kn b">inc</code>函数递增每个数字，并返回一个新的递增数字列表。</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="bf65" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于<code class="eh kk kl km kn b">input</code> <code class="eh kk kl km kn b">[1 2 3 4 5]</code>，预期的<code class="eh kk kl km kn b">output</code>将是<code class="eh kk kl km kn b">[2 3 4 5 6]</code>。</p><h1 id="ed54" class="lb lc hu bd ld le lz lg lh li ma lk ll lm nw lo lp lq nx ls lt lu ny lw lx ly dt translated">不变</h1><blockquote class="ka"><p id="c725" class="kb kc hu bd kd ke kf kg kh ki kj jz ek translated">u<!-- -->n随时间变化或无法改变。</p></blockquote><figure class="oa ob oc od oe iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nz"><img src="../Images/d09c22b00fbe714942308d437cd87c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MGlzHgISuw0dXwsf"/></div></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">“Change neon light signage” by <a class="ae kt" href="https://unsplash.com/@rossf?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ross Findon</a> on <a class="ae kt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b3a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当数据不可变时，其<strong class="je hv">状态在创建后不能改变</strong> <em class="of"> </em> <strong class="je hv">。如果你想改变一个不可变的对象，你不能。相反，<strong class="je hv">你用新值创建一个新对象。</strong></strong></p><p id="1675" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Javascript中，我们通常使用<code class="eh kk kl km kn b">for</code>循环。下一个<code class="eh kk kl km kn b">for</code>语句有一些可变变量。</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="a24f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于每次迭代，我们都要改变<code class="eh kk kl km kn b">i</code>和<code class="eh kk kl km kn b">sumOfValue</code>和<strong class="je hv">状态</strong>。但是我们如何处理迭代中的可变性呢？递归！回到Clojure！</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="4901" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以这里我们有接收数值向量的<code class="eh kk kl km kn b">sum</code>函数。<code class="eh kk kl km kn b">recur</code>跳回<code class="eh kk kl km kn b">loop</code>直到我们得到空的向量(<a class="ae kt" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursive_functions_and_algorithms" rel="noopener ugc nofollow" target="_blank">我们的递归</a> <code class="eh kk kl km kn b"><a class="ae kt" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursive_functions_and_algorithms" rel="noopener ugc nofollow" target="_blank">base case</a></code>)。对于每次“迭代”,我们将把值添加到<code class="eh kk kl km kn b">total</code>累加器中。</p><p id="4821" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用递归，我们保持我们的<strong class="je hv">变量</strong> <em class="of"> </em>不可变。</p><p id="4ac0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">观察</strong>:是的！我们可以用<code class="eh kk kl km kn b">reduce</code>来实现这个功能。我们将在<code class="eh kk kl km kn b">Higher Order Functions</code>主题中看到这一点。</p><p id="c398" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">构建对象的最终<strong class="je hv">状态</strong>也很常见。假设我们有一个字符串，我们想把这个字符串转换成一个<code class="eh kk kl km kn b">url slug</code>。</p><p id="27b9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Ruby的OOP中，我们会创建一个类，比如说，<code class="eh kk kl km kn b">UrlSlugify</code>。这个类将有一个<code class="eh kk kl km kn b">slugify!</code>方法将字符串输入转换成一个<code class="eh kk kl km kn b">url slug</code>。</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="6a6a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">漂亮！已经落实了！这里我们有命令式编程，确切地说明我们在每个<code class="eh kk kl km kn b">slugify</code>进程中想要做什么——首先是小写，然后删除无用的空格，最后用连字符替换剩余的空格。</p><p id="a0c9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是我们在这个过程中改变了输入状态。</p><p id="8c52" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以通过函数组合或函数链接来处理这种变异。换句话说，一个函数的结果将被用作下一个函数的输入，而不修改原始的输入字符串。</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="e331" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里我们有:</p><ul class=""><li id="fc2f" class="mn mo hu je b jf jg jj jk jn mp jr mq jv mr jz ms mt mu mv dt translated"><code class="eh kk kl km kn b">trim</code>:删除字符串两端的空白</li><li id="9e0f" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><code class="eh kk kl km kn b">lower-case</code>:将字符串转换为全部小写</li><li id="d86f" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><code class="eh kk kl km kn b">replace</code>:用给定字符串中的替换替换match的所有实例</li></ul><p id="4fca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将这三个函数结合起来，我们可以<code class="eh kk kl km kn b">"slugify"</code>我们的字符串。</p><p id="fcf5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">说到<strong class="je hv">组合函数</strong>，我们可以用<code class="eh kk kl km kn b">comp</code>函数来组合这三个函数。让我们来看看:</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><h1 id="207e" class="lb lc hu bd ld le lz lg lh li ma lk ll lm nw lo lp lq nx ls lt lu ny lw lx ly dt translated">对透明性有关的</h1><figure class="mf mg mh mi fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff og"><img src="../Images/9dfbac25433991767421bfb12b0eafd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K0VAbQjAwmKZb1at"/></div></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">“person holding eyeglasses” by <a class="ae kt" href="https://unsplash.com/@joshcala?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Josh Calabrese</a> on <a class="ae kt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cfaf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们实现一个<code class="eh kk kl km kn b">square function</code>:</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="dc6e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">给定相同的输入，这个(纯)函数将总是具有相同的输出。</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="5a31" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将“2”作为参数传递给<code class="eh kk kl km kn b">square function</code>将始终返回4。所以现在我们可以用4代替<code class="eh kk kl km kn b">(square 2)</code>。就是这样！我们的功能是<code class="eh kk kl km kn b">referentially transparent</code>。</p><p id="b451" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基本上，如果一个函数对于相同的输入始终产生相同的结果，那么它就是参照透明的。</p><p id="b5bb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">纯函数+不可变数据=参照透明</strong></p><p id="8187" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了这个概念，我们可以做的一件很酷的事情就是记忆这个函数。想象我们有这个函数:</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="27a8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kk kl km kn b">(+ 5 8)</code>等于<code class="eh kk kl km kn b">13</code>。该功能将始终导致<code class="eh kk kl km kn b">13</code>。所以我们可以这样做:</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="37b7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">而这个表达式总会产生<code class="eh kk kl km kn b">16</code>。我们可以用一个数字常数替换整个表达式，然后<a class="ae kt" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">记忆它。</a></p><h1 id="fa29" class="lb lc hu bd ld le lz lg lh li ma lk ll lm nw lo lp lq nx ls lt lu ny lw lx ly dt translated">作为一级实体发挥作用</h1><figure class="mf mg mh mi fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oh"><img src="../Images/aa3c7d75c309cac5f358392d88050f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K6m1Ftw54Wm6tfFB"/></div></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">“first-class” by <a class="ae kt" href="https://unsplash.com/@andrewtneel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andrew Neel</a> on <a class="ae kt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="41c1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将函数作为一级实体的想法是，函数<strong class="je hv">也被</strong>视为值<strong class="je hv">，而</strong>被用作数据。</p><p id="4bf4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Clojure中，通常使用<code class="eh kk kl km kn b">defn</code>来定义函数，但这只是对<code class="eh kk kl km kn b">(def foo (fn ...))</code>的语法修饰。<code class="eh kk kl km kn b">fn</code>返回函数本身。<code class="eh kk kl km kn b">defn</code>返回一个指向函数对象的<code class="eh kk kl km kn b">var</code>。</p><p id="dda9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为一级实体的功能可以:</p><ul class=""><li id="dcba" class="mn mo hu je b jf jg jj jk jn mp jr mq jv mr jz ms mt mu mv dt translated">从常量和变量中引用它</li><li id="2ee9" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated">将其作为参数传递给其他函数</li><li id="de1f" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated">从其他函数返回结果</li></ul><p id="b2af" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">其思想是将函数视为值，并像传递数据一样传递函数。通过这种方式，我们可以组合不同的功能来创建具有新行为的新功能。</p><p id="bd32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我们有一个函数，它将两个值相加，然后将值加倍。大概是这样的:</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="ae8e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在是一个减去数值并返回双精度值的函数:</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="05f4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些函数具有相似的逻辑，但不同之处在于运算符函数。如果我们可以将函数视为值，并将它们作为参数传递，我们就可以构建一个接收操作符函数的函数，并在函数内部使用它。让我们建造它！</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="9e19" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">搞定了。现在我们有了一个<code class="eh kk kl km kn b">f</code>参数，并用它来处理<code class="eh kk kl km kn b">a</code>和<code class="eh kk kl km kn b">b</code>。我们传递了<code class="eh kk kl km kn b">+</code>和<code class="eh kk kl km kn b">-</code>函数来与<code class="eh kk kl km kn b">double-operator</code>函数组合并创建一个新的行为。</p><h1 id="3cd4" class="lb lc hu bd ld le lz lg lh li ma lk ll lm nw lo lp lq nx ls lt lu ny lw lx ly dt translated">高阶函数</h1><p id="7cdd" class="pw-post-body-paragraph jc jd hu je b jf np jh ji jj nq jl jm jn nr jp jq jr ns jt ju jv nt jx jy jz hn dt translated">当我们谈到高阶函数时，我们指的是这样的函数:</p><ul class=""><li id="0494" class="mn mo hu je b jf jg jj jk jn mp jr mq jv mr jz ms mt mu mv dt translated">接受一个或多个函数作为参数，或者</li><li id="5b36" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated">返回一个函数作为结果</li></ul><p id="8b3a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们上面实现的<code class="eh kk kl km kn b">double-operator</code>函数是一个高阶函数，因为它将一个操作符函数作为参数并使用它。</p><p id="90d3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可能已经听说过<code class="eh kk kl km kn b">filter</code>、<code class="eh kk kl km kn b">map</code>和<code class="eh kk kl km kn b">reduce</code>。让我们看看这些。</p><h2 id="8437" class="nb lc hu bd ld nc nd ne lh nf ng nh ll jn ni nj lp jr nk nl lt jv nm nn lx no dt translated">过滤器</h2><p id="0e1b" class="pw-post-body-paragraph jc jd hu je b jf np jh ji jj nq jl jm jn nr jp jq jr ns jt ju jv nt jx jy jz hn dt translated">给定一个集合，我们希望按属性过滤。filter函数期望一个<code class="eh kk kl km kn b">true</code>或<code class="eh kk kl km kn b">false</code>值来确定元素<strong class="je hv">是否应该包含在结果集合中。基本上，如果回调表达式是<code class="eh kk kl km kn b">true</code>，过滤函数会将元素包含在结果集合中。否则，不会。</strong></p><p id="d98d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个简单的例子是，当我们有一个整数集合，我们只想要偶数。</p><p id="6c0a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">命令式方法</strong></p><p id="fa1f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用Javascript实现这一点的一个必要方法是:</p><ul class=""><li id="e2d3" class="mn mo hu je b jf jg jj jk jn mp jr mq jv mr jz ms mt mu mv dt translated">创建一个空矢量<code class="eh kk kl km kn b">evenNumbers</code></li><li id="8659" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated">迭代<code class="eh kk kl km kn b">numbers</code>向量</li><li id="5a56" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated">将偶数推送到<code class="eh kk kl km kn b">evenNumbers</code>向量</li></ul><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="23e5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以使用<code class="eh kk kl km kn b">filter</code>高阶函数来接收<code class="eh kk kl km kn b">even?</code>函数，并返回一个偶数列表:</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="d14b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我在<a class="ae kt" href="https://www.hackerrank.com/domains/fp" rel="noopener ugc nofollow" target="_blank">黑客等级FP </a>路径上解决的一个有趣的问题是<a class="ae kt" href="https://www.hackerrank.com/challenges/fp-filter-array/problem" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">过滤数组问题</strong> </a>。问题的想法是过滤一个给定的整数数组，只输出那些小于指定值<code class="eh kk kl km kn b">X</code>的值。</p><p id="3700" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个问题的一个强制性Javascript解决方案是这样的:</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="1275" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们确切地说出了我们的函数需要做什么——迭代集合，将集合当前项与<code class="eh kk kl km kn b">x</code>进行比较，如果它通过了条件，则将该元素推送到<code class="eh kk kl km kn b">resultArray</code>。</p><p id="dcaa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">声明式方法</strong></p><p id="a848" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是我们想要一个更加声明性的方法来解决这个问题，并且使用<code class="eh kk kl km kn b">filter</code>高阶函数。</p><p id="633e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个声明性的Clojure解决方案应该是这样的:</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="2659" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个语法一开始看起来有点奇怪，但是很容易理解。</p><p id="979a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kk kl km kn b">#(&gt; x %)</code>只是一个匿名函数，它接收<code class="eh kk kl km kn b">x</code>，并将其与集合中的每个元素进行比较。<code class="eh kk kl km kn b">%</code>表示匿名函数的参数——在本例中是<code class="eh kk kl km kn b">filter</code>中的当前元素。</p><p id="6507" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们也可以用地图来做这件事。假设我们有一张地图，上面有人们的<code class="eh kk kl km kn b">name</code>和<code class="eh kk kl km kn b">age</code>。我们希望只过滤超过指定年龄值的人，在本例中是21岁以上的人。</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="4d63" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">代码摘要:</p><ul class=""><li id="9be4" class="mn mo hu je b jf jg jj jk jn mp jr mq jv mr jz ms mt mu mv dt translated">我们有一份人员名单(带<code class="eh kk kl km kn b">name</code>和<code class="eh kk kl km kn b">age</code>)。</li><li id="468c" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated">我们有匿名函数<code class="eh kk kl km kn b">#(&lt; 21 (:age %))</code>。还记得<code class="eh kk kl km kn b">%</code>代表集合中的当前元素吗？这个系列的元素是一个人物地图。如果我们执行<code class="eh kk kl km kn b">(:age {:name "TK" :age 26})</code>，它将返回年龄值，在本例中为<code class="eh kk kl km kn b">26</code>。</li><li id="77c5" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated">我们根据这个匿名函数过滤所有人。</li></ul><h2 id="0232" class="nb lc hu bd ld nc nd ne lh nf ng nh ll jn ni nj lp jr nk nl lt jv nm nn lx no dt translated">地图</h2><p id="5efa" class="pw-post-body-paragraph jc jd hu je b jf np jh ji jj nq jl jm jn nr jp jq jr ns jt ju jv nt jx jy jz hn dt translated">映射的思想是转换一个集合。</p><blockquote class="ka"><p id="4789" class="kb kc hu bd kd ke kf kg kh ki kj jz ek translated"><code class="eh kk kl km kn b">map</code>方法通过对集合的所有元素应用一个函数并从返回值构建一个新的集合来转换集合。</p></blockquote><p id="d704" class="pw-post-body-paragraph jc jd hu je b jf ko jh ji jj kp jl jm jn kq jp jq jr kr jt ju jv ks jx jy jz hn dt translated">让我们得到上面相同的<code class="eh kk kl km kn b">people</code>集合。我们现在不想按“超龄”来过滤。我们只是想要一个字符串列表，类似于<code class="eh kk kl km kn b">TK is 26 years old</code>。所以最终的字符串可能是<code class="eh kk kl km kn b">:name is :age years old</code>，其中<code class="eh kk kl km kn b">:name</code>和<code class="eh kk kl km kn b">:age</code>是来自<code class="eh kk kl km kn b">people</code>集合中每个元素的属性。</p><p id="caec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">按照强制的Javascript方式，应该是:</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="9df1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以声明性的Clojure方式，它应该是:</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="94bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">整个想法是将一个给定的集合转换成一个新的集合。</p><p id="3871" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个有趣的黑客排名问题是<a class="ae kt" href="https://www.hackerrank.com/challenges/fp-update-list/problem" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">更新列表问题</strong> </a>。我们只想用给定集合的绝对值来更新它们的值。</p><p id="1726" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">比如输入<code class="eh kk kl km kn b">[1 2 3 -4 5]</code>需要输出为<code class="eh kk kl km kn b">[1 2 3 4 5]</code>。<code class="eh kk kl km kn b">-4</code>的绝对值是<code class="eh kk kl km kn b">4</code>。</p><p id="73b5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个简单的解决方案是对每个集合值进行就地更新。</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="d51f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们使用<code class="eh kk kl km kn b">Math.abs</code>函数将值转换成绝对值，并进行就地更新。</p><p id="53c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是<strong class="je hv">而不是</strong>实现这个解决方案的功能性方法。</p><p id="e129" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们学习了不变性。我们知道不变性对于使我们的函数更加一致和可预测是多么重要。这个想法是建立一个包含所有绝对值的新集合。</p><p id="7e60" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二，这里为什么不用<code class="eh kk kl km kn b">map</code>来“转换”所有数据？</p><p id="7a3b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我的第一个想法是构建一个只处理一个值的<code class="eh kk kl km kn b">to-absolute</code>函数。</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="f318" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果它是负的，我们想把它转换成正值(绝对值)。否则，我们不需要改造它。</p><p id="2f38" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">既然我们知道如何为一个值做<code class="eh kk kl km kn b">absolute</code>，我们可以使用这个函数作为参数传递给<code class="eh kk kl km kn b">map</code>函数。你还记得a <code class="eh kk kl km kn b">higher order function</code>可以接收一个函数作为参数并使用它吗？是的，地图可以做到！</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="bb1c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">哇哦。太美了！😍</p><h2 id="e061" class="nb lc hu bd ld nc nd ne lh nf ng nh ll jn ni nj lp jr nk nl lt jv nm nn lx no dt translated">减少</h2><p id="65d9" class="pw-post-body-paragraph jc jd hu je b jf np jh ji jj nq jl jm jn nr jp jq jr ns jt ju jv nt jx jy jz hn dt translated">reduce的思想是接收一个函数和一个集合，并返回通过组合这些项而创建的值。</p><p id="2a21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">人们谈论的一个常见例子是获取订单的总金额。想象你在一个购物网站上。您已经将<code class="eh kk kl km kn b">Product 1</code>、<code class="eh kk kl km kn b">Product 2</code>、<code class="eh kk kl km kn b">Product 3</code>和<code class="eh kk kl km kn b">Product 4</code>添加到您的购物车(订单)中。现在我们要计算购物车的总金额。</p><p id="cb49" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在命令式方法中，我们将迭代订单列表，并将每个产品的金额加到总金额中。</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="f0f3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用<code class="eh kk kl km kn b">reduce</code>，我们可以构建一个函数来处理<code class="eh kk kl km kn b">amount sum</code>，并将其作为参数传递给<code class="eh kk kl km kn b">reduce</code>函数。</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="4f03" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里我们有<code class="eh kk kl km kn b">shopping-cart</code>，接收当前<code class="eh kk kl km kn b">total-amount</code>的函数<code class="eh kk kl km kn b">sum-amount</code>，以及<code class="eh kk kl km kn b">current-product</code>对象来<code class="eh kk kl km kn b">sum</code>它们。</p><p id="d9ee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kk kl km kn b">get-total-amount</code>功能用于使用<code class="eh kk kl km kn b">sum-amount</code>从<code class="eh kk kl km kn b">0</code>开始<code class="eh kk kl km kn b">reduce</code>到<code class="eh kk kl km kn b">shopping-cart</code>。</p><p id="d6e5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一种得到总量的方法是将<code class="eh kk kl km kn b">map</code>和<code class="eh kk kl km kn b">reduce</code>合成。我这么说是什么意思？我们可以使用<code class="eh kk kl km kn b">map</code>将<code class="eh kk kl km kn b">shopping-cart</code>转换成一个<code class="eh kk kl km kn b">amount</code>值的集合，然后只需将<code class="eh kk kl km kn b">reduce</code>函数与<code class="eh kk kl km kn b">+</code>函数一起使用。</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="19e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kk kl km kn b">get-amount</code>接收产品对象并只返回<code class="eh kk kl km kn b">amount</code>值。所以我们这里有<code class="eh kk kl km kn b">[10 30 20 60]</code>。然后<code class="eh kk kl km kn b">reduce</code>将所有项目相加。漂亮！</p><p id="969e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们看了一下每个高阶函数是如何工作的。我想向你们展示一个例子，我们如何在一个简单的例子中组合所有三个函数。</p><p id="4960" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">谈到<code class="eh kk kl km kn b">shopping cart</code>，假设我们的订单中有以下产品列表:</p><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="c85f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们需要购物车中所有书籍的总数。就这么简单。算法？</p><ul class=""><li id="c511" class="mn mo hu je b jf jg jj jk jn mp jr mq jv mr jz ms mt mu mv dt translated"><strong class="je hv">按书籍类型过滤</strong></li><li id="0ded" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated">使用<strong class="je hv">映射</strong>将购物车转换为金额集合</li><li id="1bc0" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated">用<strong class="je hv">减少</strong>将所有项目相加</li></ul><figure class="mf mg mh mi fq iv"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="065f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">搞定了。🎉</p><h1 id="b8a5" class="lb lc hu bd ld le lz lg lh li ma lk ll lm nw lo lp lq nx ls lt lu ny lw lx ly dt translated">资源</h1><p id="f8f4" class="pw-post-body-paragraph jc jd hu je b jf np jh ji jj nq jl jm jn nr jp jq jr ns jt ju jv nt jx jy jz hn dt translated">我整理了一些我阅读和研究的资源。我正在分享一些我觉得非常有趣的照片。更多资源，请访问我的<a class="ae kt" href="https://github.com/LeandroTk/learning-functional-programming" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">函数式编程Github资源库</strong> </a>。</p><ul class=""><li id="81dc" class="mn mo hu je b jf jg jj jk jn mp jr mq jv mr jz ms mt mu mv dt translated"><a class="ae kt" href="https://github.com/LeandroTk/learning-functional-programming/tree/master/ruby" rel="noopener ugc nofollow" target="_blank">红宝石特有资源</a></li><li id="f85e" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="https://github.com/LeandroTk/learning-functional-programming/tree/master/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript特定资源</a></li><li id="80cb" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="https://github.com/LeandroTk/learning-functional-programming/tree/master/clojure" rel="noopener ugc nofollow" target="_blank"> Clojure特定资源</a></li></ul><h2 id="30ff" class="nb lc hu bd ld nc nd ne lh nf ng nh ll jn ni nj lp jr nk nl lt jv nm nn lx no dt translated">介绍</h2><ul class=""><li id="f10d" class="mn mo hu je b jf np jj nq jn oi jr oj jv ok jz ms mt mu mv dt translated"><a class="ae kt" href="https://www.youtube.com/watch?v=e-5obm1G_FY" rel="noopener ugc nofollow" target="_blank">在JS中学习FP</a></li><li id="0ba4" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="https://codewords.recurse.com/issues/one/an-introduction-to-functional-programming" rel="noopener ugc nofollow" target="_blank">用Python介绍do FP</a></li><li id="bc6a" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="https://blog.codeship.com/overview-of-functional-programming" rel="noopener ugc nofollow" target="_blank">FP概述</a></li><li id="97d1" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="https://hackernoon.com/a-quick-introduction-to-functional-javascript-7e6fe520e7fa" rel="noopener ugc nofollow" target="_blank">功能JS快速介绍</a></li><li id="ac4e" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0">什么是FP？</a></li><li id="d114" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="https://github.com/hemanth/functional-programming-jargon" rel="noopener ugc nofollow" target="_blank">函数式编程行话</a></li></ul><h2 id="58aa" class="nb lc hu bd ld nc nd ne lh nf ng nh ll jn ni nj lp jr nk nl lt jv nm nn lx no dt translated">纯函数</h2><ul class=""><li id="54b5" class="mn mo hu je b jf np jj nq jn oi jr oj jv ok jz ms mt mu mv dt translated"><a class="ae kt" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976">什么是纯函数？</a></li><li id="a29a" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="https://www.fpcomplete.com/blog/2017/04/pure-functional-programming" rel="noopener ugc nofollow" target="_blank">纯函数编程1 </a></li><li id="9f9d" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="https://www.fpcomplete.com/blog/2017/05/pure-functional-programming-part-2" rel="noopener ugc nofollow" target="_blank">纯函数编程2 </a></li></ul><h2 id="79d9" class="nb lc hu bd ld nc nd ne lh nf ng nh ll jn ni nj lp jr nk nl lt jv nm nn lx no dt translated">不可变数据</h2><ul class=""><li id="ec9f" class="mn mo hu je b jf np jj nq jn oi jr oj jv ok jz ms mt mu mv dt translated"><a class="ae kt" href="https://www.youtube.com/watch?v=Wo0qiGPSV-s" rel="noopener ugc nofollow" target="_blank">用于函数式编程的不可变DS</a></li><li id="fc28" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="http://henrikeichenhardt.blogspot.com/2013/06/why-shared-mutable-state-is-root-of-all.html" rel="noopener ugc nofollow" target="_blank">为什么共享可变状态是万恶之源</a></li><li id="58a0" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="http://hypirion.com/musings/understanding-persistent-vector-pt-1" rel="noopener ugc nofollow" target="_blank">clo jure中的结构共享:第1部分</a></li><li id="4dec" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated">Clojure中的结构共享:第二部分</li><li id="b4da" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="http://hypirion.com/musings/understanding-persistent-vector-pt-3" rel="noopener ugc nofollow" target="_blank">clo jure中的结构共享:第3部分</a></li><li id="4472" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="http://hypirion.com/musings/persistent-vector-performance-summarised" rel="noopener ugc nofollow" target="_blank">clo jure中的结构共享:最终部分</a></li></ul><h2 id="fcc7" class="nb lc hu bd ld nc nd ne lh nf ng nh ll jn ni nj lp jr nk nl lt jv nm nn lx no dt translated">高阶函数</h2><ul class=""><li id="f328" class="mn mo hu je b jf np jj nq jn oi jr oj jv ok jz ms mt mu mv dt translated"><a class="ae kt" href="https://eloquentjavascript.net/05_higher_order.html" rel="noopener ugc nofollow" target="_blank">雄辩的JS:高阶函数</a></li><li id="8fc8" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="https://www.youtube.com/watch?v=BMUiFMZr7vk&amp;t=0s&amp;list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84&amp;index=2&amp;ab_channel=FunFunFunction" rel="noopener ugc nofollow" target="_blank">趣味趣味功能滤镜</a></li><li id="0926" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="https://www.youtube.com/watch?v=bCqtb-Z5YGQ&amp;index=2&amp;list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84&amp;ab_channel=FunFunFunction" rel="noopener ugc nofollow" target="_blank">趣味趣味功能图</a></li><li id="f013" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="https://www.youtube.com/watch?v=Wl98eZpkp-c&amp;list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84&amp;index=3&amp;frags=wn&amp;ab_channel=FunFunFunction" rel="noopener ugc nofollow" target="_blank">趣味趣味功能基本减少</a></li><li id="68d6" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="https://www.youtube.com/watch?v=1DMolJ2FrNY&amp;list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84&amp;index=4&amp;ab_channel=FunFunFunction" rel="noopener ugc nofollow" target="_blank">趣味趣味功能高级减少</a></li><li id="8dc0" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="https://clojure.org/guides/higher_order_functions" rel="noopener ugc nofollow" target="_blank"> Clojure高阶函数</a></li><li id="fa24" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="https://purelyfunctional.tv/lesson/filter/" rel="noopener ugc nofollow" target="_blank">纯函数过滤器</a></li><li id="22cd" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="https://purelyfunctional.tv/lesson/map/" rel="noopener ugc nofollow" target="_blank">纯功能图</a></li><li id="d5e8" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><a class="ae kt" href="https://purelyfunctional.tv/lesson/reduce/" rel="noopener ugc nofollow" target="_blank">纯粹功能性减少</a></li></ul><h2 id="0f5c" class="nb lc hu bd ld nc nd ne lh nf ng nh ll jn ni nj lp jr nk nl lt jv nm nn lx no dt translated">声明式编程</h2><ul class=""><li id="5ed4" class="mn mo hu je b jf np jj nq jn oi jr oj jv ok jz ms mt mu mv dt translated"><a class="ae kt" href="https://tylermcginnis.com/imperative-vs-declarative-programming/" rel="noopener ugc nofollow" target="_blank">声明式编程vs命令式编程</a></li></ul><h1 id="af32" class="lb lc hu bd ld le lz lg lh li ma lk ll lm nw lo lp lq nx ls lt lu ny lw lx ly dt translated">就是这样！</h1><p id="c6c5" class="pw-post-body-paragraph jc jd hu je b jf np jh ji jj nq jl jm jn nr jp jq jr ns jt ju jv nt jx jy jz hn dt translated">嘿，朋友们，我希望你们在阅读这篇文章的时候有乐趣，并且我希望你们在这里学到了很多！这是我尝试分享我所学到的东西。</p><p id="8d32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kt" href="https://github.com/LeandroTk/functional-programming-article-source-code" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">这里是本文中所有代码</strong> </a>的存储库。</p><p id="9758" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">来跟我学吧。我在这个<a class="ae kt" href="https://github.com/LeandroTk/learning-functional-programming" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">学习函数式编程库</strong> </a>里共享资源和我的代码。</p><p id="d48e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望你在这里看到了对你有用的东西。下次再见！:)</p></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><blockquote class="ka"><p id="8ff3" class="kb kc hu bd kd ke kf kg kh ki kj jz ek translated"><a class="ae kt" href="https://ko-fi.com/teekay" rel="noopener ugc nofollow" target="_blank">我希望你喜欢这个内容。支持我在高保真方面的工作</a></p></blockquote></div><div class="ab cl ku kv hc kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hn ho hp hq hr"><p id="eb20" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我的<a class="ae kt" href="https://twitter.com/LeandroTk_" rel="noopener ugc nofollow" target="_blank">Twitter</a>&amp;<a class="ae kt" href="https://github.com/LeandroTk" rel="noopener ugc nofollow" target="_blank">Github</a>。☺</p><p id="aeef" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">TK。</p></div></div>    
</body>
</html>