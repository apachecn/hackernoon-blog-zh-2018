<html>
<head>
<title>Defense Against Dark Arts —The Mirror of Erised</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">黑魔法防御——厄里斯魔镜</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/defense-against-dark-arts-the-mirror-of-erised-7d65fc6a333d?source=collection_archive---------11-----------------------#2018-12-23">https://medium.com/hackernoon/defense-against-dark-arts-the-mirror-of-erised-7d65fc6a333d?source=collection_archive---------11-----------------------#2018-12-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/8ebf2db874314cc38e2684922149f0d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R-mOEUvIP6HtUyXTDUHNMg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">The Mirror of Erised from Harry Potter and the Sorcerer’s Stone</figcaption></figure><p id="cacf" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">就像在哈利波特传奇中一样，我们被未知的食死徒(read黑客)包围，他们出于这样或那样的原因试图攻击可怜的波特(read客户端/数据)。有时他们想要数据(像足球之石或凤凰社中的预言)，或者有时他们只是想杀死/腐蚀波特以抵御威胁/竞争。无论是哪种情况，我们都需要保护我们的数据和深度学习模型免受这种黑暗攻击。</p><p id="d232" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">常规的深度学习模型非常容易受到攻击，因为它通常在训练深度学习模型的集中式服务器中收集大量数据。这被称为集中学习，因为学习发生在中央服务器上。但是通过一种叫做联合学习的技术，我们不是把数据带到模型中，而是把模型带到训练数据中。</p><p id="e3c8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在这篇文章中，我将向你解释一个来自<a class="ae ke" href="https://github.com/OpenMined/PySyft" rel="noopener ugc nofollow" target="_blank"> PySyft </a>库的例子，带你走过联合学习的一小步。具体来说，我们将看到一个名为“Bob”的终端客户端如何让一个集中式服务器使用其数据，而实际上却不必共享它。当我们浏览这个例子时，你会理解得更多。</p><p id="a91b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在本教程中，我们将使用两台Jupyter笔记本。一个用于“Bob”(Bob . ipynb)，他将准备其数据，引用其数据，其中数据(实际上是其指针)可以被中央服务器使用，并最终打开连接，其中它可以接收中央服务器的请求。另一方面，集中式服务器也将有一个文件(Model.ipynb)在其终端运行，该文件将首先与Bob的套接字建立连接，获取指向实际数据的指针，最后仅使用指针变量运行其算法。</p><p id="3b2d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> Bob.ipynb </strong></p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="f9fa" class="ko kp hu kk b fv kq kr l ks kt">##### Import files#############<br/>import syft as sy<br/>hook = sy.TorchHook() # Start a hook to make a connection</span><span id="c190" class="ko kp hu kk b fv ku kr l ks kt">"""#########################<br/>Give your hook a <strong class="kk hv">id</strong>: “Bob”<br/><strong class="kk hv">Port Address</strong>: 3000<br/><strong class="kk hv">is_pointer</strong>: Will update more about it<br/><strong class="kk hv">is_client_worker</strong>:(bool, optional)** a boolean which determines                             whether this worker is associated with an end user client. If so,                             it assumes that the client will maintain control over when                             tensors/variables/models are instantiated or deleted as opposed to                             handling tensor/variable/model lifecycle internally<br/><strong class="kk hv">verbose:</strong>(bool, optional)** A flag for whether or not to print events to stdout.<br/>##########################"""</span><span id="cb9e" class="ko kp hu kk b fv ku kr l ks kt">hook.local_worker = sy.SocketWorker(hook=hook,<br/>                                   id="Bob",<br/>                                   port=3000,<br/>                                   is_pointer=False,<br/>                                   is_client_worker=False,<br/>                                   verbose=True)<br/>sy.local_worker = hook.local_worker</span><span id="d031" class="ko kp hu kk b fv ku kr l ks kt"># create two sample Pytorch tensors for our demonstration<br/>import torch<br/>x = torch.FloatTensor([1, 2, 3, 4, 5])<br/>y = torch.FloatTensor([1, 1, 1, 1, 1])</span></pre><p id="e209" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">检查向bob注册对象列表，这是验证我们刚刚创建的张量是否正确配置给Bob的简单方法。</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="2058" class="ko kp hu kk b fv kq kr l ks kt">hook.local_worker._objects</span></pre><p id="0342" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">输出:<br/>{ 38610448342:[_ local tensor—id:38610448342所有者:Bob]，<br/>51021230807:[_ local tensor—id:51021230807所有者:Bob]}</p><p id="0860" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">结果清楚地表明，我们作为本地张量创建的x和y张量归Bob所有。</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="db92" class="ko kp hu kk b fv kq kr l ks kt"># Set ID with which client can request for pointers for our tensors</span><span id="b1bb" class="ko kp hu kk b fv ku kr l ks kt">x.set_id("#X")<br/>y.set_id("#Y")</span><span id="559a" class="ko kp hu kk b fv ku kr l ks kt"># start listening to commands and wait for magic to happen!</span><span id="bbd4" class="ko kp hu kk b fv ku kr l ks kt">hook.local_worker.listen()</span></pre><p id="0d67" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> Model.ipynb </strong></p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="0445" class="ko kp hu kk b fv kq kr l ks kt"># Give yourself a name and port address<br/>import syft as sy<br/>hook = sy.TorchHook(local_worker = sy.SocketWorker(id=0, port=3001))</span><span id="bec5" class="ko kp hu kk b fv ku kr l ks kt"># Connect with Bob<br/>remote_client = sy.SocketWorker(hook=hook,<br/>                               id="Bob",<br/>                               port=3000,<br/>                               is_pointer=True)<br/>hook.local_worker.add_worker(remote_client)</span><span id="2caf" class="ko kp hu kk b fv ku kr l ks kt"># Get pointer variables for actual data<br/>x_set = remote_client.search(["#X"])<br/>y_set = remote_client.search(["#Y"])</span></pre><p id="748d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果您尝试访问x_set或y_set，您将立即看到类似以下的消息</p><p id="9ab0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">[float tensor[_ pointer tensor—id:22003035565 owner:0 loc:Bob id @ loc:# Y]]</p><p id="5978" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">意思是说y_set是“PointerTensor”(而不是Y的实际值)，你是这个指针的所有者，但是实际数据的“location”是“Bob”，它的ID是#Y</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="c481" class="ko kp hu kk b fv kq kr l ks kt"># Perform Tensor Operation on actual data using pointer variables</span><span id="cb33" class="ko kp hu kk b fv ku kr l ks kt">import torch<br/>z = torch.add(x_set[0],y_set[0])<br/>z</span></pre><p id="6905" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">output:<br/>float tensor[_ pointer tensor—id:12443450818 owner:0 loc:Bob id @ loc:30395812931]</p><p id="36ac" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">同样，在我们试图访问y_set的情况下，当你试图访问z的值时，你会得到上面的消息</p><pre class="kf kg kh ki fq kj kk kl km aw kn dt"><span id="9afb" class="ko kp hu kk b fv kq kr l ks kt"># To get actual value of z<br/>z.get()</span></pre><p id="1def" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当您对bob的数据执行所有这些操作时，每当您试图访问Bob的数据时，Bob都会收到类似“Received Command From:(' 127 . 0 . 0 . 1 '，54484)" <br/>的通知。与此同时，还会生成一个日志文件。</p><p id="9fea" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">仅此而已。在这个小例子中，我们看到了如何使用PySyft来获得Bob数据的指针变量，对其执行操作(运行深度学习模型)并获得结果。从隐私的角度来看，这是一个很大的进步，因为在这个完整的操作中，没有人能够访问Bob的实际数据内容。</p><p id="037b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">事后看来，我们上面的节目与第一部电影中的<strong class="ji hv">厄里斯魔镜</strong>非常相似，因为<strong class="ji hv">会给你你想要的东西…..只要你不(错误)使用它！</strong></p><p id="bb67" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在就这样，如果你设法和我呆在一起到目前为止，我鼓励你去<a class="ae ke" href="https://github.com/OpenMined/PySyft" rel="noopener ugc nofollow" target="_blank"> PySyft </a> github页面并开始深入了解它。你可以在我的github repo <a class="ae ke" href="https://github.com/PercyJaiswal/PySyft" rel="noopener ugc nofollow" target="_blank">这里</a>找到两款Jupyter笔记本的完整代码。</p><p id="7578" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">像往常一样，如果你喜欢我的文章，用喜欢和评论来表达你的欣赏。你也可以在<a class="ae ke" href="https://twitter.com/percyjaiswal" rel="noopener ugc nofollow" target="_blank"> twitter </a>上找到我和我的其他文章。</p><p id="83bd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">直到下一次…干杯！！</p></div></div>    
</body>
</html>