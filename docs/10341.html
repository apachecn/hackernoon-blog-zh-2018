<html>
<head>
<title>Binary Search In Detail</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二分搜索法的细节</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/binary-search-in-detail-914944a1434a?source=collection_archive---------1-----------------------#2018-12-25">https://medium.com/hackernoon/binary-search-in-detail-914944a1434a?source=collection_archive---------1-----------------------#2018-12-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/fdb0f369dc2f9945df70c8c7bbbff794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DOR__3reJYPwGuyytG520g.jpeg"/></div></div></figure><p id="362d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望我们都对二分搜索法有所了解。但是我不会一步一步地解释这个算法，相反，我会深入了解二分搜索法是如何工作和使用的。</p><p id="0219" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看看:<a class="ae ka" href="http://geeksforgeeks.org/binary-search" rel="noopener ugc nofollow" target="_blank">geeksforgeeks.org/binary-search</a>如果你不知道二分搜索法。</p><p id="afcd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">给定一个已排序的数组，我们找到最中间的元素并用键检查该元素。如果最中间的元素等于key，我们就找到了key。如果最中间的元素大于键，我们在最中间的元素的左半部分搜索，否则在右半部分搜索。</p><p id="fe24" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是Java中二分搜索法的迭代代码</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div></figure><p id="d3e5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，在第6行，我们使用</p><pre class="kb kc kd ke fq kh ki kj kk aw kl dt"><span id="5211" class="km kn hu ki b fv ko kp l kq kr">int mid = (low + high) / 2;</span></pre><p id="ce32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是这样计算mid是无效的。为什么？我们举个例子。<br/>让我们取整数从整数低到整数高(两者都包括)。</p><p id="ffd7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意第3列和第4列中的公式计算出的中间值。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div></figure><ul class=""><li id="1e27" class="ks kt hu je b jf jg jj jk jn ku jr kv jv kw jz kx ky kz la dt translated">对于low = 3和high = 11，元素数量(#elements) = 9 <br/>，因此只有1个mid，即7个<br/> *两个公式都正确计算了mid</li><li id="a4ff" class="ks kt hu je b jf lb jj lc jn ld jr le jv lf jz kx ky kz la dt translated">对于low = 3和high = 10，#elements = 8 <br/>，因此有2个mid，6个(较低mid)和7个(较高mid) <br/> *两个公式都正确计算了较低mid</li><li id="4f68" class="ks kt hu je b jf lb jj lc jn ld jr le jv lf jz kx ky kz la dt translated">对于low = -11和high = -3，#elements = 9 <br/>，因此只有1个mid，即-7 <br/> *两个公式都正确计算了mid</li><li id="764b" class="ks kt hu je b jf lb jj lc jn ld jr le jv lf jz kx ky kz la dt translated">对于low = -10和high = -3，#elements = 8 <br/>，因此有2个mid，-7(较低的mid)和-8(较高的mid) <br/> *公式<code class="eh lg lh li ki b">(low + high) / 2</code>未能正确计算较低的mid，但另一个公式计算正确。</li></ul><p id="2033" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，我们应该始终使用下面的公式来计算较低的mid，因为它要可靠得多:</p><pre class="kb kc kd ke fq kh ki kj kk aw kl dt"><span id="e50a" class="km kn hu ki b fv ko kp l kq kr">int mid = low + ((high - low)/2);</span></pre><p id="6f32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当#elements =奇数时，我们只有1个mid。所以我们可以用上面的公式来计算mid。<br/>当#elements =偶数时，上面的公式只给出了较低的mid。<br/>较高的mid可通过以下公式计算:</p><pre class="kb kc kd ke fq kh ki kj kk aw kl dt"><span id="3cc5" class="km kn hu ki b fv ko kp l kq kr">int mid2 = low + ((high - low + 1) / 2);</span></pre></div><div class="ab cl lj lk hc ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hn ho hp hq hr"><p id="66d5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，有趣的部分…</p><p id="7d92" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们回到二分搜索法的迭代代码。注意三件事。<br/> 1。我们如何在低处和高处移动<br/> 2。我们如何计算mid <br/> 3。while循环中的条件</p><p id="c263" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">二分搜索法的美丽就在于这三样东西。让我们进一步探讨这个问题。</p><p id="b726" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于一个简单的二分搜索法，我们只需要找到数组中的元素，<br/>我们使用下面的:<br/> 1。<code class="eh lg lh li ki b">low = mid - 1</code>为移动<code class="eh lg lh li ki b">low</code>为移动<br/>为2。<code class="eh lg lh li ki b">high = mid + 1</code>为动<code class="eh lg lh li ki b">high</code>为动<br/> 3。<code class="eh lg lh li ki b">mid = low + ((high - low) / 2)</code>(为什么？<br/>以上讨论)4。<code class="eh lg lh li ki b">low &lt;= high</code>在while循环中</p><p id="efb9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们对二分搜索法总是使用同样的条件吗？这取决于我们的问题陈述。</p><p id="d600" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">示例#1:</p><p id="56c0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">给定一个整数x，在一个大小为N的数组中找到满足条件<code class="eh lg lh li ki b">y &lt;= x</code>的最大元素y</p><p id="11bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">解决方案:</p><p id="633a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们知道x可能不在数组中。所以给定数组中x的简单二分搜索法不起作用。但对二分搜索法来说，我们只知道x，关键。我们需要找到数组中最接近x并且小于或等于x的元素(如果它存在的话)。</p><p id="83ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用二分搜索法时，你应该记住三件事。应该如何低移高？<br/> 2。我们应该如何计算mid？<br/> 3。while循环中的条件是什么？</p><p id="0807" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lq">我们总是从“如何在低位和高位移动？”然后了解如何计算mid以及while条件是什么。而不是相反。</em></p><ol class=""><li id="e711" class="ks kt hu je b jf jg jj jk jn ku jr kv jv kw jz lr ky kz la dt translated"><em class="lq">如何移低移高？</em> <br/>当<code class="eh lg lh li ki b">array[mid] &lt; x</code>时，有可能当前元素可能就是答案(因为y可以小于x)。<br/>所以，我们不应该在低位运行时丢弃mid。<br/>于是，低就变成了<code class="eh lg lh li ki b">low = mid</code>，而不是<code class="eh lg lh li ki b">low = mid + 1</code> <br/>高保持不变，因为它与我们的问题陈述无关。</li><li id="6af1" class="ks kt hu je b jf lb jj lc jn ld jr le jv lf jz lr ky kz la dt translated"><em class="lq">如何计算mid？<br/> </em>当我们使用<code class="eh lg lh li ki b">mid = low + ((high - low) / 2)</code>时，我们是在计算较低的mid。因此，当数组中的#元素为偶数时，<br/> <code class="eh lg lh li ki b">if(array[mid] &gt; x)</code>变为false，因此控制将转到else子句，其中<code class="eh lg lh li ki b">low = mid</code>。这会导致无限循环。(为什么？举个例子)<br/>因此，我们取较高的mid，即<code class="eh lg lh li ki b">mid = low + ((high - low + 1) / 2)</code></li><li id="d5c4" class="ks kt hu je b jf lb jj lc jn ld jr le jv lf jz lr ky kz la dt translated"><em class="lq">while循环中的条件是什么？<br/> </em>由于我们是在low中存储小于等于x的最大元素，所以当low = high时应该停止，返回<code class="eh lg lh li ki b">array[low]</code>或<code class="eh lg lh li ki b">array[high]</code>。因此，while循环中的条件是<code class="eh lg lh li ki b">low &lt; high</code>。</li></ol><p id="c5ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Java中的解决方案如下所示:</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div></figure><p id="18e0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">示例2:</p><p id="effd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">给定一个整数x，在大小为N的数组中找到满足条件<code class="eh lg lh li ki b">y &gt;= x</code>的最小元素y</p><p id="444f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">解决方案:</p><p id="8eb3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用我们在示例1中使用的类似分析方法(自己尝试一下)，我们可以说</p><ol class=""><li id="fb5e" class="ks kt hu je b jf jg jj jk jn ku jr kv jv kw jz lr ky kz la dt translated"><code class="eh lg lh li ki b">low = mid + 1</code>用于移动低位</li><li id="60df" class="ks kt hu je b jf lb jj lc jn ld jr le jv lf jz lr ky kz la dt translated"><code class="eh lg lh li ki b">high = mid</code>用于移动高位</li><li id="9580" class="ks kt hu je b jf lb jj lc jn ld jr le jv lf jz lr ky kz la dt translated"><code class="eh lg lh li ki b">mid = low + ((high - low) / 2)</code>用于计算mid</li><li id="d986" class="ks kt hu je b jf lb jj lc jn ld jr le jv lf jz lr ky kz la dt translated"><code class="eh lg lh li ki b">low &lt; high</code>对于while循环中的条件</li></ol><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div></figure></div><div class="ab cl lj lk hc ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hn ho hp hq hr"><p id="bbe7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，我们可以将使用二分搜索法的不同场景列表如下:</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kf kg l"/></div></figure><p id="4784" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请随意试验这些条件，我希望您已经对如何使用二分搜索法有所了解。</p><p id="c86d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">合十礼！</p></div></div>    
</body>
</html>