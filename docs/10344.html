<html>
<head>
<title>JSON Lines format: Why jsonl is better than a regular JSON for web scraping</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JSON Lines格式:为什么jsonl比普通JSON更适合网络抓取</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/json-lines-format-76353b4e588d?source=collection_archive---------0-----------------------#2018-12-26">https://medium.com/hackernoon/json-lines-format-76353b4e588d?source=collection_archive---------0-----------------------#2018-12-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/51f845efd5b6f31ca6f673fbbd292e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*no0tVa_RVMdNVT8k9ZJhfg.png"/></div></div></figure><h1 id="55ab" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">CSV和JSON格式介绍</h1><p id="8322" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated"><strong class="kc hv">逗号分隔值(CSV)格式</strong>是一种常用的数据交换格式，广泛用于表示具有相同字段列表的记录集。</p><p id="c94c" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">JavaScript Object Notation(JSON)</strong>如今已经成为事实上的数据交换格式标准，取代了在21世纪初非常流行的XML。它不仅是自描述的，也是人类可读的。</p><p id="c537" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">让我们看看这两种格式的例子。</p><p id="8399" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">以下是以CSV数据表示的系列列表:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="44bb" class="lm jd hu li b fv ln lo l lp lq">id,father,mother,children<br/>1,Mark,Charlotte,1<br/>2,John,Ann,3<br/>3,Bob,Monika,2</span></pre><p id="bfd6" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">CSV看起来比下面显示的<a class="ae lr" href="https://hackernoon.com/tagged/json" rel="noopener ugc nofollow" target="_blank"> JSON </a>数组模拟简单得多:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="9a51" class="lm jd hu li b fv ln lo l lp lq">[<br/>   {"id":1,"father":"Mark","mother":"Charlotte","children":1},<br/>   {"id":2,"father":"John","mother":"Ann","children":3},<br/>   {"id":3,"father":"Bob","mother":"Monika","children":2},<br/>]</span></pre><p id="83ee" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">但是CSV仅限于存储二维的无类型数据。没有任何方法可以在普通CSV中存储嵌套结构或类型的值，比如孩子的名字。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="a097" class="lm jd hu li b fv ln lo l lp lq">[<br/>   {"id":1,"father":"Mark","mother":"Charlotte","children":["Tom"]},<br/>   {"id":2,"father":"John","mother":"Ann","children":["Jessika","Antony","Jack"]},<br/>   {"id":3,"father":"Bob","mother":"Monika","children":["Jerry","Karol"]},<br/>]</span></pre><p id="2a48" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">不过，在JSON文件中表示嵌套结构很容易。</p><p id="8d7f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">为什么不用一个常规的json数组来包围整个数据，这样文件本身就是有效的JSON？</strong></p><blockquote class="ls"><p id="fda9" class="lt lu hu bd lv lw lx ly lz ma mb kx ek translated">为了从JSON数组中插入或读取记录，您必须解析整个文件，这远非理想。</p><p id="b90d" class="lt lu hu bd lv lw lx ly lz ma mb kx ek translated">因为JSON行中的每个条目都是有效的JSON，所以它可以作为独立的JSON文档进行解析/解组。例如，您可以在其中进行搜索，将一个10gb的文件分割成较小的文件，而无需解析整个文件。</p><p id="6407" class="lt lu hu bd lv lw lx ly lz ma mb kx ek translated">1.解析之前不需要读取内存中的整个文件。2.您可以通过简单地向文件追加内容来轻松地向文件中添加更多的行。如果整个文件是一个JSON数组，那么您必须解析它，添加新行，然后转换回JSON。</p></blockquote></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><blockquote class="ls"><p id="38ca" class="lt lu hu bd lv lw lx ly lz ma mb kx ek translated">因此，将几千兆字节作为单个JSON数组是不实际的。考虑到Dataflow kit用户需要存储和解析大量数据，我们实现了将<a class="ae lr" href="https://github.com/slotix/dataflowkit/issues/11" rel="noopener ugc nofollow" target="_blank">导出为JSONL格式</a>。</p></blockquote><figure class="mk ml mm mn mo iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mj"><img src="../Images/ffa56bc31731b71f364a4e3b16df37a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y7Wjyoa_EscL2vahRlZVyw.png"/></div></div></figure><p id="8cf7" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv"> JSON lines (jsonl)、换行符分隔的JSON (ndjson)、换行符分隔的JSON (ldjson) </strong>是三个术语，表示主要用于JSON流的相同格式。</p><p id="3c0b" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">让我们看看<strong class="kc hv"> JSON Lines </strong>是什么，以及它与其他JSON流格式相比如何。</p><h2 id="2f58" class="lm jd hu bd je mp mq mr ji ms mt mu jm kl mv mw jq kp mx my ju kt mz na jy nb dt translated">JSON行与JSON</h2><p id="1ca5" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">表示为<strong class="kc hv"> JSON行</strong>格式的完全相同的系列列表如下所示:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="94ce" class="lm jd hu li b fv ln lo l lp lq">{"id":1,"father":"Mark","mother":"Charlotte","children":["Tom"]}<br/>{"id":2,"father":"John","mother":"Ann","children":["Jessika","Antony","Jack"]}<br/>{"id":3,"father":"Bob","mother":"Monika","children":["Jerry","Karol"]}</span></pre><p id="1240" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv"> JSON行</strong>本质上由几行组成，每一行都是一个有效的JSON对象，由换行符<code class="eh nc nd ne li b">`\n`</code>分隔。</p><p id="7197" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">它不需要定制的解析器。只需读取一行，解析为JSON，读取一行，解析为JSON…等等。</p><p id="d5c0" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">实际上在工业中使用<code class="eh nc nd ne li b">jsonl</code>已经是非常普遍的了</p><p id="a549" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">点击下面的链接可以找到更多关于JSON lines规范的细节。</p><div class="nf ng fm fo nh ni"><a href="http://jsonlines.org" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab ej"><div class="nk ab nl cl cj nm"><h2 class="bd hv fv z el nn eo ep no er et ht dt translated">JSON行</h2><div class="np l"><h3 class="bd b fv z el nn eo ep no er et ek translated">本页描述了JSON行文本格式，也称为换行符分隔的JSON。JSON Lines是一种方便的格式…</h3></div><div class="nq l"><p class="bd b gc z el nn eo ep no er et ek translated">jsonlines.org</p></div></div></div></a></div><h2 id="604f" class="lm jd hu bd je mp mq mr ji ms mt mu jm kl mv mw jq kp mx my ju kt mz na jy nb dt translated">JSON行与JSON文本序列</h2><p id="aec9" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">让我们比较一下<strong class="kc hv"> JSON文本序列格式</strong>和相关媒体类型“application/json-seq”与<a class="ae lr" href="https://hackernoon.com/tagged/ndjson" rel="noopener ugc nofollow" target="_blank"> NDJSON </a>。它由任意数量的JSON文本组成，都用UTF-8编码，每个文本都以ASCII记录分隔符(0x1E)为前缀，每个文本都以ASCII换行符(0x0A)结束。</p><p id="869f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">让我们看看上面提到的人员列表，用JSON-sequence文件表示:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="847c" class="lm jd hu li b fv ln lo l lp lq">&lt;RS&gt;{"id":1,"father":"Mark","mother":"Charlotte","children":["Tom"]}&lt;LF&gt;<br/>&lt;RS&gt;{"id":2,"father":"John","mother":"Ann","children":["Jessika","Antony","Jack"]}&lt;LF&gt;<br/>&lt;RS&gt;{"id":3,"father":"Bob","mother":"Monika","children":["Jerry","Karol"]}&lt;LF&gt;</span></pre><p id="c9c5" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这里是不可打印的ASCII记录分隔符(0x1E)的占位符。<code class="eh nc nd ne li b">&lt;LF&gt;</code>代表换行符。</p><p id="ab52" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">除了每个记录开头的这个特殊符号之外，该格式看起来几乎与JSON行相同。</p><p id="e4f1" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">由于这两种格式如此相似，你可能想知道为什么它们都存在？</p><p id="e477" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><em class="nr"> JSON文本序列</em>格式用于流上下文。所以这种格式没有定义相应的文件扩展名。虽然JSON文本序列格式规范注册了新的MIME媒体类型<code class="eh nc nd ne li b">application/json-seq.</code>，但是在文本编辑器中存储和编辑这种格式很容易出错，因为不可打印的(0x1E)字符可能是乱码。</p><p id="6f6e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">您可以考虑始终使用JSON行作为替代。</p><h2 id="db4f" class="lm jd hu bd je mp mq mr ji ms mt mu jm kl mv mw jq kp mx my ju kt mz na jy nb dt translated">JSON行与连接的JSON</h2><p id="457e" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">JSON行的另一个替代方法是<strong class="kc hv">级联JSON。</strong>在这种格式中，每个JSON文本根本没有相互分离。</p><p id="beb3" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">下面是上面一个例子的级联JSON表示:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="22aa" class="lm jd hu li b fv ln lo l lp lq">{"id":1,"father":"Mark","mother":"Charlotte","children":["Tom"]}{"id":2,"father":"John","mother":"Ann","children":["Jessika","Antony","Jack"]}{"id":3,"father":"Bob","mother":"Monika","children":["Jerry","Karol"]}</span></pre><p id="5050" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">串联JSON并不是一种新的格式，它只是一个没有任何分隔符的流多个JSON对象的名称。</p><p id="5b64" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">虽然生成JSON并不是一项复杂的任务，但是解析这种格式实际上需要很大的努力。事实上，您应该实现一个上下文感知的解析器，该解析器检测各个记录并正确地将它们相互分离。</p><h2 id="8415" class="lm jd hu bd je mp mq mr ji ms mt mu jm kl mv mw jq kp mx my ju kt mz na jy nb dt translated">印刷精美的JSON格式</h2><p id="a866" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">如果你有大的嵌套结构，那么不推荐直接阅读JSON行文本。使用<code class="eh nc nd ne li b">jq</code>工具使查看大型结构更容易:</p><p id="a022" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><code class="eh nc nd ne li b">grep . families.jsonl | jq</code></p><p id="2d93" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">因此，您会看到打印得非常漂亮的JSON文件:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="9a03" class="lm jd hu li b fv ln lo l lp lq">{<br/>  "id": 1,<br/>  "father": "Mark",<br/>  "mother": "Charlotte",<br/>  "children": [<br/>    "Tom"<br/>  ]<br/>}<br/>{<br/>  "id": 2,<br/>  "father": "John",<br/>  "mother": "Ann",<br/>  "children": [<br/>    "Jessika",<br/>    "Antony",<br/>    "Jack"<br/>  ]<br/>}<br/>{<br/>  "id": 3,<br/>  "father": "Bob",<br/>  "mother": "Monika",<br/>  "children": [<br/>    "Jerry",<br/>    "Karol"<br/>  ]<br/>}</span></pre><h1 id="d180" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">结论</h1><blockquote class="ls"><p id="e380" class="lt lu hu bd lv lw lx ly lz ma mb kx ek translated">从技术上讲，完整的JSON行文件作为一个整体不再是有效的JSON，因为它包含多个JSON文本。</p><p id="1a7f" class="lt lu hu bd lv lw lx ly lz ma mb kx ek translated">每一个新行都意味着一个单独的条目，这使得JSON Lines格式的文件是可流的。您可以根据需要读取任意多的行来获得相同数量的记录。</p></blockquote><div class="mk ml mm mn mo ni"><a href="https://dataflowkit.com" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab ej"><div class="nk ab nl cl cj nm"><h2 class="bd hv fv z el nn eo ep no er et ht dt translated">将网站转变为结构化数据/数据流套件</h2><div class="np l"><h3 class="bd b fv z el nn eo ep no er et ek translated">用Go写的Web抓取开源平台</h3></div><div class="nq l"><p class="bd b gc z el nn eo ep no er et ek translated">dataflowkit.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ja ni"/></div></div></a></div><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="ny nz l"/></div></figure></div></div>    
</body>
</html>