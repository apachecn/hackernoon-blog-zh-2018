<html>
<head>
<title>Scala Type Classes— The Name Printer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala类型类——名称打印机</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/scala-type-class-es-the-name-printer-beb0ea4dc4b0?source=collection_archive---------6-----------------------#2018-12-26">https://medium.com/hackernoon/scala-type-class-es-the-name-printer-beb0ea4dc4b0?source=collection_archive---------6-----------------------#2018-12-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/b9418aabb405a996f47be383971fa3b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*7CLE2hzlL7RtT-jhTwHOxg.png"/></div></figure><p id="f7cd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt jw translated">任何来自Java的人都会问什么是类型类，为什么使用它们，以及如何使用。这篇文章并不打算解释如何完全实现类型类，而是展示一个实际的例子，<strong class="ja hv">name-printer。</strong></p><p id="d6ba" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在之前的一篇文章<a class="ae kf" href="https://hackernoon.com/scala-object-serialization-for-mapr-db-792817d3962d" rel="noopener ugc nofollow" target="_blank"><strong class="ja hv"><em class="kg">MapR-DB的Scala对象序列化</em> </strong> </a>中，我们使用了一个简单的type类来解决在我们心爱的Scala中使用MapR-DB时遇到的序列化问题。现在，我们给出一个更简单的例子来展示类型类的<em class="kg"> why </em>和<em class="kg"> how </em>。</p><h1 id="d536" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">名称表示</h1><p id="a343" class="pw-post-body-paragraph iy iz hu ja b jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv hn dt translated">让我们从陈述正在讨论的问题开始。在这种情况下，我们有一个名为<code class="eh lk ll lm ln b">Name</code>的业务对象，正如您可能猜到的，它表示一个人的名字。我们可以用下面的类来表示某人的名字。</p><figure class="lo lp lq lr fq iv"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="70be" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在的问题是，一旦我们有了这个需求，我们要如何表示这个对象？</p><p id="01f7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于那些来自Java的人来说，答案很简单，我们需要覆盖<code class="eh lk ll lm ln b">.toString</code>函数，问题就解决了。实际上，比这要复杂得多。</p><p id="f26a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">根据特定的上下文，相同的名称可以用不同的方式表示。例如，<code class="eh lk ll lm ln b">Nicola A Perez</code>在正式场合可能是<code class="eh lk ll lm ln b">Mr. Perez</code>，或者在非常社交化的环境中可能是<code class="eh lk ll lm ln b">Nico</code>。有时，完全相同的名称可能必须被完全寻址，而其他时候(web id)它可能只是<code class="eh lk ll lm ln b">anicolaspp</code>。</p><p id="2fc0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果我们试图将表示附加到<code class="eh lk ll lm ln b">Name</code>对象本身，我们肯定会每次都很短，因为总会有我们没有考虑的上下文。</p><p id="ca70" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个想法是解耦对象及其可能的表示，同时启用多态机制在需要时将它们紧密结合在一起，即使我们无法访问类本身的原始源代码。</p><h1 id="4841" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">可打印类型类</h1><p id="ce52" class="pw-post-body-paragraph iy iz hu ja b jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv hn dt translated">我们可以从定义一个特征开始，这个特征表示我们将在这个例子中使用的类型类。</p><figure class="lo lp lq lr fq iv"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="171a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在上面的代码片段中，我们已经定义了可能的表示的接口，现在让我们看看如何实现其中的一些。</p><figure class="lo lp lq lr fq iv"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="c56d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如我们所见，我们添加了多种方式来表示名称。现在我们可以在不同的上下文中使用它们。让我们定义一些函数，每个函数接收一个名字并打印出来。注意，每个函数代表上下文本身。</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><figure class="lo lp lq lr fq iv"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="0865" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">重要的是要注意，每个函数都知道上下文，并使用它来获得正确的打印机，以便根据函数表示的上下文正确地表示名称。</p><p id="692b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">有趣的是，我们给<code class="eh lk ll lm ln b">name</code>对象添加了<code class="eh lk ll lm ln b">.asString</code>函数。仅当给定类型的相应隐式存在时，此即席功能才可用。添加发生在编译时，Scala编译器能够查看上下文以选择可能的类型添加。</p><p id="9fe9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后，我们可以看到所有的事情是如何一起发生的。</p><figure class="lo lp lq lr fq iv"><div class="bz el l di"><div class="ls lt l"/></div></figure><h1 id="247f" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">结论</h1><p id="be0e" class="pw-post-body-paragraph iy iz hu ja b jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv hn dt translated">Scala强大的类型系统允许超越我们在Java或大多数编程语言中所能做的任何事情，同时在编译时保持类型安全。</p><p id="8618" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在我们的特殊情况下，类型类也是一种非常好且有趣的方式，可以在不修改原始代码的情况下向现有对象添加功能。在Java中，使用继承可以部分地做到这一点，但是这个问题并没有完全解决，而且在大多数情况下，如果类型被标记为final，这甚至是不可能的。</p><p id="f142" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最终，我们将动态地向我们的对象添加功能，并且只有当我们启用正确的上下文时，该功能才可用。同样，这远远超出了您在大多数编程语言中所能做的任何事情，尤其是在类型安全领域。</p></div></div>    
</body>
</html>