<html>
<head>
<title>Arcsecond: Parsing in JavaScript made easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">arc second:JavaScript解析变得简单</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/arcsecond-parsing-in-javascript-made-easy-af1894bdcec9?source=collection_archive---------1-----------------------#2018-12-27">https://medium.com/hackernoon/arcsecond-parsing-in-javascript-made-easy-af1894bdcec9?source=collection_archive---------1-----------------------#2018-12-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/05f298eefef37a7235661bb1117ff090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*tsHrUKwQXG1YZX0l957ISw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Gandalf should have used arcsecond</figcaption></figure><p id="a0f1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我最近开始认真尝试学习Haskell(任何以前尝试过的人可能都会同意，通常需要尝试几次才能破解它)。在Haskell提供的许多很酷的东西中，有一个令人惊叹的解析库，它附带了一组标准的包，名为<a class="ae ke" href="https://wiki.haskell.org/Parsec" rel="noopener ugc nofollow" target="_blank"><strong class="ji hv">【Parsec】</strong></a><strong class="ji hv">，</strong>，让您可以描述如何用看起来像自然语言的方式解析复杂的语法。</p><p id="927b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">下面是如何使用Parsec实现CSV解析器。如果您不理解所有的语法，也不要担心，关键是整个解析器只用四行代码就指定了。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">If you want to read more checkout <a class="ae ke" href="http://book.realworldhaskell.org" rel="noopener ugc nofollow" target="_blank">http://book.realworldhaskell.org</a></figcaption></figure><p id="ac3b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然而，这篇文章不是关于Haskell，<a class="ae ke" href="https://github.com/francisrstokes/arcsecond" rel="noopener ugc nofollow" target="_blank">而是我写的一个名为<strong class="ji hv"> arcsecond </strong>的库，它基于Parsec </a>，目标是给JavaScript带来同样的表现力。</p><h1 id="01c1" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">解析器组合子</h1><p id="a483" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated"><strong class="ji hv"> arcsecond </strong>是一个解析器组合子库，在这个库中可以通过组合简单的解析器来构建复杂的解析器。最简单的解析器只匹配特定的字符串或字符:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="e2e6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然后可以用库中的<em class="lo">组合器</em>将它们组合在一起。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="5c2f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然后新的解析器可以用于文本:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><h2 id="3870" class="lp km hu bd kn lq lr ls kr lt lu lv kv jr lw lx kz jv ly lz ld jz ma mb lh mc dt translated">组合子</h2><p id="9e3e" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">组合子是它变酷的地方。在<strong class="ji hv"> arcsecond </strong>中，组合子是一个更高阶的解析器，它接受一个或多个解析器作为其输入，并返回一个新的解析器，这个解析器以某种方式组合了这些解析器。如果你已经在react中使用了<em class="lo">高阶组件</em>，比如<strong class="ji hv"> <em class="lo">连接</em> </strong>、<strong class="ji hv"> <em class="lo">与路由器</em> </strong>，或者<strong class="ji hv"> <em class="lo">与样式</em> </strong>，那么你已经熟悉这个想法了。</p><p id="fee4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如上所示，<strong class="ji hv"><em class="lo"/></strong>的sequenceOf是一个组合器，它将按顺序使用每个解析器解析文本，并将它们的结果收集到一个数组中。</p><p id="3884" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="lo"> choice </em> </strong>则相反，会按顺序尝试它的每个解析器，并使用第一个匹配的解析器。这个库包含更多，像<strong class="ji hv"> <em class="lo"> many </em> </strong>，它接受一个解析器作为参数，并使用该解析器尽可能多地匹配，将结果收集到一个数组中:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="254c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">您可以使用<strong class="ji hv"> <em class="lo"> sepBy </em> </strong>来创建一个解析器，该解析器匹配由<em class="lo">另一个解析器</em>匹配的内容所分隔的项目。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="e2d9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="lo"> between </em> </strong>将让您匹配发生在<em class="lo">两个其他解析器</em>之间的项目。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><h2 id="8145" class="lp km hu bd kn lq lr ls kr lt lu lv kv jr lw lx kz jv ly lz ld jz ma mb lh mc dt translated">简化的功能</h2><p id="56cf" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated"><strong class="ji hv"> arcsecond </strong>利用了curried函数。如果你不知道什么是curried函数，可以看看我的文章“<a class="ae ke" href="https://hackernoon.com/making-functional-programming-click-836d4715baf2" rel="noopener ugc nofollow" target="_blank">制作函数式编程点击</a>”。如果你现在真的不能被打扰，在另一个标签中打开它，阅读这个执行摘要。</p><p id="ebfe" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">curried函数是这样一种函数，如果它接受多个参数，它将返回一个接受下一个参数的新函数。用一些代码更容易看出:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="f508" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">上面可以看到，<strong class="ji hv"> <em class="lo"> curriedAdd </em> </strong>是先用1调用的。因为它随后返回一个函数，我们可以继续用2调用它，最终返回实际的结果。</p><p id="50ab" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们可以使用<strong class="ji hv"> <em class="lo"> curriedAdd </em> </strong>来创建一个新函数，只需用一个参数调用它，然后将结果赋给一个变量。作为一种语言，JavaScript将函数视为一等公民，这意味着它们可以被传递和赋给变量。</p><p id="a37e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这个原则是<strong class="ji hv"> arcsecond，</strong>的核心，库中的每个函数都是这样定义的。<strong class="ji hv"> <em class="lo"> sepBy </em> </strong>采用两个解析器——第一个是分隔符解析器，第二个是值解析器。因为它是curried，所以只需提供第一个参数，就可以很容易地创建一个更具体的组合子，如<strong class="ji hv"><em class="lo">commaSeparated</em></strong>。</p><blockquote class="md me mf"><p id="4ab0" class="jg jh lo ji b jj jk jl jm jn jo jp jq mg js jt ju mh jw jx jy mi ka kb kc kd hn dt translated">如果你不习惯，可能会觉得奇怪。但是作为一名软件开发人员，一个很好的教训是不要对你不能立即理解的事情产生下意识的不良反应。通常都有一个原因，你会发现发现这个原因比忽视它更有价值。</p></blockquote><h1 id="83e9" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">错误处理</h1><p id="0936" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">如果你试图解析一个格式不正确的字符串，你会得到某种错误信息。<strong class="ji hv"> arcsecond </strong>使用一种特殊的数据类型叫做an<strong class="ji hv"><em class="lo"/></strong>，也就是<em class="lo"/>一个值或者一个错误。这就像一个<strong class="ji hv"> <em class="lo">的承诺</em> </strong>，既可以拒绝，也可以解决，但没有不同步的暗示。然而在一个<strong class="ji hv"> <em class="lo">或者</em> </strong>中，“已解决”类型被称为右<strong class="ji hv"><em class="lo"/></strong>，“已拒绝”类型被称为左<strong class="ji hv"><em class="lo"/></strong>。</p><p id="f20a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="lo">解析</em> </strong>的返回类型是一个要么。您可以像这样获得值或误差:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="0abe" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然而，如果你没有更多的功能代码，这可能不适合你的代码库。出于这个原因，还有另外两个选择。首先是将<strong class="ji hv"><em class="lo"/></strong>转换成<strong class="ji hv"> <em class="lo">许诺:</em> </strong></p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="41eb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">或者您可以使用<strong class="ji hv"> <em class="lo"> toValue，</em> </strong>它必须包含在一个try/catch块中:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><h1 id="9b4d" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">更复杂的东西:JSON</h1><p id="bd26" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">让我们用arcsecond为JSON创建一个解析器来测试一下它。</p><blockquote class="md me mf"><p id="5570" class="jg jh lo ji b jj jk jl jm jn jo jp jq mg js jt ju mh jw jx jy mi ka kb kc kd hn dt translated"><a class="ae ke" href="https://gist.github.com/francisrstokes/4d5f5b2de9644cf547799e3ac85fc6e2" rel="noopener ugc nofollow" target="_blank"> <em class="hu">单击此处跳过，在一个文件中查看完整的JSON解析器</em> </a></p></blockquote><h2 id="3851" class="lp km hu bd kn lq lr ls kr lt lu lv kv jr lw lx kz jv ly lz ld jz ma mb lh mc dt translated">价值观念</h2><p id="0e8a" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">JSON只有7个可能的值:</p><ul class=""><li id="9c66" class="mj mk hu ji b jj jk jn jo jr ml jv mm jz mn kd mo mp mq mr dt translated">线</li><li id="d266" class="mj mk hu ji b jj ms jn mt jr mu jv mv jz mw kd mo mp mq mr dt translated">数字</li><li id="06d4" class="mj mk hu ji b jj ms jn mt jr mu jv mv jz mw kd mo mp mq mr dt translated">真实的</li><li id="0a7a" class="mj mk hu ji b jj ms jn mt jr mu jv mv jz mw kd mo mp mq mr dt translated">错误的</li><li id="ef8e" class="mj mk hu ji b jj ms jn mt jr mu jv mv jz mw kd mo mp mq mr dt translated">空</li><li id="706b" class="mj mk hu ji b jj ms jn mt jr mu jv mv jz mw kd mo mp mq mr dt translated">排列</li><li id="d60e" class="mj mk hu ji b jj ms jn mt jr mu jv mv jz mw kd mo mp mq mr dt translated">目标</li></ul><p id="1798" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">所以要编写一个JSON解析器，我们只需要为所有这些值编写解析器。</p><h2 id="a009" class="lp km hu bd kn lq lr ls kr lt lu lv kv jr lw lx kz jv ly lz ld jz ma mb lh mc dt translated">类型</h2><p id="8c4d" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">为了让我们的解析器有用，我们需要能够识别我们解析了什么，最好的方法是将结果放入数据类型中，这将为我们提供一个与JSON树交互的公共接口。每种类型都有一个<em class="lo">类型</em>名称、一个<em class="lo">值</em>和一个<em class="lo"> toString </em>函数来漂亮地打印结构。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="e76d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">有了我们的类型，让我们从最简单的解析器开始:<strong class="ji hv"> <em class="lo">真</em> </strong>，<strong class="ji hv"> <em class="lo">假</em> </strong>和<strong class="ji hv"> <em class="lo">空</em> </strong>。这些只是文字字符串:</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><blockquote class="md me mf"><p id="79e7" class="jg jh lo ji b jj jk jl jm jn jo jp jq mg js jt ju mh jw jx jy mi ka kb kc kd hn dt translated"><strong class="ji hv"> arcsecond </strong>中的解析器有一个<strong class="ji hv"> <em class="hu"> map </em> </strong>方法——就像数组一样——它允许您转换解析器匹配的值。使用<strong class="ji hv"> <em class="hu">映射</em> </strong>我们可以将匹配的值放入上面定义的数据类型中。</p></blockquote><p id="da32" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">数字有点复杂。JSON规范有一个铁路图，展示了如何解析一个数字:</p><figure class="kf kg kh ki fq iv fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/1faed16aa9794c57aec3cefa07c1713c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/1*tFuvEG2-YfBSMBPykulv9A.gif"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Credit: https://json.org</figcaption></figure><p id="8880" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">铁路上的岔道显示了可选性，所以可以匹配的最简单的数字是0。</p><p id="c56c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">基本上是这样的数字:</p><ul class=""><li id="c3e6" class="mj mk hu ji b jj jk jn jo jr ml jv mm jz mn kd mo mp mq mr dt translated"><em class="lo"> 1 </em></li><li id="5130" class="mj mk hu ji b jj ms jn mt jr mu jv mv jz mw kd mo mp mq mr dt translated"><em class="lo"> -0.2 </em></li><li id="a325" class="mj mk hu ji b jj ms jn mt jr mu jv mv jz mw kd mo mp mq mr dt translated"><em class="lo"> 3.42e2 </em></li><li id="9adb" class="mj mk hu ji b jj ms jn mt jr mu jv mv jz mw kd mo mp mq mr dt translated"><em class="lo"> -0.4352E-235 </em></li></ul><p id="1ff4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在JSON中都是有效的，而像<em class="lo"> 03.46 </em>这样的东西是无效的，因为铁路上没有允许这样做的路径。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="f1ef" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你花时间通读一下<strong class="ji hv"> <em class="lo"> numberParser </em> </strong>，你会发现它与上图几乎是1:1的关系。</p><p id="3cc2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来让我们试试弦乐。字符串是双引号之间的任何内容，但它也可以包含转义引号。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="51f5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"><em class="lo">any thing except</em></strong>解析器在这里非常方便，与JSON spec网站上的图片相比，它尤其具有表现力。</p><figure class="kf kg kh ki fq iv fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/486597da9930bff244d0223f38cd7cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/1*yCIr1X6WLFKB5USa76dnSA.gif"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Credit: <a class="ae ke" href="https://json.org" rel="noopener ugc nofollow" target="_blank">https://json.org</a></figcaption></figure><p id="452c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这样就只剩下数组和对象，这两者都是陷阱，因为它们基本上只是<strong class="ji hv"> <em class="lo"> jsonValue的容器。</em> </strong>为了说明这是如何出错的，我们可以先以“错误”的方式编写数组解析器，然后看看如何解决它。</p><p id="6fc8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们可以使用<strong class="ji hv"> <em class="lo">空格</em> </strong>解析器——它匹配零个或多个空格字符——来确保数组括号和逗号操作符允许可能存在的任何(可选)空格。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="b521" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因为<strong class="ji hv"> <em class="lo">数组解析器</em> </strong>是根据<strong class="ji hv"><em class="lo">JSON解析器</em> </strong>定义的，而<strong class="ji hv"><em class="lo">JSON解析器</em> </strong>是根据<strong class="ji hv"> <em class="lo">数组解析器</em> </strong>定义的，所以我们遇到了<em class="lo">引用错误</em>。如果我们把<strong class="ji hv"> <em class="lo"> arrayParser </em> </strong>的定义移到<strong class="ji hv"> <em class="lo"> jsonParser </em> </strong>下面，我们还是会有同样的问题。我们可以通过将<strong class="ji hv"> <em class="lo"> jsonParser </em> </strong>封装在一个特殊的解析器中来解决这个问题，这个解析器被恰当地命名为<strong class="ji hv"><em class="lo">recursiveParser</em></strong>。<a class="ae ke" href="https://en.wikipedia.org/wiki/Thunk" rel="noopener ugc nofollow" target="_blank">对<strong class="ji hv"><em class="lo">recursiveParser</em></strong>的参数是一个thunk </a>，它将允许我们引用还不在作用域内的变量。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="360f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">实现<strong class="ji hv"> <em class="lo"> arrayParser </em> </strong>实际上非常简单——就像方括号中用逗号分隔的JSON值一样简单。</p><p id="e6f2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">对象只是稍微复杂一点。对象中的值是成对的字符串(一些其他JSON值)，用冒号作为分隔符。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><p id="268b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">仅此而已。<strong class="ji hv"> <em class="lo"> jsonValue </em> </strong>可以用来解析一个完整的JSON文档。完整的解析器可以在这里找到。</p><h1 id="48cc" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">奖金解析器:CSV</h1><p id="4bd3" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">因为我在Haskell中打开了CSV解析器，所以让我们看看它在<strong class="ji hv"> arcsecond </strong>中会是什么样子。我将保持它的最小化，并放弃创建数据类型来保存值，以及一些Parsec版本也没有的额外增强。</p><p id="183b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">结果应该是一个数组的数组——外部数组保存“行”,内部数组包含行的元素。</p><figure class="kf kg kh ki fq iv"><div class="bz el l di"><div class="kj kk l"/></div></figure><h1 id="168e" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">结论</h1><p id="8598" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">有相当多的<strong class="ji hv"> arcsecond </strong>的关键特性在这篇文章中没有提到，包括它<a class="ae ke" href="https://en.wikipedia.org/wiki/Context-sensitive_grammar" rel="noopener ugc nofollow" target="_blank">可以解析上下文敏感语言</a>的事实，以及解析模型是基于一个<a class="ae ke" href="https://github.com/fantasyland/fantasy-land" rel="noopener ugc nofollow" target="_blank">幻想土地兼容单子</a>。这个项目的主要目标是给JavaScript带来与Parsec相同的表达能力，我希望我已经做到了。</p><p id="4e43" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="ae ke" href="https://github.com/francisrstokes/arcsecond" rel="noopener ugc nofollow" target="_blank">请在github上查看该项目以及所有的API文档和示例</a>，下次当你发现自己在编写一个难以理解的意面正则表达式时，想想<a class="ae ke" href="https://github.com/francisrstokes/arcsecond" rel="noopener ugc nofollow" target="_blank"><strong class="ji hv">arc second</strong></a>——你可能用错了工具！您可以通过以下方式安装最新版本:</p><blockquote class="md me mf"><p id="dce3" class="jg jh lo ji b jj jk jl jm jn jo jp jq mg js jt ju mh jw jx jy mi ka kb kc kd hn dt translated"><strong class="ji hv"> npm i arcsecond </strong></p></blockquote></div><div class="ab cl my mz hc na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hn ho hp hq hr"><p id="cf4e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="ae ke" href="https://twitter.com/fstokesman" rel="noopener ugc nofollow" target="_blank">在twitter @fstokesman上给我打电话</a>，给这篇文章一个👏如果你觉得有趣！我可能会写一篇关于<strong class="ji hv"> arcsecond </strong>内部如何工作的后续文章，敬请关注。</p></div></div>    
</body>
</html>