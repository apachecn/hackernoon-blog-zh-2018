<html>
<head>
<title>Create a Go Json Parser: Batteries Included</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个Go Json解析器:包括电池</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/create-a-go-json-parser-batteries-included-9d02d09fe508?source=collection_archive---------8-----------------------#2018-12-28">https://medium.com/hackernoon/create-a-go-json-parser-batteries-included-9d02d09fe508?source=collection_archive---------8-----------------------#2018-12-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e46320af7ca33a05254c96f8927a8779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CeP3A7A60m6Osl8miEkksQ.jpeg"/></div></div></figure><p id="15f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这篇文章的灵感来自于工作中的一个项目。我正在构建一个需要比较两个Json对象的服务。问题是我需要能够<strong class="je hv">替换键</strong>，<strong class="je hv">过滤出路径</strong>，并且<strong class="je hv">将比较函数</strong>应用到特定的节点。</p><p id="9ab7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">显然，像<code class="eh ka kb kc kd b">reflect.DeepEqual()</code>这样的标准库比较函数是行不通的。😧</p><p id="adfa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">解决方案是构建一个<strong class="je hv"> AST </strong> ( <em class="ke">抽象语法树</em>)模仿<strong class="je hv"> Json </strong>对象。树中的每个<code class="eh ka kb kc kd b">Node</code>代表一个<code class="eh ka kb kc kd b">string</code>、<code class="eh ka kb kc kd b">integer</code>、<code class="eh ka kb kc kd b">array</code>或<code class="eh ka kb kc kd b">object</code>。</p><p id="c90a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过这样做，我可以灵活地将<a class="ae kf" href="https://hackernoon.com/tagged/algorithms" rel="noopener ugc nofollow" target="_blank">算法</a>应用到数据上。</p><p id="9517" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了构建这个，我们将从生成<strong class="je hv">令牌</strong>的<strong class="je hv">词法分析器</strong>开始。然后转移到<strong class="je hv">解析器</strong>上，解析器将获取令牌并将它们与<strong class="je hv"> Json </strong>语法进行匹配。最后，我们将添加<strong class="je hv"> AST </strong>钩子来生成树。</p><p id="5e38" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最终的目录结构:</p><pre class="kg kh ki kj fq kk kd kl km aw kn dt"><span id="a1ec" class="ko kp hu kd b fv kq kr l ks kt">.<br/>main.go<br/>/lexer<br/>    lexer.go<br/>    lexer_test.go<br/>/token<br/>    token.go<br/>/parser<br/>    parser.go<br/>/ast<br/>    ast.go</span></pre><p id="7c4f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您想查看和运行最终结果:</p><pre class="kg kh ki kj fq kk kd kl km aw kn dt"><span id="8102" class="ko kp hu kd b fv kq kr l ks kt">cd $GOPATH/src/github.com/Lebonesco<br/>git clone <a class="ae kf" href="https://github.com/Lebonesco/json_parser.git" rel="noopener ugc nofollow" target="_blank">https://github.com/Lebonesco/json_parser.git</a><br/>go run main.go ./examples/test.json</span></pre><h1 id="e833" class="ku kp hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">词法分析程序</h1><p id="2313" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">lexer的工作是接收<a class="ae kf" href="https://hackernoon.com/tagged/json" rel="noopener ugc nofollow" target="_blank"> json </a>数据，并将其转换成<code class="eh ka kb kc kd b">tokens</code>流。这些令牌包括:<code class="eh ka kb kc kd b">INVALID</code>、<code class="eh ka kb kc kd b">EOF</code>、<code class="eh ka kb kc kd b">COMMA</code>、<code class="eh ka kb kc kd b">COLON</code>、<code class="eh ka kb kc kd b">LBRACE</code>、<code class="eh ka kb kc kd b">RBRACE</code>、<code class="eh ka kb kc kd b">LBRACKET</code>、<code class="eh ka kb kc kd b">RBRACKET</code>、<code class="eh ka kb kc kd b">STRING</code>和<code class="eh ka kb kc kd b">INTEGER</code>。</p><p id="3a68" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注:</strong>lexer也称为扫描仪。</p><p id="b2be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们从下面开始👇</p><pre class="kg kh ki kj fq kk kd kl km aw kn dt"><span id="1635" class="ko kp hu kd b fv kq kr l ks kt">cd $GOPATH/src/github.com/Lebonesco/json_parser<br/>mkdir token<br/>cd token<br/>touch token.go</span></pre><p id="3955" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在如何定义自己的<code class="eh ka kb kc kd b">tokens</code>方面，你有一些自由。添加到<code class="eh ka kb kc kd b">token</code>中的数据越多，调试就越容易。</p><p id="3797" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意:我们将使用一个<code class="eh ka kb kc kd b">rune</code>数组<code class="eh ka kb kc kd b">[]rune</code>来存储我们的<code class="eh ka kb kc kd b">token</code>文字，以支持<strong class="je hv"> Unicode </strong>字符。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="9ca8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，让我们跳进我们的<code class="eh ka kb kc kd b">lexer</code>👍</p><pre class="kg kh ki kj fq kk kd kl km aw kn dt"><span id="e537" class="ko kp hu kd b fv kq kr l ks kt">mkdir lexer<br/>cd lexer<br/>touch lexer.go<br/>touch lexer_test.go</span></pre><p id="4e25" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ka kb kc kd b">lexer</code>将跟踪我们在输入中的位置，必要的字符向前看。</p><p id="3b14" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就功能而言，它需要能够创建一个新的<code class="eh ka kb kc kd b">token</code>，并在下一个之前达到峰值。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="84c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注意:</strong>该扫描仪不支持<strong class="je hv">布尔</strong>值，但可以轻松添加。</p><h2 id="a4b7" class="ko kp hu bd kv ly lz ma kz mb mc md ld jn me mf lh jr mg mh ll jv mi mj lp mk dt translated">莱克斯试验</h2><p id="25d1" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">这里我们将接受一个j <strong class="je hv"> son </strong>字符串，并确保它输出正确的令牌流。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="f05d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要运行测试:</p><pre class="kg kh ki kj fq kk kd kl km aw kn dt"><span id="0e94" class="ko kp hu kd b fv kq kr l ks kt">go test -v<br/>=== RUN   TestLexer<br/>--- PASS: TestLexer (0.00s)<br/>PASS<br/>ok      github.com/Lebonesco/json_parser/lexer  0.433s</span></pre><p id="51df" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你现在有了一个可以工作的lexer🎉 🎉 🎉</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="ml lx l"/></div></figure><h1 id="81ef" class="ku kp hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">句法分析程序</h1><p id="044a" class="pw-post-body-paragraph jc jd hu je b jf lr jh ji jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz hn dt translated">这是我们获取流并将其与<strong class="je hv"> json语法</strong>匹配以产生<strong class="je hv"> AST </strong>节点的部分。</p><p id="c830" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们用正则表达式来定义json，它将由下面定义的语法来表示👇</p><pre class="kg kh ki kj fq kk kd kl km aw kn dt"><span id="980e" class="ko kp hu kd b fv kq kr l ks kt">JSON : value<br/>Value :  Object | Array | String | Integer | Bool | Null<br/>Array : '[' [Value] {',' Value}']'<br/>Object : '{' [Property] {',' Property} '}'<br/>Property : String ':' Value</span></pre><p id="e92e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的语法中，<code class="eh ka kb kc kd b">[expression]</code>表示表达式出现一次或多次，<code class="eh ka kb kc kd b">{expression}</code>表示出现零次或多次。</p><p id="4763" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你提供正则表达式，有像<code class="eh ka kb kc kd b">gocc</code>这样的工具可以生成词法分析器和/或语法分析器。如果您正在处理更复杂的事情，这是推荐的方法。</p><p id="539e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是由于<strong class="je hv"> Json </strong>相当简单，我们就手工做吧！👐</p><p id="18f7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们构造一个AST <code class="eh ka kb kc kd b">nodes</code>来表示我们的最终结果。</p><pre class="kg kh ki kj fq kk kd kl km aw kn dt"><span id="389e" class="ko kp hu kd b fv kq kr l ks kt">mkdir ast<br/>cd ast<br/>touch ast.go</span></pre><p id="b639" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ka kb kc kd b">nodes</code>相当简单。如果我们更关心错误处理和跟踪<code class="eh ka kb kc kd b">node</code>散列，就像我的用例，我们可以存储更多的数据。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="1c78" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注意:</strong>因为Go使用<code class="eh ka kb kc kd b">composition</code>而不是<code class="eh ka kb kc kd b">inheritance</code>，我们需要将<code class="eh ka kb kc kd b">TokenLiteral()</code>方法应用于每个<code class="eh ka kb kc kd b">node</code>类型，以便将每个类型解释为一个<code class="eh ka kb kc kd b">Json</code>节点。</p><p id="6054" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在来看解析器！</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="9d83" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们把这些都集中起来，写我们的驱动，<code class="eh ka kb kc kd b">main.go</code>。</p><p id="3a7f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注意:</strong> <code class="eh ka kb kc kd b">json.MarshalIndent()</code>是<code class="eh ka kb kc kd b">json.Marshal()</code>的一个很好的替代品，可以得到更漂亮的<strong class="je hv"> json </strong>输出。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="6300" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要运行:</p><pre class="kg kh ki kj fq kk kd kl km aw kn dt"><span id="8572" class="ko kp hu kd b fv kq kr l ks kt">go run main.go ./exampes/test.json</span></pre><p id="4d5f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">全部完成😄</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="mm lx l"/></div></figure><p id="18f8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们可以生成一个<strong class="je hv"> AST，</strong>很容易向每个节点添加一个滚动散列，并执行所有其他定制操作，例如:</p><ul class=""><li id="3da8" class="mn mo hu je b jf jg jj jk jn mp jr mq jv mr jz ms mt mu mv dt translated"><strong class="je hv">替换节点值</strong></li><li id="c27d" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><strong class="je hv">过滤掉节点</strong></li><li id="eae5" class="mn mo hu je b jf mw jj mx jn my jr mz jv na jz ms mt mu mv dt translated"><strong class="je hv">对节点应用特殊的比较函数</strong></li></ul><p id="ba3e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我将把这些扩展留给读者。欢迎在评论中留下你作品的链接。我很想看看你能想出什么。👍</p><p id="a18b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢您花时间阅读这篇文章。</p><p id="6211" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你觉得它有帮助或有趣，请让我知道👏👏👏。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="nb lx l"/></div></figure></div></div>    
</body>
</html>