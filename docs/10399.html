<html>
<head>
<title>Navigating Imperatively With Angular Dart In An E-commerce Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在电子商务Web应用程序中使用角标强制导航</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/navigating-imperatively-with-angular-dart-in-an-e-commerce-web-app-f9d7d0da096f?source=collection_archive---------14-----------------------#2018-12-28">https://medium.com/hackernoon/navigating-imperatively-with-angular-dart-in-an-e-commerce-web-app-f9d7d0da096f?source=collection_archive---------14-----------------------#2018-12-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/eda263f336b3718acb10853ce901b948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*TDHUKs_IzldQNNXTr86SLw.gif"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Our E-commerce Web App.</figcaption></figure><p id="346e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="ae ke" href="https://hackernoon.com/router-practical-approach-with-angular-dart-80485978a124" rel="noopener ugc nofollow" target="_blank">之前，</a>我们研究了使用路由器从一个视图导航到另一个视图，这需要锚链接，我们将<strong class="ji hv"> routerLink </strong>属性传递给shell，但是这种方法需要我们不断为每个视图创建组件，但是如果有更好的方法来编写代码并在视图之间导航，而不必为每个视图创建新的组件呢？</p><p id="50e8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">今天，我们将通过像web app这样的电子商务来研究这一点，同时在产品和结账之间进行交互。</p><p id="3e12" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们的应用程序中列出的产品很少，但这是否意味着我们必须为每个产品结账创建一个新视图？这可能真的很有压力，并且使我们很难管理我们的代码库，这就是为什么强制导航看起来很重要。</p><p id="e775" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">使用命令式导航，我们只需为产品结账页面创建一个视图，并将其绑定到产品结账按钮，告诉路由器导航到该页面，并提供产品数据，我们现在将一步一步地完成这项工作。</p><p id="c6b3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你不知道什么是路由器以及如何使用它，请参考我以前的教程<a class="ae ke" href="https://hackernoon.com/router-practical-approach-with-angular-dart-80485978a124" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="748b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在我们开始之前，请确保您知道如何执行以下操作:</p><p id="6512" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> -创建并定义路线路径</strong></p><p id="9d26" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> -创建一个向我们的应用程序异步提供数据的服务</strong></p><p id="6914" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">就这样了。在本教程结束时，你的应用程序应该像上面的图片一样运行，尽管缺乏高质量的用户界面，特别是在结账页面。</p><p id="6ffd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">好了，我已经准备好了我们需要的文件，包括UI、产品数据，我还创建了一个服务，所以只需从我的<a class="ae ke" href="https://github.com/corpsgeek/naviagting-imperatively-with-angular-dart" rel="noopener ugc nofollow" target="_blank">库</a>中克隆它，运行pub get和webdev serve。</p><p id="dadd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我想我们都已经准备好进行强制性导航了。</p><p id="373c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在进入命令式导航之前，让我们运行应用程序来了解一下变化和结构。现在，当用户点击继续结帐时，所点击产品的详细信息显示在产品列表部分，如下所示:</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div class="fe ff kf"><img src="../Images/bc611159367007e5c86d3a3d3c8fe677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Tuk2m1U9ORrG6yoIjwaW4Q.gif"/></div></figure><p id="42cd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们想要做的是，当用户单击“前进到结帐”按钮时，我们希望它导航到一个全新的视图，并显示所单击的特定产品的数据。</p><p id="6f1a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们要做的第一件事是为新视图创建一个组件，我们称之为checkout视图。因此，让我们在lib文件夹中创建一个<strong class="ji hv"> checkout.dart </strong>文件，并向其中添加以下代码:</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="c50d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">开始吧，我们已经有了选择器、模板、指令，还导出了路由路径和路由。如果你注意到我们没有导入RoutePaths和Routes包，因为我们已经在app组件中导入了，从而使它可用于所有其他组件。</p><p id="0a6e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，我们定义结账的路径，这将是棘手的部分。</p><p id="a7f5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">所以，我们现在想要的是，当用户点击产品时，我们的URL显示产品名称，就像这样:</p><p id="7171" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="ae ke" href="http://localhost:8080/#shopping/2%20by%208%20bedroom" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/# shopping/2% 20 by % 208% 20 bedroom</a></p><p id="fd04" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">该URL表明用户点击了“继续”来结帐名为“2乘8卧室”的产品，这只能通过使用路由参数来完成。路由参数的语法如下:</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="18ca" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">参数只返回一个字符串，但是我们也可以解析它来返回一个整数，基于路由参数的API文档，没有任何关于如何使用它的明确定义，所以我也要这么做。</p><p id="6595" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">首先，我们希望URL指示shopping/“product name ”,但是我们已经为购物创建了一个路由路径，所以我们将使用<strong class="ji hv"> shopping.path </strong>来引用购物路径。</p><p id="fda9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还想传入产品名，为此我们首先创建一个变量名<strong class="ji hv"> idParam </strong>，并赋予它一个值<em class="km">“产品”</em>。</p><blockquote class="kn ko kp"><p id="5b52" class="jg jh km ji b jj jk jl jm jn jo jp jq kq js jt ju kr jw jx jy ks ka kb kc kd hn dt translated">我们在购物页面中使用了价值产品来列出我们列表中的所有商品，为了安全起见，我建议您在程序中保持一个变量名。事情可能会变得更大，您无法跟踪所有这些变量名。</p></blockquote><p id="e039" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">好了，让我们继续创建一个常量变量名<strong class="ji hv"> idParam </strong>，其值乘积正好在<strong class="ji hv"> RoutePaths </strong>的类声明之上。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="7b21" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，我们通过将<strong class="ji hv"> idParam </strong>作为参数来定义checkout的路由路径</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="614d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">正如我前面提到的，我们希望URL地址指示<strong class="ji hv"> #shopping </strong>，正确的做法是引用购物路径，后跟一个正斜杠，并使用<strong class="ji hv"> idParam </strong>作为路由参数。</p><p id="9ba0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">似乎我们还没有完成，<strong class="ji hv"> idParam </strong>在route参数的路径中创建了一个槽，路由器会将所单击产品的产品名称插入到我们的槽中，如果我们告诉路由器导航到checkout组件，并显示产品名称为2x 2 bedroom、价格为300美元的产品的checkout详细信息以及描述，URL应该如下所示:</p><p id="ee36" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="ae ke" href="http://localhost:8080/#shopping/2%20by%208%20bedroom" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/# shopping/2% 20 by % 208% 20 bedroom</a></p><p id="89c6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果用户也在地址栏中直接输入上述URL，它会导航到该产品的结帐页面，就像我前面解释的那样。</p><p id="2338" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> RouterParameters </strong>属性具有字符串类型的URL参数的映射，使得如果匹配的<strong class="ji hv"> RouteDefinition </strong>路径具有路径“shopping/:productName”并且URL是“shopping/2by2bedroom”，则路由器参数将等于{productName: '2by2bedroom'}。</p><p id="f39f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来是获取被点击的产品的名称，并将其传递到路由参数中。在我们的<strong class="ji hv"> route_path.dart </strong>文件中，我们创建了一个方法<strong class="ji hv"> getName() </strong>，该方法返回一个字符串值并接收路由器参数的一个参数。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="a289" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> getProducts() </strong>方法返回给定[product]的值，如果[product]不在映射中，则返回null。有些映射允许键的值为null，所以我们还将它设置为如果乘积等于null则返回null，如果为false则返回产品名称，这是一个字符串参数。</p><blockquote class="kn ko kp"><p id="c750" class="jg jh km ji b jj jk jl jm jn jo jp jq kq js jt ju kr jw jx jy ks ka kb kc kd hn dt translated">如果您尝试返回一个整数，并且我们很清楚route parameters接收一个字符串，我们使用<strong class="ji hv">try parse(</strong><em class="hu">source</em><strong class="ji hv">)</strong>方法将该项解析为一个整数，如下面的代码所示:</p></blockquote><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="c5d8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，我们以与定义其他视图的路由路径相同的传统方式来定义结帐路由路径:</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="0073" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们已经准备好实现所有必须导航的结账路径。</p><p id="2a08" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们将dart文件切换到保存所有产品列表的组件，即<strong class="ji hv"> shopping.dart </strong>文件。我们不会添加任何<strong class="ji hv"> routerLink </strong>来继续检查锚链接标签，而是使用路由器强制导航。但是首先我们在我们的<strong class="ji hv">购物组件</strong>类中初始化路由器</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="67e7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在初始化路由器之后，我们创建一个私有方法，因为它将被初始化，它保存结帐视图URL，并且还将所需的参数传递给结帐路径:</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="d560" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> _checkoutUrl </strong>接受产品的字符串参数，因为我们的产品名称是一个字符串，就像我前面提到的那样— <em class="km">在强制导航时维护一个变量名。</em></p><p id="b0bc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> chechoutUrl </strong>使用arrow语法传递结账路径的Url和必要的参数。</p><p id="fe97" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因此，我们想告诉路由器在发生什么事情时自动导航，在这种情况下，当用户点击继续结帐按钮。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="fe71" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当调用<strong class="ji hv">router . navigate</strong>时，Future用于延迟计算，而<strong class="ji hv"> NavigationResult </strong>保存调用<strong class="ji hv"> router.navigate </strong>的结果，router.navigate 试图导航到定义的路径，在这种情况下是检验路径。</p><p id="2ae4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们在<strong class="ji hv"> _checkoutUrl() </strong>方法中定义了产品的字符串参数，即产品名称。</p><p id="94b9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">前面，我们初始化了<strong class="ji hv"> onSelect() </strong>方法，该方法响应一个点击事件，并返回被点击产品的数据，将其存储在类型类<strong class="ji hv"> Products </strong>的变量<strong class="ji hv"> selectedProduct </strong>中。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="e799" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">但是我们不想再在产品列表下显示所选产品，我们只想在另一个视图中显示所选产品，因此我们将products参数传递给<strong class="ji hv"> _checkoutProduct() </strong>，这使我们能够引用特定的产品名称。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="1537" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">就是这样；我们已经完成了与购物组件的交互，剩下的部分在结帐视图组件中，但是让我们转到购物组件HTML文件，并剪切掉所选的产品部分。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="1388" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们将把这个<strong class="ji hv"> selectedProduct </strong>部分粘贴到我们的checkout组件的模板属性中。</p><p id="267a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">很快，让我们将<strong class="ji hv"> ShoppingComponent </strong>添加到我们的指令中，并导入<strong class="ji hv"> ShoppingComponent </strong> dart文件。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="b9ec" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在我们的<strong class="ji hv"> CheckoutComponent </strong>类中，我们初始化了<strong class="ji hv">产品服务</strong>和<strong class="ji hv">位置</strong>，它们与浏览器URL交互，还将用于导航回购物页面；我们还声明了类型类<strong class="ji hv"> Products </strong>的变量名<strong class="ji hv"> selectedProduct </strong>，它与模板中的<strong class="ji hv"> *ngIf </strong>属性中的变量相同。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="cc41" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们在<strong class="ji hv"> CheckoutComponent </strong>类上实现<strong class="ji hv"> onActivate </strong>生命周期挂钩。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><blockquote class="kn ko kp"><p id="ab4d" class="jg jh km ji b jj jk jl jm jn jo jp jq kq js jt ju kr jw jx jy ks ka kb kc kd hn dt translated"><strong class="ji hv"> onActivate </strong>是一个生命周期接口，它在组件被路由激活时发出通知。如果组件类将作为路由定义的一部分被导航到，并且希望在由于路由而被激活时得到通知，那么它们应该实现这一点。</p></blockquote><p id="4539" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在实现了<strong class="ji hv"> onActivate </strong>之后，我们创建了一个覆盖注释来覆盖<strong class="ji hv"> onActivate </strong>方法</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="1b9e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们用下划线(<strong class="ji hv"> _ </strong>)替换<strong class="ji hv"> RouterState </strong> previous，该下划线在路由器出口插入组件后被调用，并将在初始变化检测后出现。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="0816" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，我们将这段代码添加到<strong class="ji hv"> onActivate </strong>方法中:</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="1733" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">get product(current . parameters)</strong>从route path返回产品的当前值，如果产品不等于null，我们将产品赋给变量名<strong class="ji hv"> selectedProduct </strong>。</p><p id="409a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还没有初始化<strong class="ji hv"> get() </strong>方法，该方法只能在产品服务类中完成。</p><p id="f5b4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> await </strong>表示异步操作，因此我们将<strong class="ji hv"> async </strong>添加到<strong class="ji hv"> onActivate() </strong>方法中，该方法异步获取产品数据。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="b95e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，我们转向产品服务类并添加一个<strong class="ji hv"> get </strong>方法，该方法从产品列表中异步获取数据，同时迭代列表以获取列表中第一次出现的所选产品名称。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="282a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">是的，这就解决了问题，我们的应用程序运行良好，那么为什么不在您的…..</p><p id="8239" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">还有一件事，让我们看看<strong class="ji hv">位置</strong>是如何有用的。</p><p id="7528" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在我们的结帐页面中，我将添加一个“<strong class="ji hv">返回购物</strong>”按钮，使用location.back将用户导航回上一页</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="a63c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">将这段HTML代码添加到结帐页面的模板中，并将这段代码添加到实现<strong class="ji hv"> goBack() </strong> click事件的<strong class="ji hv"> CheckoutComponent </strong>类中</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div></figure><p id="919b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">位置类可以在平台(浏览器)历史中向后和向前导航。</p><p id="c776" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">是的，回到我刚才说的。</p><p id="603a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这就解决了问题，我们的应用程序运行良好，那么为什么不在你的下一个电子商务应用程序或任何你选择的应用程序(如博客)中使用强制导航呢？</p></div></div>    
</body>
</html>