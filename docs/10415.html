<html>
<head>
<title>RESTful API-design based on Vert.x, Keycloak and Kotlin/Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RESTful API——基于Vert.x、Keycloak和kot Lin/协程的设计</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-we-built-an-asynchronous-temporal-restful-api-based-on-vert-x-4570f681a3?source=collection_archive---------2-----------------------#2018-12-29">https://medium.com/hackernoon/how-we-built-an-asynchronous-temporal-restful-api-based-on-vert-x-4570f681a3?source=collection_archive---------2-----------------------#2018-12-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="d9b1" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">我们如何为Sirix.io(开源)构建一个异步的时态RESTful API</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff jj"><img src="../Images/06b14ae6648274c74648b03a83b81318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*MBuIiFdKuz7tr1mbZPfqjA.png"/></div><figcaption class="jr js fg fe ff jt ju bd b be z ek">Interactive Visualization — Uses Hierarchical Edge Bundles to visualize moved nodes.</figcaption></figure><h1 id="6c37" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">为什么现在存储历史数据变得可行</h1><p id="f156" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">生命受制于不断的进化。我们的数据也是如此，无论是研究、商业还是个人信息管理。因此，令人惊讶的是，数据库通常只保持当前状态。然而，随着闪存驱动器(例如固态硬盘)的出现，与旋转磁盘形成鲜明对比的是，固态硬盘在随机访问数据方面要快得多，并且不太擅长擦除或覆盖数据，我们现在能够开发智能的版本控制算法和存储系统来保持过去的状态，同时不影响效率/性能。因此，搜索/插入/删除操作应该是对数时间的(O(log(n))，以便与常用的索引结构竞争。</p><h1 id="fa26" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">临时存储系统SirixDB</h1><blockquote class="lj"><p id="e895" class="lk ll hu bd lm ln lo lp lq lr ls li ek translated">Sirix是一个版本化的临时存储系统，其核心是日志结构。</p></blockquote><p id="dc76" class="pw-post-body-paragraph kn ko hu kp b kq lt iv ks kt lu iy kv kw lv ky kz la lw lc ld le lx lg lh li hn dt translated">我们支持<strong class="kp hv"> N个只读</strong>事务，这些事务被绑定到一个<strong class="kp hv">单一版本</strong>(每个事务可以从任何过去的版本开始)<em class="ly">并发</em>到<strong class="kp hv">一个单一资源上的写</strong>事务。因此，我们的系统基于<strong class="kp hv">快照隔离</strong>。写事务可以将最近的修订恢复到任何过去的修订。然后，可以提交对此过去修订的更改，以创建新的快照，从而创建新的修订。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="fe ff lz"><img src="../Images/dd56b664d92a88376810af1df87e1b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*j8pCR0heKRznTIuwCA1chA.png"/></div></div></figure><blockquote class="lj"><p id="7f07" class="lk ll hu bd lm ln me mf mg mh mi li ek translated">在事务提交期间，以内部索引树结构的后序遍历方式将写操作批处理并同步到磁盘。因此，我们能够在父指针中存储页面的哈希，就像<strong class="ak"> ZFS一样，用于将来的完整性检查</strong>。</p></blockquote><p id="3c04" class="pw-post-body-paragraph kn ko hu kp b kq lt iv ks kt lu iy kv kw lv ky kz la lw lc ld le lx lg lh li hn dt translated">快照，即在每次提交期间创建的新修订。除了数字的<em class="ly">修订号</em>之外，<em class="ly">时间戳</em>被序列化。随后可以通过指定ID或时间戳来打开修订。使用时间戳需要对时间戳数组进行二进制搜索，这些时间戳持久存储在第二个文件中，并在启动时加载到内存中。如果找到准确的时间戳或与给定时间点最接近的修订，则搜索结束。数据永远不会写回同一个位置，因此不会就地修改。<strong class="kp hv">取而代之的是，Sirix在记录层使用写时复制(COW)语义(创建页面片段，通常不复制整页)。每当一个页面必须被修改时，已经改变的记录以及一些未改变的记录被写入一个新的位置。具体复制哪些记录取决于使用的版本控制算法</strong>。因此，它特别适合固态硬盘等基于闪存的驱动器。对数据库中资源的更改发生在上述资源绑定的单次写事务中。因此，首先必须在特定资源上打开ResourceManager，以启动单个资源范围的事务。请注意，我们已经开始处理数据库范围的事务:-)</p><p id="549d" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">我们最近写了另一篇<a class="ae mo" href="https://link.medium.com/DI6qr33v7S" rel="noopener">文章</a>，提供了更多关于Sirix背后原理的背景信息。</p><h1 id="2185" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">简单的基于事务游标的API</h1><p id="02f8" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">下面显示了一个简单的Java代码，用于创建数据库、数据库中的资源以及XML文档的导入。它将被分解成我们的内部表示(这可以被认为是一个持久的DOM实现，因此涉及到内存布局和二进制序列化格式)。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="f83a" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">JSON的原生存储将是下一个。一般来说，每种类型的数据都可以存储在Sirix中，只要它可以由生成的顺序、稳定的记录标识符获取，该标识符由Sirix在插入期间分配，并且插入了定制的串行化器/解串行化器。然而，我们正在开发几个小的层来本地存储JSON数据。</p><h1 id="5744" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">Vert.x、Kotlin/Coroutines和Keycloak</h1><p id="e36d" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">另一方面，Vert.x 是在Node.js的基础上为JVM设计的。Vert.x中的一切都应该是非阻塞的。因此，一个称为事件循环的线程可以处理大量的请求。阻塞调用必须在一个特殊的线程池上处理。默认情况下，每个CPU有两个事件循环(多反应器模式)。</p><p id="9ca8" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">我们使用<strong class="kp hv">科特林</strong>，因为它简单明了。其中一个非常有趣的特性是协程。从概念上讲，它们就像非常轻量级的线程。虽然创建线程非常昂贵，但创建协程并不昂贵。协同程序允许像顺序代码一样编写异步代码。每当由于阻塞调用或长时间运行的任务而被挂起时，底层线程不会被阻塞，并且可以被重用。在幕后，每个挂起的函数通过Kotlin编译器获得另一个参数，一个continuation，它存储在哪里恢复函数(正常恢复，异常恢复)。</p><p id="0e2c" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated"><strong class="kp hv"> Keycloak </strong>通过OAuth2(密码凭证流)用作授权服务器，因为我们决定不自己实现授权。</p><h1 id="9085" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">构建服务器时需要考虑的事项</h1><p id="2f13" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">首先，我们必须决定哪一个流程最适合我们的需求。因为我们构建了一个通常不被用户代理/浏览器使用的REST-API，所以我们决定使用<strong class="kp hv">密码凭证流。</strong>很简单:首先获取一个访问令牌，然后在授权头中随每个请求一起发送。</p><p id="78e6" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">为了获得访问令牌，首先必须对一个<strong class="kp hv"> POST /login — </strong> route发出一个请求，在请求体中以JSON-object的形式发送用户名/密码凭证。</p><p id="ea2b" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">实现如下所示:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="693e" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">协程处理程序是一个简单的扩展函数:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="e9d6" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">协程在Vert.x事件循环(调度程序)上启动。</p><p id="8d68" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">为了执行一个运行时间更长的处理程序，我们使用</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="3101" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">对于这些任务，Vert.x使用不同的线程池。因此，任务在另一个线程中执行。注意，事件循环不会被阻塞，协程会被挂起。</p><h1 id="77ce" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">通过示例进行API设计</h1><p id="ea9b" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated"><em class="ly">现在我们再次将焦点转移到我们的API，并通过示例展示它是如何设计的</em>。我们首先需要设置我们的服务器和Keycloak(阅读<a class="ae mo" href="http://sirix.io" rel="noopener ugc nofollow" target="_blank"> http://sirix.io </a>如何做这件事)。</p><p id="4f64" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">一旦两台服务器都启动并运行，我们就能够编写一个简单的HTTP-Client。我们首先必须用给定的“用户名/密码”JSON-Object从<code class="eh mr ms mt mu b">/login</code>端点获得一个令牌。在Kotlin中使用异步HTTP-Client(来自Vert.x ),看起来像这样:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="b273" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">然后，这个访问令牌必须在每个后续请求的授权HTTP头中发送。存储第一个资源如下所示(简单的HTTP PUT-Request):</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="90dc" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">首先，创建一个名为<code class="eh mr ms mt mu b">database</code>的包含一些元数据的空数据库，然后用名称<code class="eh mr ms mt mu b">resource1</code>存储XML片段。PUT HTTP-Request是等幂的。具有相同URL端点的另一个PUT请求将删除以前的数据库和资源，并重新创建数据库/资源。</p><p id="808c" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">HTTP响应代码应该是200(一切正常)，在这种情况下，HTTP-body产生:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="8b64" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">我们正在序列化从存储系统中为元素节点生成的id。</p><p id="7858" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">通过一个<code class="eh mr ms mt mu b">GET HTTP-Request</code>到<code class="eh mr ms mt mu b">https://localhost:9443/database/resource1</code>，我们也能够再次检索存储的资源。</p><p id="c5d1" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">然而，到目前为止，这并不真正有趣。我们可以通过<code class="eh mr ms mt mu b">POST-Request</code>更新资源。假设我们像以前一样检索了访问令牌，我们可以简单地做一个后请求，并使用我们以前收集的关于节点id的信息:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="f43d" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">有趣的部分是我们用作端点的URL。我们简单地说，选择ID为3的节点，然后插入给定的XML片段作为第一个子节点。这会产生以下序列化的XML文档:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="49c3" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">每个PUT-以及POST-请求都隐式地<code class="eh mr ms mt mu b">commits</code>底层事务。因此，我们现在能够发送第一个GET-request来再次检索整个资源的内容，例如通过指定一个简单的XPath-query来选择所有修订<code class="eh mr ms mt mu b">GET https://localhost:9443/database/resource1?query=/xml/all-time::*</code>中的根节点，并获得下面的XPath-result:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="0057" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">注意，我们在query-parameter中使用了一个时间旅行轴。一般来说，我们支持几个额外的时间XPath轴:未来、未来或自我、过去、过去或自我、前一个、前一个或自我、下一个、下一个或自我、第一个、最后一个、所有时间</p><p id="1891" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">时间轴兼容节点测试:<br/> <br/> &lt;时间轴&gt; :: &lt;节点测试&gt; <br/> <br/>定义为<br/> <br/> &lt;时间轴&gt;:*/self::&lt;节点测试&gt;。</p><p id="9a97" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">当然，通常的方法是，首先使用一个标准的XPath轴导航到您感兴趣的节点，例如后代和/或子轴，添加谓词，然后及时导航，观察节点和子树是如何变化的。这是一个令人难以置信的强大特性，可能是未来文章的主题。</p><p id="974c" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">通过在GET-request中指定要序列化的修订范围(开始和结束修订参数),也可以达到同样的目的:</p><p id="df43" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated"><code class="eh mr ms mt mu b">GET <a class="ae mo" href="https://localhost:9443/database/resource1?start-revision=1&amp;end-revision=2" rel="noopener ugc nofollow" target="_blank">https://localhost:9443/database/resource1?start-revision=1&amp;end-revision=2</a></code></p><p id="e16f" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">或者通过时间戳:</p><p id="5c20" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated"><code class="eh mr ms mt mu b">GET <a class="ae mo" href="https://localhost:9443/database/resource1?start-revision-timestamp=2018-12-20T18:00:00&amp;end-revision-timestamp=2018-12-20T19:00:00" rel="noopener ugc nofollow" target="_blank">https://localhost:9443/database/resource1?start-revision-timestamp=2018-12-20T18:00:00&amp;end-revision-timestamp=2018-12-20T19:00:00</a></code></p><p id="343e" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">但是，如果我们首先打开一个资源，然后通过一个查询选择单个节点，那么使用时间轴会更快，否则必须对每个打开的修订执行相同的查询(解析、编译、执行……)。</p><p id="1a1e" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">我们当然也能够通过更新XQuery表达式(这不是很RESTful)或简单的<code class="eh mr ms mt mu b">DELETE</code> HTTP-request来删除资源或其中的任何子树:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="7419" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">这将删除ID为3的节点，在我们的例子中，因为它是一个元素节点，所以删除了整个子树。当然，它是作为修订版3提交的，因此所有旧的修订版仍然可以查询整个子树，就像在事务提交期间一样(在第一个修订版中，它只是名为“bar”的元素，没有任何子树)。</p><p id="2233" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">如果我们想要获得一个diff，目前是以XQuery Update语句的形式，只需调用XQuery函数<code class="eh mr ms mt mu b">sdb:diff</code>，它被定义为:</p><p id="b743" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated"><code class="eh mr ms mt mu b">sdb:diff($coll as xs:string, $res as xs:string, $rev1 as xs:int, $rev2 as xs:int) as xs:string</code></p><p id="a7c0" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">我们当然可以指定其他序列化格式。</p><p id="5f26" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">例如，我们可以在上面创建的数据库/resource1上发送这样的GET-request:</p><p id="e407" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated"><code class="eh mr ms mt mu b">GET <a class="ae mo" href="https://localhost:9443/?query=sdb:diff('database','resource1',1,2)" rel="noopener ugc nofollow" target="_blank">https://localhost:9443/?query=</a>sdb%3Adiff%28%27database%27%2C%27resource1%27%2C1%2C2%29</code></p><p id="5f54" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">请注意，查询字符串必须是URL编码的，因此解码它的</p><p id="25d4" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated"><code class="eh mr ms mt mu b"><a class="ae mo" href="https://localhost:9443/?query=sdb:diff('database','resource1',1,2)" rel="noopener ugc nofollow" target="_blank">sdb:diff('database','resource1',1,2)</a></code></p><p id="c922" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">并且我们正在比较修订版1和2(但是对于我们比较的每个修订版元组，不同的性能肯定在相同的时间复杂度上)。在我们的示例中，diff的输出是这个XQuery-Update语句，该语句包装在一个封闭的sequence-element中:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="88f8" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">这意味着<code class="eh mr ms mt mu b">database</code>中的<code class="eh mr ms mt mu b">resource1</code>在第一次修改时打开。然后将子树<code class="eh mr ms mt mu b">&lt;xml&gt;foo&lt;bar/&gt;&lt;/xml&gt;</code>附加到具有稳定node-ID 3的节点，作为第一个子节点。</p></div><div class="ab cl mv mw hc mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="hn ho hp hq hr"><p id="1eaa" class="pw-post-body-paragraph kn ko hu kp b kq mj iv ks kt mk iy kv kw ml ky kz la mm lc ld le mn lg lh li hn dt translated">如果你喜欢这个，请给我们一些掌声，让更多的人看到它或Github上的一颗星…最重要的是检查一下(<strong class="kp hv">我们很乐意听到任何建议，反馈，对未来工作的建议，例如关于JSON或云的水平扩展的工作，错误报告；-)，只是一切…请联系</strong> ) :-)</p><h1 id="af73" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">我们的开源库:<a class="ae mo" href="http://sirix.io" rel="noopener ugc nofollow" target="_blank"> http://sirix.io </a></h1></div></div>    
</body>
</html>