<html>
<head>
<title>Reversing an n-bit number in O(log n)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反转O(log n)中的n位数</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/reversing-an-n-bit-number-in-o-log-n-time-9bf69363d452?source=collection_archive---------3-----------------------#2018-12-29">https://medium.com/hackernoon/reversing-an-n-bit-number-in-o-log-n-time-9bf69363d452?source=collection_archive---------3-----------------------#2018-12-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="2216" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上周，在写我的<a class="ae jp" rel="noopener" href="/p/537cc8bb9f52">上一篇文章</a>时，我遇到了一个有趣的整数反转算法。比如它取<code class="eh jq jr js jt b">10100011</code>，转换成<code class="eh jq jr js jt b">11000101</code>。这个算法的酷之处在于它只需要O(log n)次迭代。这是代码:</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="jz ka l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Reverse an n-bit number in O(log n). From <a class="ae jp" href="http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel" rel="noopener ugc nofollow" target="_blank">http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel</a></figcaption></figure><p id="5e8f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是的。9行，包括签名和右括号。<strong class="it hv">我们来看看效果如何。</strong></p><p id="311d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下一部分逐行研究代码。如果你对技术细节感到厌烦，可以直接跳到最后的<a class="ae jp" rel="noopener" href="/@ehudt/reversing-an-n-bit-number-in-o-log-n-9bf69363d452#2326"> <strong class="it hv">动画</strong> </a>。</p><p id="912e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">更新:</strong>O(logn)运行时间复杂度只适用于n ≤机器字长，现在一般是64位。感谢所有让我注意到这一点的人。</p><h1 id="edb8" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">技术:递归块交换</h1><p id="c99d" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">该算法通过递归交换相邻的比特块来工作，在每次迭代中减小块的大小。它首先交换2个n/2位的块，然后是4个n/4位的块，8个n/8位的块，依此类推，最后是n个1位的块。在每次迭代中，所有成对的相邻块被并行交换<strong class="it hv"/>。结果是颠倒的数字。为了并行交换块，该算法使用<a class="ae jp" href="https://en.wikipedia.org/wiki/Bitwise_operation" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">逐位</strong> <strong class="it hv">操作</strong> </a>和<strong class="it hv">位屏蔽</strong>。</p><p id="1bac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">注</strong>:原码使用32位输入。我们将使用<strong class="it hv"> 8位整数</strong>来使事情更容易理解。</p><h2 id="0022" class="li kg hu bd kh lj lk ll kl lm ln lo kp jc lp lq kt jg lr ls kx jk lt lu lb lv dt translated">交换相邻的比特块</h2><p id="1aae" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">并行交换块是通过特制的位掩码完成的。</p><p id="0031" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于<strong class="it hv">块大小</strong> <code class="eh jq jr js jt b">s</code>，位屏蔽<code class="eh jq jr js jt b">mask</code>由交替的<code class="eh jq jr js jt b">s</code>0和<code class="eh jq jr js jt b">s</code>1块组成。比如对于<code class="eh jq jr js jt b">s = 4</code>、<code class="eh jq jr js jt b">mask == 00001111</code>。对于<code class="eh jq jr js jt b">s = 2</code>，<code class="eh jq jr js jt b">mask == 00110011</code>。</p><p id="3bab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该行使用掩码并行交换所有块对<strong class="it hv"/>:</p><pre class="ju jv jw jx fq lw jt lx ly aw lz dt"><span id="273f" class="li kg hu jt b fv ma mb l mc md">num = ((num &gt;&gt; s) &amp; mask) | ((num &lt;&lt; s) &amp; ~mask);</span></pre><ul class=""><li id="e7d2" class="me mf hu it b iu iv iy iz jc mg jg mh jk mi jo mj mk ml mm dt translated"><code class="eh jq jr js jt b">(num &gt;&gt; s) &amp; mask)</code>向右移动<em class="mn">偶数块</em> <code class="eh jq jr js jt b">s</code>位置，并使用掩膜清除<em class="mn">奇数块</em>。</li><li id="5e43" class="me mf hu it b iu mo iy mp jc mq jg mr jk ms jo mj mk ml mm dt translated"><code class="eh jq jr js jt b">(num &lt;&lt; s) &amp; ~mask</code>向左移动<em class="mn">奇数块</em> <code class="eh jq jr js jt b">s</code>位置，并使用掩码的逐位非清除<em class="mn">偶数块</em>。</li><li id="d1ca" class="me mf hu it b iu mo iy mp jc mq jg mr jk ms jo mj mk ml mm dt translated">按位“或”用于将这些结果加到交换数中。</li></ul><p id="afb7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">非常简单，不是吗？</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="fe ff mt"><img src="../Images/ad2af6285467eba645b55b25f3a5ef10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NUyM1-jlPvQC8ixKdJBo-g.jpeg"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">A flower XORed against itself. Original By Sam Oth (User:World Trekker) — Own work, CC BY-SA 2.5, <a class="ae jp" href="https://commons.wikimedia.org/w/index.php?curid=863943" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/w/index.php?curid=863943</a></figcaption></figure><h2 id="8feb" class="li kg hu bd kh lj lk ll kl lm ln lo kp jc lp lq kt jg lr ls kx jk lt lu lb lv dt translated">创建遮罩</h2><p id="834c" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">另一个很酷的技巧在于<code class="eh jq jr js jt b">mask</code>是如何创造的。<code class="eh jq jr js jt b">mask</code>由大小为<code class="eh jq jr js jt b">s</code>的0和1的交替块组成。掩码以全1数字开始，并在循环的第一行更新:</p><pre class="ju jv jw jx fq lw jt lx ly aw lz dt"><span id="f5d3" class="li kg hu jt b fv ma mb l mc md">while ((s &gt;&gt;= 1) &gt; 0) {<br/>  mask ^= (mask &lt;&lt; s);<br/>  ...</span></pre><p id="05b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这发生在<code class="eh jq jr js jt b">s</code>减半之后，因此<code class="eh jq jr js jt b">s</code>是<code class="eh jq jr js jt b">mask</code>块大小的一半。在第一次迭代中，<code class="eh jq jr js jt b">mask == 11111111</code>和<code class="eh jq jr js jt b">s == 4</code>。掩码通过将其自身与左移<code class="eh jq jr js jt b">s</code>位的其自身的另一个副本进行异或运算来更新:</p><pre class="ju jv jw jx fq lw jt lx ly aw lz dt"><span id="1085" class="li kg hu jt b fv ma mb l mc md">mask = <br/>    11111111 XOR  // mask<br/>    11110000      // mask &lt;&lt; s<br/>  = 00001111</span></pre><p id="a52d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当且仅当两位彼此不相等时，两位的异或为1。在掩码更新的每次迭代中，所有块都向左移动一半大小。当一个块与前一个掩码进行异或运算时，该块的一半与0重叠，另一半与1重叠。这在新的遮罩中创建了2个块，每个块的大小是前一个块的一半。下面是一个例子:</p><pre class="ju jv jw jx fq lw jt lx ly aw lz dt"><span id="3265" class="li kg hu jt b fv ma mb l mc md">0000000011111111  // original mask, 8-bit blocks<br/>0000111111110000  // mask shifted left by block-size/2<br/>0000111100001111  // XORed: new mask, 4-bit blocks</span></pre><h1 id="2326" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">把这一切联系在一起</h1><p id="5884" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">下面是一个简短的动画，展示了该算法的实际应用:</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="na ka l"/></div></figure></div><div class="ab cl nb nc hc nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="hn ho hp hq hr"><p id="92c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">令人惊讶的是，在9行代码中可以找到多少深度。如果你想让我研究一段有趣的代码，请在下面<strong class="it hv">留下回复</strong>！</p></div></div>    
</body>
</html>