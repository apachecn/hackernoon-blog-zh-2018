<html>
<head>
<title>Asynchronous, Temporal REST With Vert.x, Keycloak and Kotlin Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vert.x、Keycloak和Kotlin协同程序的异步临时REST</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/asynchronous-temporal-rest-with-vert-x-keycloak-and-kotlin-coroutines-217b25756314?source=collection_archive---------9-----------------------#2018-12-29">https://medium.com/hackernoon/asynchronous-temporal-rest-with-vert-x-keycloak-and-kotlin-coroutines-217b25756314?source=collection_archive---------9-----------------------#2018-12-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="fb3c" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">我们如何为一个日志结构的、时态的、版本化的NoSQL文档库——sirix . io(开源且免费)构建一个异步的、RESTful API</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="ab fr cl jo"><img src="../Images/bd5b46a4dd62bc492f01631914c214f2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*MBuIiFdKuz7tr1mbZPfqjA.png"/></div><figcaption class="jr js fg fe ff jt ju bd b be z ek">Interactive Visualization — Uses Hierarchical Edge Bundles to visualize moved nodes.</figcaption></figure><h1 id="5d10" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">为什么现在保留旧版本/修订版的数据变得可行</h1><p id="91d9" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">生命受制于不断的进化。我们的数据也是如此，无论是研究、商业还是个人信息管理。因此，令人惊讶的是，数据库通常只保持当前状态。然而，随着闪存驱动器(例如固态硬盘)的出现，与旋转磁盘形成鲜明对比的是，固态硬盘在随机访问数据方面要快得多，并且不太擅长擦除或覆盖数据，我们现在能够开发智能的版本控制算法和存储系统来保持过去的状态，同时不影响效率/性能。因此，搜索/插入/删除操作应该是对数时间的(<em class="lj"> O(log(n)) </em>)，以便与常用的索引结构竞争。</p><h1 id="bb50" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">进化的、时间的NoSQL商店Sirix.io</h1><blockquote class="lk"><p id="900b" class="ll lm hu bd ln lo lp lq lr ls lt li ek translated"><strong class="ak"> <em class="lu"> Sirix </em> </strong> <em class="lu">是一个版本化的时态存储系统，其核心是日志结构。</em></p></blockquote><p id="ed75" class="pw-post-body-paragraph kn ko hu kp b kq lv iv ks kt lw iy kv kw lx ky kz la ly lc ld le lz lg lh li hn dt translated">我们支持<strong class="kp hv"> N个只读</strong>事务，这些事务被绑定到一个<strong class="kp hv">单一修订</strong>(每个事务可以在任何过去的修订上开始)<em class="lj">并发</em>到<strong class="kp hv">一个写</strong>事务。因此，我们的系统基于<strong class="kp hv">快照隔离</strong>。写事务可以将最近的修订恢复到任何过去的修订。然后，可以提交对此过去修订的更改，以创建新的快照，从而创建新的修订。</p><blockquote class="lk"><p id="fadf" class="ll lm hu bd ln lo lp lq lr ls lt li ek translated"><em class="lu">在事务提交期间，在内部索引树结构的后序遍历中，写入被批处理并同步到磁盘。因此，我们将随机写入I/O转换为顺序写入。此外，我们能够在父指针中存储页面的哈希，就像</em><strong class="ak"><em class="lu">【ZFS】用于将来的完整性检查(Merkle-Tree) </em> </strong> <em class="lu">。优步页是资源的根页，最后写入。因此，我们的存储总是一致的，不需要预写日志(WAL)。我们没有持久日志和数据存储，而是只有日志结构的索引(和一个轻量级缓冲区管理器)。</em></p></blockquote><figure class="ma mb mc md me jn fe ff paragraph-image"><div class="ab fr cl jo"><img src="../Images/f8670591abfdd1cc41b1cad6cbe5cac8.png" data-original-src="https://miro.medium.com/v2/format:webp/1*j8pCR0heKRznTIuwCA1chA.png"/></div><figcaption class="jr js fg fe ff jt ju bd b be z ek">Sunburst View of a file system import</figcaption></figure><p id="9870" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">快照，即在每次提交期间创建的新修订。除了数字的<em class="lj">修订号</em>之外，<em class="lj">时间戳</em>被序列化。随后可以通过指定ID或时间戳来打开修订。使用时间戳需要对时间戳数组进行二进制搜索，时间戳数组持久存储在第二个文件中，并在启动时加载到内存中。如果找到准确的时间戳或与给定时间点最接近的修订，则搜索结束。数据永远不会写回同一个位置，因此不会就地修改。<strong class="kp hv">取而代之的是，Sirix在记录层使用写时复制(COW)语义(创建页面片段，通常不复制整页)。每当一个页面必须被修改时，那些已经改变的记录以及一些未改变的记录都被写入一个新的位置。具体复制哪些记录取决于使用的版本控制算法</strong>。因此，它特别适合固态硬盘等基于闪存的驱动器。对数据库中资源的更改发生在上述资源绑定的单次写事务中。因此，首先必须在特定资源上打开资源管理器，以启动单个资源范围的事务(类似于资源范围的会话)。请注意，我们已经开始处理数据库范围的事务:-)</p><p id="f501" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">我们最近写了另一篇<a class="ae mk" href="https://hackernoon.com/sirix-io-why-copy-on-write-semantics-and-node-level-versioning-are-key-to-efficient-snapshots-754ba834d3bb" rel="noopener ugc nofollow" target="_blank">文章</a>，提供了更多关于Sirix背后原理的背景信息。</p><h1 id="0cc1" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">简单的、基于事务游标的API</h1><p id="570e" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">下面显示了一个简单的Java代码，用于创建数据库、数据库中的资源以及JSON文档的导入。它将被分解成我们内部的二进制表示。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ml mm l"/></div></figure><h1 id="d158" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">用于JSON和XML的强大XQuery API</h1><p id="baac" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">基于XQuery处理器(<strong class="kp hv"> Brackit </strong>)的强大查询API可用于处理本地存储的XML和JSON，并可用于<strong class="kp hv"> HTTP POST- </strong>和<strong class="kp hv"> GET-requests </strong>(后者用于简单查询):</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="23cc" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">该查询基本上基于时间戳(<em class="lj">2019–04–13t 16:24:27Z</em>)打开特定修订版中的数据库/资源，并搜索所有具有<strong class="kp hv"> created_at </strong>时间戳的状态，该时间戳必须大于2018年2月1日，并且在先前的修订版中不存在。<strong class="kp hv"> = &gt; </strong>是一个解引用操作符，用于解引用JSON对象中的键，数组值可以通过函数<strong class="kp hv"> bit:array-values </strong>或者通过指定一个索引来访问，从零开始:<strong class="kp hv"> array[[0]] </strong>例如指定数组的第一个值。XQuery最初是为查询XML数据而设计的，类似于查询关系数据的SQL(但是功能更强大)，但它也是查询其他树结构数据的完美候选，例如稍加调整的JSON。</p><p id="5b69" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">我们还支持具有几乎相同的API的本地XML存储。一般来说，每种类型的数据都可以存储在Sirix中，只要它可以由生成的顺序的、稳定的记录标识符获取，该标识符由Sirix在插入期间分配，并且只要插入了定制的串行器/解串器。</p><h1 id="ae4c" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">Vert.x、Kotlin/Coroutines和Keycloak</h1><p id="bd63" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated"><strong class="kp hv"> Vert.x </strong>是在<strong class="kp hv"> Node.js </strong>的基础上，为<strong class="kp hv"> JVM </strong>设计的。Vert.x中的一切都应该是非阻塞的。因此，一个称为事件循环的线程可以处理大量的请求。阻塞调用必须在一个特殊的线程池上处理。默认情况下，每个CPU有两个事件循环(多反应器模式)。</p><p id="1ac0" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">我们使用<strong class="kp hv"> Kotlin </strong>，因为它简单明了。其中一个非常有趣的特性是协程。从概念上讲，它们就像非常轻量级的线程。虽然创建线程非常昂贵，但创建协程并不昂贵。协同程序允许像顺序代码一样编写并发代码。每当协程由于阻塞调用或长时间运行的任务而被挂起时，底层线程不会被阻塞，并且可以被重用。在幕后，每个挂起的函数通过Kotlin编译器获得另一个参数，一个continuation，它存储在哪里恢复函数(正常恢复，异常恢复)。</p><p id="cba3" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">Keycloak 通过OAuth2(密码凭证流)用作授权服务器，因为我们决定不自己实现授权。</p><h1 id="9ce2" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">构建服务器时需要考虑的事项</h1><p id="8197" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">首先，我们必须决定哪一个流程最适合我们的需求。因为我们构建了一个通常不被用户代理/浏览器使用的REST-API，所以我们决定使用<strong class="kp hv">密码凭证流。事情就这么简单:首先获取一个访问令牌，然后在授权头中随每个请求一起发送。</strong></p><p id="02cf" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">为了获得访问令牌，首先必须对一个<strong class="kp hv"> POST /login — </strong> route发出一个请求，在请求体中以JSON-object的形式发送用户名/密码凭证。</p><p id="1cf2" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">实现如下所示:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="aa2d" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">协程处理程序是一个简单的扩展函数:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="7a41" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">协程在Vert.x事件循环(调度程序)上启动。</p><p id="9d73" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">为了执行一个运行时间更长的处理程序，我们使用</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="d30b" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">对于这些任务，Vert.x使用不同的线程池。因此，任务在另一个线程中执行。注意，事件循环不会被阻塞，协程会被挂起。</p><p id="c922" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">API的每个端点都受到授权处理程序的保护，该处理程序与Keycloak实例通信并检查授权:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="43d5" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">因此，我们的路线看起来像这样:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="ad72" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">基本上，这是HTTP GET-Requests的一个端点，它产生“application/json”内容并检索数据库中的资源。可选地，可以使用一个<strong class="kp hv">查询</strong>参数来深入存储的JSON或XML资源的内部树形结构。端点受到上述身份验证处理程序的保护，因此只有授权用户才能查看资源。</p><h1 id="c39b" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">通过示例进行API设计</h1><p id="c8f9" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated"><em class="lj">现在我们再次将焦点转移到我们的API上，并通过例子展示它是如何设计的</em>。我们首先需要设置我们的服务器和Keycloak(阅读<a class="ae mk" href="http://sirix.io" rel="noopener ugc nofollow" target="_blank"> https://sirix.io </a>如何做这件事)。</p><p id="585b" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">一旦两台服务器都启动并运行，我们就能够编写一个简单的HTTP-Client。我们首先必须用给定的“用户名/密码”JSON-Object从<code class="eh mn mo mp mq b">/login</code>端点获得一个令牌。在Kotlin中使用异步HTTP-Client(来自Vert.x ),看起来像这样:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="3f3a" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">然后，这个访问令牌必须在每个后续请求的授权HTTP头中发送。存储第一个资源如下所示(简单的HTTP PUT-Request):</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="2dc9" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated"><code class="eh mn mo mp mq b">$server</code>定义为“<em class="lj">协议://主机:端口/ </em>”(例如<code class="eh mn mo mp mq b"><a class="ae mk" href="https://localhost:9443/" rel="noopener ugc nofollow" target="_blank">https://localhost:9443/</a></code>)。首先，创建一个名为<code class="eh mn mo mp mq b">database</code>的带有一些元数据的空数据库，其次，以我们内部的二进制格式存储名为<code class="eh mn mo mp mq b">resource1</code>的JSON片段。<code class="eh mn mo mp mq b">PUT HTTP-Request</code>是等幂的。具有相同URL端点的另一个PUT请求将删除以前的数据库和资源，并重新创建数据库/资源。注意，我们使用HTTP头“Content-Type”来指定它是哪种资源类型，因为我们当前允许创建XML和JSON数据库以及“Accept-Header ”,这是我们期望检索的资源类型(如果有的话)。</p><p id="b8c1" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">HTTP响应代码应该是200(一切正常)，在这种情况下，HTTP主体产生存储的资源。</p><p id="6de2" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">通过一个<code class="eh mn mo mp mq b">GET HTTP-Request</code>到<code class="eh mn mo mp mq b">https://localhost:9443/database/resource1</code>，我们也能够再次检索存储的资源。</p><p id="d04e" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">然而，到目前为止，这并不真正有趣。我们可以通过<code class="eh mn mo mp mq b">POST HTTP-Request</code>更新资源。首先，我们需要获得节点的内部的、惟一的node-ID，在这里我们要插入新的JSON-data:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="edf7" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">我们可以使用POST-或GET HTTP-请求，查询URL编码。查询参数允许直接在URI中指定简单的查询:</p><pre class="jj jk jl jm fq mr mq ms mt aw mu dt"><span id="7027" class="mv jw hu mq b fv mw mx l my mz"><strong class="mq hv">$server$serverPath?query=let%20%24nodeKey%20%3A%3D%20sdb%3Anodekey(.%3D%3Efoo%5B%5B2%5D%5D)%0Areturn%20%7B%22nodeKey%22%3A%20%24nodeKey%7D</strong></span></pre><p id="ce15" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">然而，正如我们所看到的，查询很快变得不可读。</p><p id="fe48" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">请记住，我们在数据库中存储了以下JSON文档:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="c380" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">例如，在上面的查询中，我们选择了“foo”，然后选择了数组中的第三个项目(2.33)，然后检索了它的节点键。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="b188" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">在这个例子中得到的节点密钥/节点标识符是6。假设我们像以前一样检索了访问令牌，我们可以简单地做一个后请求，并使用我们以前收集的关于节点密钥的信息:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="75b2" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">有趣的部分是我们用作端点的URL。我们简单地说，选择ID为6的节点，然后插入给定的JSON-data作为该节点的右兄弟，这是通过它的节点键选择的。这会产生以下序列化的JSON-document(注意，我们尽可能压缩JSON字符串，因此，这里漂亮的打印只是为了可读性):</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="3c4d" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">每个PUT-以及POST HTTP-请求都隐式地<code class="eh mn mo mp mq b">commits</code>底层事务，并因此创建一个新的修订。将一堆请求捆绑到单个事务中的想法是将事务公开为资源，例如，将它的ID与每个请求一起发送，并通过对特定“提交”资源/ GET端点的请求来提交资源。</p><p id="7e34" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">请记住，在我们最近提交之前，资源的第一个版本很容易被重建。因此，我们现在能够发送第一个GET-request来再次检索整个资源的内容，例如通过指定一个简单的查询，在所有修订中选择根JSON对象(在我们的例子中，到目前为止只存在两个修订)。因此，执行一个<code class="eh mn mo mp mq b">GET https://localhost:9443/database/resource1?query=jn:all-times(.)</code>请求并得到以下结果:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="3daf" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">请注意，我们在query-parameter中使用了时间旅行函数。一般来说，我们支持几个额外的时间旅行函数:<em class="lj"> jn:未来，jn:过去，jn:上一个，jn:下一个，jn:第一个，jn:最后一个和jn:所有时间</em>正如我们所看到的。我们还支持其变体，而当前上下文项也在结果集中(特别是过去或自己、未来或自己…)。</p><p id="3cb0" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">当然，通常的方法是，导航到您感兴趣的节点，添加谓词，然后及时导航，观察一个节点或整个子树是如何变化的。这是一个令人难以置信的强大特性，可能是未来文章的主题。注意，目前唯一值得注意的例外是空节点，它不能在时间轴上查询，因为我们的查询编译器Brackit目前为空项发出空序列。我们可能会在未来的版本中改变这一点。请注意，在未来的版本中，我们可能还会在查询编译器中为JSON部分实现更新原语，这样就有可能避免首先检索节点键，然后再发送另一个查询。我们可能会简单地添加XQuery函数作为第一步。</p><p id="bd7b" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">通过在GET-request中指定要序列化的修订范围(开始和结束修订参数),也可以达到同样的目的:</p><p id="8ae0" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated"><code class="eh mn mo mp mq b">GET <a class="ae mk" href="https://localhost:9443/database/resource1?start-revision=1&amp;end-revision=2" rel="noopener ugc nofollow" target="_blank">https://localhost:9443/database/resource1?start-revision=1&amp;end-revision=2</a></code></p><p id="7154" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">或者通过时间戳:</p><p id="2d51" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated"><code class="eh mn mo mp mq b">GET <a class="ae mk" href="https://localhost:9443/database/resource1?start-revision-timestamp=2018-12-20T18:00:00&amp;end-revision-timestamp=2018-12-20T19:00:00" rel="noopener ugc nofollow" target="_blank">https://localhost:9443/database/resource1?start-revision-timestamp=2019-04-20T18:00:00Z&amp;end-revision-timestamp=2019-14-20T19:00:00</a>Z</code></p><p id="4d97" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">但是，如果我们首先打开一个资源，然后通过一个查询选择单个节点，那么使用时间轴会更快，否则必须对每个打开的修订执行相同的查询(解析、编译、执行……)。</p><p id="4a02" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">我们当然也能够通过一个简单的<code class="eh mn mo mp mq b">DELETE</code> HTTP-request删除资源或其中的任何子树:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="ml mm l"/></div></figure><p id="03f4" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">这将删除节点键/ID为7的节点——在我们的例子中，它是整个子树的记录键节点(运行示例中的对象键“bar”)。当然，变更是作为修订版3提交的。如果在URL中省略nodeId参数，资源将被删除。如果您还忽略了资源名称，那么可能包含大量资源的整个数据库都将被删除。</p><p id="843d" class="pw-post-body-paragraph kn ko hu kp b kq mf iv ks kt mg iy kv kw mh ky kz la mi lc ld le mj lg lh li hn dt translated">因此，在事务提交期间，仍然可以查询整个子树的所有旧修订，这使它成为审计、纠正人为或应用程序错误的理想候选。</p><h2 id="3a92" class="mv jw hu bd jx na nb nc kb nd ne nf kf kw ng nh kh la ni nj kj le nk nl kl nm dt translated">注意，我们也有复杂的区分能力，但是现在缺少一个合适的JSON序列化格式。关于XML，我们目前发出XQuery Update语句。此外，我们希望重新启用一个过时的图形用户界面的基础上(仍然；-))用于比较树结构的新的可视化方法:<a class="ae mk" href="https://www.youtube.com/watch?v=l9CXXBkl5vI&amp;t=26s" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=l9CXXBkl5vI&amp;t = 26s</a></h2><p id="16fa" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">接下来，预编译的用户定义的XQuery脚本也应该可以存储在应用服务器上。</p></div><div class="ab cl nn no hc np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="hn ho hp hq hr"><h1 id="bad3" class="jv jw hu bd jx jy nu ka kb kc nv ke kf ja nw jb kh jd nx je kj jg ny jh kl km dt translated">支持我</h1><p id="dafe" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">如果你喜欢这样，不如来点掌声让更多的人看到，或者来点<a class="ae mk" href="https://github.com/sirixdb/sirix" rel="noopener ugc nofollow" target="_blank"> <strong class="kp hv"> Github </strong> </a>上的明星？🙂👏最重要的是，请检查并让我知道，因为目前我是唯一一个在Sirix上工作的人，现在比以往任何时候都更渴望提出一个版本化的、安全的时态分析平台作为开源社区的愿景(<strong class="kp hv">我很乐意听到任何建议、反馈、对未来工作的建议，例如关于云中水平扩展(即复制/分区)的工作、bug报告；-)，只是一切…请联系</strong> ) :-)</p><h2 id="f203" class="mv jw hu bd jx na nb nc kb nd ne nf kf kw ng nh kh la ni nj kj le nk nl kl nm dt translated">开源库:<a class="ae mk" href="https://github.com/sirixdb/sirix" rel="noopener ugc nofollow" target="_blank">https://github.com/sirixdb/sirix</a></h2><h2 id="e56c" class="mv jw hu bd jx na nb nc kb nd ne nf kf kw ng nh kh la ni nj kj le nk nl kl nm dt translated">Sirix网址:<a class="ae mk" href="https://sirix.io" rel="noopener ugc nofollow" target="_blank"> https://sirix.io </a></h2><h2 id="b22e" class="mv jw hu bd jx na nb nc kb nd ne nf kf kw ng nh kh la ni nj kj le nk nl kl nm dt translated">新社区论坛:<a class="ae mk" href="https://sirix.discourse.group" rel="noopener ugc nofollow" target="_blank">https://sirix . discourse . group</a></h2><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="nz mm l"/></div></figure></div></div>    
</body>
</html>