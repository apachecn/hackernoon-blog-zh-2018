<html>
<head>
<title>Beyond Solidity, part 1: Setting up the Monorepo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超越可靠性，第1部分:建立单一报告</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/beyond-solidity-part-1-setting-up-the-monorepo-8db094ebbee5?source=collection_archive---------11-----------------------#2018-12-30">https://medium.com/hackernoon/beyond-solidity-part-1-setting-up-the-monorepo-8db094ebbee5?source=collection_archive---------11-----------------------#2018-12-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="7892" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在为8x开发智能合约之后，我以为一切都结束了。那远非事实。随着时间的推移，对分散协议的要求逐渐增加，需要:</p><ul class=""><li id="4e75" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">一个易于使用的JS库</li><li id="dc03" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">最新的合同地址和ABIs</li><li id="e976" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">文档(动态的，因为实际上是谁更新了静态文档)</li><li id="cfe1" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">开发者实用程序</li><li id="572c" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">dApp/widget与底层协议交互</li><li id="3313" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">整合或包含您的dApp/widget的营销网站</li></ul><p id="e218" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些要求或多或少都需要自己的回购。在你知道之前，你将会管理超过7个不同的回购协议，每个协议都有版本控制。突然，在一个包中做一个小的改变将需要在至少另外两个包中做一个<code class="eh kd ke kf kg b">npm install</code>(最好的情况)。</p></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><p id="c099" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么这种疯狂的答案是什么呢？一个<strong class="it hv">单报告</strong>。</p><p id="93c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我第一次看到monorepo的时候，感觉有点像这样:</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div class="fe ff ko"><img src="../Images/2ba06abdf641126ef697e0a9b5b87597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*JwmYx3GZXG0oaLYjIv72TQ.jpeg"/></div></figure></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><p id="17f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一开始感觉有点违背直觉，为什么你会有一个包含所有回购的回购？微软、脸书和谷歌等许多大公司已经给出了答案，它们的整个代码库都有一个单一的回购协议。以下是其中的一些:</p><ul class=""><li id="6a3a" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">版本控制管理的简易性</li><li id="d53a" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">通过引用它们的本地路径，以一些非常简洁的方式操作你的repos</li><li id="ce63" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">大规模重构变得容易(如果你搞砸了什么，你的整个代码库将立即崩溃)</li><li id="7890" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">整个组织代码库的可见性</li><li id="e17a" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">避免团队间的非发明综合症</li></ul><p id="8f7e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有些事情可能看起来有点抽象，但我保证你最终会明白的。</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div class="fe ff kw"><img src="../Images/ceb8185dd6e4234c89217e36046f966f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*wq7BV3_ECYFtPtM5xIwTeg.jpeg"/></div></figure></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><h1 id="448c" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">最底层的</h1><p id="77d2" class="pw-post-body-paragraph ir is hu it b iu lv iw ix iy lw ja jb jc lx je jf jg ly ji jj jk lz jm jn jo hn dt translated"><em class="ma">为了创建我们的monorepo，我们将使用Lerna:</em><a class="ae mb" href="https://github.com/lerna/lerna" rel="noopener ugc nofollow" target="_blank"><em class="ma">https://github.com/lerna/lern</em></a></p><p id="29e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是你在新文件夹中想要做的事情</p><p id="0fd4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.创建一个新目录<code class="eh kd ke kf kg b">mkdir monorepo &amp;&amp; cd $_</code></p><p id="a3a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.全球安装lerna】</p><p id="0a34" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.为您的新monorepo创建结构<code class="eh kd ke kf kg b">lerna init</code></p><p id="0248" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">4.使用<code class="eh kd ke kf kg b">lerna import /path/to/your/contracts/repo</code>导入您现有的智能合约回购(这将保留您的提交历史，所以不用担心从零开始，年轻人)。</p><p id="41f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好了，在我们继续之前，你很快就会有一个看起来有点像这样的结构:</p><pre class="kp kq kr ks fq mc kg md me aw mf dt"><span id="7f5c" class="mg ky hu kg b fv mh mi l mj mk">monorepo/<br/>├── package.json<br/>├── packages<br/>│   └── contracts<br/>│       └── package.json<br/>│   └── another_one<br/>│       └── package.json<br/>│   └── another_one<br/>│       └── package.json</span></pre><p id="f951" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本质上，这意味着您的所有依赖项都将相互关联，因此一个存储库中的更改会立即在其他存储库中显示出来，因为它们引用的是本地文件系统中的相同路径，而不是始终包含重复的代码。你需要做的就是运行<code class="eh kd ke kf kg b">lerna bootstrap</code>一次。</p><p id="e1b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是你也可以开始做一些很酷的事情，比如:</p><p id="8b6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kd ke kf kg b">lerna run build</code>哪个将在每个回购<strong class="it hv">或</strong>内运行<code class="eh kd ke kf kg b">npm run build</code></p><p id="dec2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kd ke kf kg b">lerna publish</code>这将把你所有的软件包升级到同一个版本(如果你要部署一套新的智能合约，这很有用)。如果你在你所有的repos中添加一个<code class="eh kd ke kf kg b">prepublish</code>脚本，这个脚本将依次<code class="eh kd ke kf kg b">clean</code>你的<code class="eh kd ke kf kg b">dist</code>文件夹、<code class="eh kd ke kf kg b">lint</code>你的代码库并生成你最终的<code class="eh kd ke kf kg b">dist</code>文件夹，这将变得更好。</p><pre class="kp kq kr ks fq mc kg md me aw mf dt"><span id="ac70" class="mg ky hu kg b fv mh mi l mj mk">"scripts": {</span><span id="0ae4" class="mg ky hu kg b fv ml mi l mj mk">"clean": "rimraf -rf ./dist",</span><span id="94db" class="mg ky hu kg b fv ml mi l mj mk">"lint": "tslint --project tsconfig.json -c tslint.json",</span><span id="9ced" class="mg ky hu kg b fv ml mi l mj mk">"build": "npm run clean &amp;&amp; npm run lint &amp;&amp; tsc,</span><span id="01de" class="mg ky hu kg b fv ml mi l mj mk">"prepublishOnly": "npm run build"</span><span id="d6ad" class="mg ky hu kg b fv ml mi l mj mk">}</span></pre></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><h1 id="602e" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">自述文件</h1><p id="f59b" class="pw-post-body-paragraph ir is hu it b iu lv iw ix iy lw ja jb jc lx je jf jg ly ji jj jk lz jm jn jo hn dt translated">如果你要把所有的鸡蛋放在一个篮子里，确保那个篮子看起来很体面！</p><p id="72fa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<code class="eh kd ke kf kg b">monorepo</code>文件夹的根目录下，创建一个名为<code class="eh kd ke kf kg b">readme.mustache</code>的新文件</p><p id="1e9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我知道，你在想为什么不是<code class="eh kd ke kf kg b">readme.md</code>？我们稍后将回到这一点，但现在你可以这样炫耀你的回购:</p><pre class="kp kq kr ks fq mc kg md me aw mf dt"><span id="18a8" class="mg ky hu kg b fv mh mi l mj mk">&lt;p align="center"&gt;&lt;img src="<strong class="kg hv">your-logo</strong>" width="280"/&gt;&lt;/p&gt; </span><span id="1c04" class="mg ky hu kg b fv ml mi l mj mk">&lt;p align="center"&gt;</span><span id="3517" class="mg ky hu kg b fv ml mi l mj mk"><strong class="kg hv">insert-description-here</strong></span><span id="5435" class="mg ky hu kg b fv ml mi l mj mk">&lt;/p&gt; </span><span id="92a8" class="mg ky hu kg b fv ml mi l mj mk">&lt;p align="center"&gt;  </span><span id="94a9" class="mg ky hu kg b fv ml mi l mj mk">&lt;a href="https://opensource.org/licenses/Apache-2.0"&gt;    <br/>   &lt;img src="https://img.shields.io/badge/LICENSE-APACHE2.0-3DA639.svg"/&gt;  <br/>&lt;/a&gt;</span><span id="11f3" class="mg ky hu kg b fv ml mi l mj mk">&lt;/p&gt;</span></pre><p id="6e10" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这会给你一些类似这样的东西(少了聊天和<a class="ae mb" href="https://hackernoon.com/tagged/solidity" rel="noopener ugc nofollow" target="_blank">坚固性</a>徽章，在我们将其转换为降价之后):</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff mm"><img src="../Images/d4b046457d6de00403d3fb9f0cd111d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ysUG2VZNrna6V0bO8DzNGg.png"/></div></div></figure><p id="b14f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个很好的开始，但是你的开发伙伴想要看到你的monorepo中的所有包以及它们各自的版本。让我们给我们的<code class="eh kd ke kf kg b">readme.mustache</code>添加更多的代码:</p><pre class="kp kq kr ks fq mc kg md me aw mf dt"><span id="6093" class="mg ky hu kg b fv mh mi l mj mk">## Packages</span><span id="9a4a" class="mg ky hu kg b fv ml mi l mj mk">### Published</span><span id="41c7" class="mg ky hu kg b fv ml mi l mj mk">|   Package   |   Version   |   Description   |<br/>-----------------------------------------------</span><span id="b98d" class="mg ky hu kg b fv ml mi l mj mk">|<strong class="kg hv">[`name`](/packages/path)</strong> | <strong class="kg hv">[![npm](https://img.shields.io/npm/v/name.svg)](https://www.npmjs.com/package/name) </strong>| a description |</span><span id="7325" class="mg ky hu kg b fv ml mi l mj mk">### Private</span><span id="c3a4" class="mg ky hu kg b fv ml mi l mj mk">|   Package   |   Description   |<br/>---------------------------------<br/>|<strong class="kg hv">[`name`](/packages/path) </strong>| a description |</span></pre><p id="30a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想知道，发布的包是你要用npm发布的包，以便在其他回购中使用。私有包是您不会导入到另一个项目中的包。示例包括智能合同、营销网站等。那么上面的净给我们带来了什么？<strong class="it hv">这个</strong>:</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="fe ff mr"><img src="../Images/9c3b48168ebd8280a7de3e14f14c87f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0JuwpdDEaTrxSvge-rZfQg.png"/></div></div></figure><p id="97dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们要添加的下一段代码是:</p><pre class="kp kq kr ks fq mc kg md me aw mf dt"><span id="f255" class="mg ky hu kg b fv mh mi l mj mk">### Contracts (<strong class="kg hv">insert network here</strong>)<br/>| Contract Name | Address |<br/>| ------------- | ------- |</span><span id="d867" class="mg ky hu kg b fv ml mi l mj mk">{{#<strong class="kg hv">network</strong>.addresses}}<br/>| {{name}} | {{address}} |<br/>{{/<strong class="kg hv">network</strong>.addresses}} </span></pre><p id="eefa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们稍后将再次讨论这一点，但是现在您将想要插入您的项目当前所在的网络(kovan、main-net等)。</p></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><h1 id="9acd" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">暂时就这样吧！</h1><p id="80a4" class="pw-post-body-paragraph ir is hu it b iu lv iw ix iy lw ja jb jc lx je jf jg ly ji jj jk lz jm jn jo hn dt translated">现在，我们已经具备了创建实际协议的基础，并且拥有相关资源，任何访问者都可以(几乎)找到他们想要的东西。</p><p id="7e6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请继续关注下一期教程，在那里我们将详细介绍如何生成Typescript工件，以及如何编写后续的JS库供其他开发人员使用。</p><figure class="kp kq kr ks fq kt"><div class="bz el l di"><div class="ms mt l"/></div></figure></div></div>    
</body>
</html>