<html>
<head>
<title>Pushing Database Versioning to Its Limits by Means of a Novel Sliding Snapshot Algorithm and Efficient Time Travel Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过新颖的滑动快照算法和高效的时间旅行查询，将数据库版本控制推向极限</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-and-how-we-built-a-temporal-database-system-called-sirixdb-open-source-from-scratch-a7446f56f201?source=collection_archive---------10-----------------------#2018-12-31">https://medium.com/hackernoon/why-and-how-we-built-a-temporal-database-system-called-sirixdb-open-source-from-scratch-a7446f56f201?source=collection_archive---------10-----------------------#2018-12-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="2520" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于当前大多数数据库系统仍然只是将当前状态或过去状态存储在一个大的关系表中，因此我们研究了性能驱动因素以及如何改进当前的技术水平。io ),它存储小尺寸的快照并支持复杂的时间旅行查询，同时与非时态数据库系统的效率竞争。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/dd56b664d92a88376810af1df87e1b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*j8pCR0heKRznTIuwCA1chA.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Sunbirst view of a resource stored in Sirix (showing file system data)</figcaption></figure><h1 id="2377" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">什么是时态数据库系统？</h1><p id="8071" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">这是一个用来描述系统能够检索数据过去状态的术语。典型地，时态数据库既存储<strong class="it hv">有效时间</strong>，即一个事实在现实世界中为真的时间，也存储<strong class="it hv">事务时间</strong>，即数据实际提交到数据库的时间。</p><p id="d3cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问题如:<em class="jp">给我上个月美元对英镑对欧元汇率的历史。</em><em class="jp">2015年7月12日当天记录的客户地址是什么？是他们移动了还是我们纠正了一个错误？我们在数据库中有错误吗，这些错误后来被纠正了吗？</em></p><p id="26b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们转向或专注于这样一个问题:为什么历史数据在过去没有被保留，以及近年来新的存储技术的进步如何使得构建复杂的解决方案来帮助回答这些问题成为可能，而没有最先进的系统带来的障碍。</p><h1 id="a6df" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">固态硬盘等闪存驱动器的优势和劣势</h1><p id="1db4" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">正如Marc Kramis在他的论文<a class="ae lj" href="http://kops.uni-konstanz.de/bitstream/handle/123456789/5914/report.pdf?sequence=1&amp;isAllowed=y" rel="noopener ugc nofollow" target="_blank">中指出的那样,</a>让持久的树木进入21世纪:</p><blockquote class="lk ll lm"><p id="27c4" class="ir is jp it b iu iv iw ix iy iz ja jb ln jd je jf lo jh ji jj lp jl jm jn jo hn dt translated">向闪存驱动器的转变强烈地促使人们从“当前状态”范式转向记住导致这种状态的进化步骤。</p></blockquote><p id="4d96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">主要观点是，如今常见的固态硬盘等闪存驱动器具有零寻道时间，同时无法对数据进行就地修改。闪存驱动器分为页面和数据块，而数据块由于其特性，能够在精细的页面级别读取数据，但只能在较粗的数据块级别擦除数据。在更新数据块之前，必须先将其擦除。因此，更新的数据首先被写入另一个地方。垃圾收集器将已被重写到新位置的数据标记为已擦除，以便将来可以存储新数据。此外，索引结构被更新。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff lq"><img src="../Images/b10fe5d20338aff648e825c5c7b237ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bHwVd6phGROGnZi1hJqHHQ.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Evolution of state through fine grained modifications</figcaption></figure><p id="75bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，Marc指出，由于传统机械磁盘磁头寻道时间的缓慢随机读取导致的群集要求，小的修改通常不仅涉及写入修改的数据，还涉及写入修改的页面中的所有其他记录以及具有未修改数据的多个页面。这显然是不希望的结果。</p><h1 id="7e67" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">我们如何基于这些观察从零开始构建一个开源存储系统</h1><blockquote class="lr"><p id="0383" class="ls lt hu bd lu lv lw lx ly lz ma jo ek translated">Sirix存储每个版本和每个页面的增量。</p></blockquote><p id="ec3c" class="pw-post-body-paragraph ir is hu it b iu mb iw ix iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo hn dt translated">由于闪存驱动器的寻道时间为零，我们不必对数据进行群集。Sirix只在事务提交期间聚集数据。它基于只追加存储。<strong class="it hv">数据从不就地修改。</strong></p><p id="0543" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">相反，一旦事务提交，它就被成批地复制并附加到内部树结构的后序遍历中的文件中。</p><p id="53ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们借鉴了文件系统<strong class="it hv"> ZFS </strong>的想法，例如存储在父数据库页面/页面片段中的校验和，这形成了自我验证的merkle树以及我们内部的数据库页面树结构。</p><blockquote class="lr"><p id="3cef" class="ls lt hu bd lu lv lw lx ly lz ma jo ek translated">与其他<strong class="ak">写时复制</strong> (COW)方法形成鲜明对比，然而我们并不是简单地复制整个记录页，这是对存储空间的浪费。根据所使用的版本控制算法，我们只从页面中复制一些记录(每次都是改变的记录本身)。</p></blockquote><p id="a2af" class="pw-post-body-paragraph ir is hu it b iu mb iw ix iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo hn dt translated"><strong class="it hv">用于存储和检索记录级快照的版本控制算法</strong></p><p id="a947" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于大多数数据库系统，我们最多存储固定数量的记录，即每个数据库页面的实际数据(目前最多512条记录)。记录本身的大小是可变的。超过预定义字节长度的超长记录存储在额外的溢出页中，仅在记录页中引用。</p><p id="f765" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们实现了许多版本控制策略，这些策略在备份系统中最为人所知，用于记录页的写时复制操作。也就是说，我们要么复制</p><ul class=""><li id="db7a" class="mg mh hu it b iu iv iy iz jc mi jg mj jk mk jo ml mm mn mo dt translated">完整记录-页面，即页面中的任何记录(<strong class="it hv">完整</strong>)</li><li id="b933" class="mg mh hu it b iu mp iy mq jc mr jg ms jk mt jo ml mm mn mo dt translated">仅记录页中关于先前版本的已更改记录(<strong class="it hv">增量</strong>)</li><li id="80ae" class="mg mh hu it b iu mp iy mq jc mr jg ms jk mt jo ml mm mn mo dt translated">自整页转储(<strong class="it hv">差异</strong>)以来，记录页中只有已更改的记录</li></ul><p id="3958" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">众所周知，这些版本控制策略各有优缺点。简单地存储整个页面(<strong class="it hv">满)</strong>对于读取操作来说是非常有效的。然而，与所有其他方法相比，写入性能是最差的，因为我们只是复制所有未更改的记录以及所有已更改的记录。</p><p id="48b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">增量</strong>-版本控制是另一个极端，写性能是最好的，因为它存储了最佳值(仅更改的记录)，但另一方面，重建页面需要间歇性的完整页面快照，这样，性能不会随着页面的每个新版本而下降，因为增量的数量随着每个新版本而增加。</p><p id="7445" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">差异</strong>——版本控制试图更好地平衡读写，但仍然不是最佳的。每次修改页中的记录时，都会写入一个新页，其中包含自上次完全转储该页以来所有已更改的记录。这意味着只需读取页面片段的两次修订即可重建记录页面。然而，写入性能也会随着页面的每个新修订而恶化。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/06b14ae6648274c74648b03a83b81318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*MBuIiFdKuz7tr1mbZPfqjA.png"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">The screenshot depicts an (Interactive) Visualization of moved subtrees in Sirix throug hierarchical edge bundles</figcaption></figure><p id="b0ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">增量</strong>版本控制在写入性能方面，由于页面的间歇性完全转储要求会导致写入峰值。差异版本控制也有类似的问题。如果没有间歇性的完整转储，每次新写入时都必须复制大量数据。</p><blockquote class="lr"><p id="8532" class="ls lt hu bd lu lv lw lx ly lz ma jo ek translated">Marc Kramis提出了一种新颖的滑动快照算法的想法，该算法平衡了读/写性能，以避开任何写峰值。</p></blockquote><p id="fbd5" class="pw-post-body-paragraph ir is hu it b iu mb iw ix iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo hn dt translated">该算法利用了滑动窗口。首先，任何改变的记录必须被存储，其次，任何比窗口的预定义长度<strong class="it hv"> N </strong>旧的并且在这些<strong class="it hv"> N </strong>修订期间没有被改变的记录。只有这些<strong class="it hv">N</strong>-最大修订版必须被读取。获取页面片段可以并行进行，或者一旦从最近的修订开始重建了整页，我们就简单地停止。</p><p id="3a7d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦我们确定我们的存储系统线性地获取旧版本和最新版本，对数地获取和存储单个记录以及整个版本，我们就把注意力集中到上层。</p><h1 id="1a62" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">DOM alike API</h1><blockquote class="lk ll lm"><p id="6930" class="ir is jp it b iu iv iw ix iy iz ja jb ln jd je jf lo jh ji jj lp jl jm jn jo hn dt translated">然后我们投入了大量的工作来实现一个持久的DOM接口(例如存储XML文档，以及将来的JSON文档)。</p></blockquote><p id="5ac7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的记录存储有稳定的标识符，这些标识符永远不会改变，不管记录是否更新，也不管它们实际存放在哪里。为删除的记录插入标记。编码只是第一个孩子、左兄弟、右兄弟、父母和节点ID，以便存储当前XML/XDM节点的一种DOM表示。</p><h1 id="99ae" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">版本化、类型化、用户定义的索引</h1><blockquote class="lr"><p id="f390" class="ls lt hu bd lu lv lw lx ly lz ma jo ek translated">然后，我们再次将重点转移到实现版本化的用户定义的索引结构上。</p></blockquote><p id="f3f1" class="pw-post-body-paragraph ir is hu it b iu mb iw ix iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo hn dt translated">在每个事务提交期间，不仅会生成存储数据的快照，还会生成索引的快照。目前的索引是基于AVL树/AVL节点，这些节点存储在我们内部类似ZFS树结构的不同子树的记录页中。</p><blockquote class="lk ll lm"><p id="9d18" class="ir is jp it b iu iv iw ix iy iz ja jb ln jd je jf lo jh ji jj lp jl jm jn jo hn dt translated">资源中所有路径的路径摘要始终保持最新。</p></blockquote><p id="0e6f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了使用户能够充分利用我们的时态数据库系统，并实际上轻松地回答前面提到的问题，我们扩展了一个名为Brackit的查询编译器。</p><blockquote class="lr"><p id="5d02" class="ls lt hu bd lu lv lw lx ly lz ma jo ek translated">用户现在能够打开特定的修订版，在类似DOM的树结构中导航以选择特定修订版中的节点，然后及时导航。例如，通过新颖的基于时间的轴，可以很容易地分析所选择的或一系列的记录/节点在下一个版本、前一个版本、第一个或最后一个版本、过去或未来版本、所有版本中看起来如何…</p></blockquote><p id="84cb" class="pw-post-body-paragraph ir is hu it b iu mb iw ix iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo hn dt translated">此外，我们能够基于给定的时间戳或修订的id来查询修订的范围。</p><p id="4bdf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，如果我们想要导入预先存在的文档的几个修订，或者独立于我们选择的版本控制算法比较存储在我们系统中的任何修订，该怎么办呢？</p><h1 id="fdf4" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">差分算法</h1><p id="ca04" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated"><strong class="it hv"> FMSE差分算法</strong></p><p id="6c5d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们首先实现了一个名为<strong class="it hv">快速匹配简单编辑脚本</strong> (FMSE)的diff算法，以支持文档不同版本的导入，并在我们的存储系统中提交几个修订。该算法不依赖于节点标识符。它基于子树的相似性进行匹配，首先在要导入的树形结构文档(目前是XML，将来也是JSON)的叶节点上计算一个<strong class="it hv">最长公共子序列</strong> (LCF)。然后它试图从下往上匹配。在下一步中，应用编辑操作将文档从一个版本转换到另一个版本。该算法显然在一种形式的树到树校正问题中使用了启发式算法，因此是NP难的。如果叶节点非常独特，它工作得最好，并且产生最小的编辑脚本。</p><p id="211b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">基于ID的算法，可选地利用存储的散列值</strong></p><p id="3396" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了计算Sirix-resources的任何修订版之间的差异，并且不考虑记录页级别的版本控制，我们开发了一种算法，该算法利用了我们的稳定记录标识符(这是基于序列生成器的，它从不重新分配id(例如从已删除的记录中)。如果我们在插入期间存储节点的散列，如果节点标识符以及散列匹配，diff算法能够跳过整个子树。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mv"><img src="../Images/bb35032a3b1929e4c3cfc3307a8f4940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IOTSBDbCLmvPdfuC6QFKKg.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek"><strong class="bd mw">Depicts how the ID-based diff algorithm works</strong></figcaption></figure><h1 id="7976" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">非阻塞、异步RESTful API</h1><p id="942e" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">我们最近在XQuery和DOM-API层之上构建了一个更高级别的API，用于与基于Vert.x、Kotlin/Coroutines和Keycloak的Sirix服务器进行通信，以进行身份验证。其实现和使用示例已经是另一篇<a class="ae lj" rel="noopener" href="/how-we-built-an-asynchronous-temporal-restful-api/how-we-built-an-asynchronous-temporal-restful-api-based-on-vert-x-4570f681a3">文章</a>的主题。</p><h1 id="1a8e" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">一种用于比较树结构的可视化分析方法</h1><p id="7ac9" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">如一些截图所示，我们曾经开发了一种可视化分析方法来比较存储在Sirix中的树形结构。但是，它有点过时了，需要移植到网络上。</p><h1 id="579e" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated"><strong class="ak">我们正在做的事情</strong></h1><blockquote class="lr"><p id="3a58" class="ls lt hu bd lu lv lw lx ly lz ma jo ek translated">接下来，我们将研究如何最好地存储JSON-documents，这简单地归结为我们希望记录有多细粒度的问题(例如对象记录节点、数组索引节点……)</p></blockquote><p id="9e6f" class="pw-post-body-paragraph ir is hu it b iu mb iw ix iy mc ja jb jc md je jf jg me ji jj jk mf jm jn jo hn dt translated">然而，我们非常乐意讨论未来的方向和想法。非常感谢任何帮助。</p></div><div class="ab cl mx my hc mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hn ho hp hq hr"><p id="0b0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你喜欢这个，请给我们一些掌声，让更多的人看到它或Github上的一颗星…最重要的是检查一下(<strong class="it hv">我们很乐意听到任何建议，反馈，对未来工作的建议，例如关于JSON或云的水平扩展的工作，错误报告；-)，只是一切…请联系</strong> ) :-)</p><h1 id="af73" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated"><strong class="ak">我们的开源库:</strong><a class="ae lj" href="http://sirix.io" rel="noopener ugc nofollow" target="_blank"><strong class="ak">http://sirix . io</strong></a></h1></div></div>    
</body>
</html>