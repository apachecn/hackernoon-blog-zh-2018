# 3 种括号:你是正则表达式大师吗？

> 原文：<https://medium.com/hackernoon/3-kinds-of-parentheses-are-you-a-regex-master-6b10eb4f41e8>

![](img/c4639b9752a4a0906490f5df88c62109.png)

如果您曾经花时间编写代码，那么毫无疑问，您已经滥用了正则表达式，直到它们变成一堆难以理解的字符，可能会给真正的解析器带来麻烦。即便如此，当我得知正则表达式中有 3 种不同的括号，而不仅仅是 2 种时，我还是很惊讶。

不，2 不是左和右，聪明的家伙。

三种类型的括号是文字括号、捕获括号和非捕获括号。你可能知道如何捕捉括号。您也可以识别文字括号。让大多数人感到困惑的是非捕获括号，以及围绕多重和嵌套捕获括号的语义。(真正的正则表达式大师，请按住“但是等等，还有更多！”为结论)。

## 文字括号

文字括号就是你想要匹配的文字。假设您想要匹配形式为`(xxx)yyy-zzzz`的美国电话号码。您可以将正则表达式写成`/\(\d{3})\d{3}-\d{4}/`。请注意，我们必须键入`\(`，而不仅仅是一个裸体的`(`。这是因为原始括号启动了一个捕获或非捕获组。如果我们想匹配文本中的文字括号，我们必须用`\`对其进行转义。

## 捕捉括号

你可能也写了一些捕获括号，不管你是否打算捕获。这些括号不是用来匹配文本中的文字`()`，而是用来在正则表达式中将字符分组，以便我们可以应用其他运算符，如`+`、`*`、`?`或`{n}`。

例如，如果我们只想匹配字符串`can`或`can’t`，我们可以写`/can('t)?/`。我们在这里需要括号，因为`/can't?/`将只匹配字符串`can’`和`can’t`，而不是我们想要的。

![](img/af339eea172c75f53bb0a0109758285d.png)

Photo by [David Clode](https://unsplash.com/photos/13PjNBaDMcg?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/search/photos/butterfly?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

然而，这里还发生了别的事情。这些被称为捕捉括号是有原因的——即它们捕捉任何与它们所包含的表达式相匹配的内容，供程序以后使用。继续这个可以/不可以的例子，在 JavaScript 中我们得到:

```
const match = /can('t)?/.exec("We can't do it!");
 console.log(match[0]); // prints the match "can't"
 console.log(match[1]); // prints captured "'t"
```

这里，`match[1]`包含由括号捕获的项目。现在这有点无趣，因为我们真的不关心与单词`can’t`分开的`‘t` 。

电话号码的例子变得更加有趣。在 JavaScript 中，我们可以提取美国风格电话号码的区号，如下所示:

```
const match = /\((\d{3})\)\d{3}-\d{4}/.exec("(303)555-1212");
console.log(match[0]); // (303)555-1212
console.log(match[1]); // 303
```

让我们仔细看看这个正则表达式中发生了什么，`/\((\d{3})\)\d{3}-\d{4}/`。它几乎与我们在文字括号示例中使用的表达式相同，但是这次我在这对文字括号中添加了一组捕获括号。这告诉正则表达式引擎记住捕获括号内的匹配部分。这个捕获的匹配就是我们在`match[1]`中找到的。注意，整个电话号码匹配都在`match[0]`中。这个小例子展示了捕捉括号的强大功能。上面，我们用它从一个电话号码中提取了一个区号。我们可以用它来提取各种文本——穷人的解析器。

![](img/c610bdf2bc01e2926cae3b17b5e7dcfc.png)

[“Exploits of a Mom”](https://xkcd.com/327/) from [XKCD](http://www.xkcd.com)

作为另一个简单的例子，我们可以使用捕捉括号通过`/(\D+) (\D+)/`提取名字和姓氏。`match[1]`会有名字，`match[2]`会有姓氏，假设你和鲍比·表的名字不匹配(见漫画)，或者有多余的空格要处理。

## 非捕获括号

现在，我们来看第三种括号——非捕获括号。有时候，您需要在一个正则表达式中将事物组合在一起，但是您不想捕获匹配，就像上面的 can/can 示例一样。为了避免捕获`‘t`，我们写`/can(?:'t)?/`。在这里，我们得到的是完整的匹配，没有子匹配。

`(?:`是一个特殊的序列，它开始一个带括号的组，就像`(`一样，但是正则表达式引擎被告知，不要费心捕捉组中的匹配，只需使用它作为操作符优先级。让我们看一个更复杂的例子，在这个例子中，忽略带括号的组是有用的。

让我们扩展电话号码正则表达式，允许前缀为`mobile`或`office`。只捕捉括号，看起来像`match = /((mobile|office) )?\((\d{3})\)\d{3}-\d{4}/.exec(...)`。(这还高深莫测吗？).问题是我们要提取的区号在`match[3]`里。(至于为什么，我将把它作为一个练习留给读者。)这是令人困惑的，也是不必要的，因为在这个例子中，除了区号之外，我们不关心注释或任何其他东西。要仅捕获区号，我们可以:

```
const re = /(?:(?:mobile|office) )?\((\d{3})\)\d{3}-\d{4}/;
const match = re.exec('mobile (303)555-1212');
console.log(match[0]); //mobile (303)555-1212
console.log(match[1]); //303
```

注意注释周围的两组非捕获括号`(?:`，但是在区域代码周围使用了常规的捕获括号。

> **有些人在遇到问题时会想
> “我知道，我会用正则表达式。”现在他们有两个问题。**
> 
> [**——杰米·扎温克西**](https://www.jwz.org/)

## 但是等等，还有呢！

现在你有了，三种括号，字面的，捕捉的和非捕捉的——`\(`，`(`，`(?:`。我们可能应该比现在更多地使用`(?:`，但是我发现它很难阅读，所以只要`(`不会导致任何性能问题或对现有正则表达式的语义改变(通过改变寻找相关组匹配所需的索引)，我将跳过额外的`?:`。我不确定这是否是最佳实践，但是让我们面对现实吧，正则表达式已经很难读懂了。

真正的正则表达式大师知道还有其他类型的括号也使用`(?`语法。唉，我实际上不是正则表达式专家，所以我将让您去搜索其他资源来了解这些内容，因为许多本机正则表达式库不支持它们，JavaScript 就是其中之一。[命名的正则表达式组](https://www.regular-expressions.info/named.html)是其中最有用的。