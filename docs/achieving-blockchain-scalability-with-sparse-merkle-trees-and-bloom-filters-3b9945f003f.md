# 利用稀疏 Merkle 树和 Bloom 过滤器实现区块链可扩展性

> 原文：<https://medium.com/hackernoon/achieving-blockchain-scalability-with-sparse-merkle-trees-and-bloom-filters-3b9945f003f>

安德鲁·巴里瑟

![](img/8cad6d9ad9ba0dedf2a6de865563ee06.png)

Merkle Trees in Bitcoin

规模问题是阻碍比特币等区块链技术被广泛采用的主要因素。现有的这些系统根本无法扩展。我们被迫一次又一次地问这个问题，如果为了保持不信任，每个用户都必须验证每笔交易，我们如何才能将无信任范式扩展到数百万甚至数十亿用户？

在这篇文章中，我将阐述我对这个问题的想法，并提出一个包含稀疏 Merkle 树和 Bloom 过滤器的系统。它将保留比特币的许多功能，即工作证明和块头确认。但是我提出了一个建议，我希望这个建议可以比当前系统获得 10 倍或更多的可伸缩性，当前系统依赖于全局状态验证。提高可伸缩性的关键是不需要用所有事务的全局视图来验证任何单个事务的有效性。

## 稀疏的 Merkle 树

首先，让我介绍稀疏 Merkle 树。这些是 [Merkle 树](https://en.wikipedia.org/wiki/Merkle_tree)，除了它们在潜在的极端深度只有稀疏的子节点。例如，我们可以想象一棵深度为 256 的 Merkle 树。这样的树将有 2 个⁵⁶叶节点，比可见宇宙中的亚原子粒子数还要多。然而，想象一下，只有这些叶节点的有限子集被填充了数据。其余的是“空的”叶节点。空叶节点的父节点本身是可预测的。整个树是稀疏的，因为只有很少的可用路径被占用。要了解更多信息，请查看我的稀疏 Merkle 树的 [Python 实现](https://github.com/barisser/smerkle)(即 SMT)。

## 布隆过滤器

[布隆过滤器](https://en.wikipedia.org/wiki/Bloom_filter)是概率数据结构，其允许固定长度的表示来缓存集合中元素的存在。它没有假阴性。诀窍是，它有概率误报。误报率是分配给布隆过滤器的空间量和其中存储的元素数量之间的比率的函数。有计算最佳布鲁姆过滤器结构的公式，你可以在这里找到一个漂亮的计算器。例如，可以创建具有 44 比特/存储元素的 10^-9 假阳性错误率的布隆过滤器。因此，预计存储多达 1000 个元素的过滤器将消耗 44kB 的空间，并为任何非成员元素提供 0.0000001%的误报概率。

布隆过滤器通常用于许多不同的应用中。

## 验证交易的关键要素

区块链允许用户独立验证所有交易，而不必信任任何单一实体。我们可以将其归结为完全验证任何一个事务所必需的几个核心操作。

1.  验证所有块标题，并找到块的最长工作证明分支。验证块头建立了真实的规范来源，但是它不验证块内的**的一致性；据我们所知，如果我们不进一步观察，这可能是自相矛盾的胡言乱语。**
2.  验证给定的事务在“内部”是正确的。换句话说，交易从发送方到接收方被正确签名，格式良好，等等。这非常简单，不需要区块链，只需要椭圆曲线加密。这是一个已经解决的问题，但是为了完整起见，我把它包含在这里。
3.  验证一个事务在应该发生的时候“发生了”。这可以被重新表述为确认事务是给定块的成员。
4.  验证事务没有在其他地方花费**，无论是在当前块中，还是在任何先前的块中。如果有人花了未用完的产出给我送比特币，我必须验证同样的未用完的产出是真正未用完的。在比特币中，我通过查看所有交易来实现这一点。通过维护国家的全局视图，我可以排除重复支出。这直接导致了可伸缩性问题。仅仅知道 1 笔交易是正确的是不够的。我必须知道，其他地方都不正确！因此，我必须检查每个块中的每个事务。**

问题#1 由比特币解决，并在[瘦比特币客户端](https://en.bitcoin.it/wiki/Thin_Client_Security#Thin_Clients)中实现。这些仅确认块标题。这些都是非常节省空间和可伸缩的。瘦客户机解决了问题 3。因为比特币块头包括交易的 Merkle 根，所以很容易证明块中交易的成员资格。问题#2 不需要区块链解决方案，并且用 20 世纪 70 年代的加密技术解决。但是瘦客户机不能解决问题 4。即使我可以证明一个有效的事务发生在一个块中，**我也不能证明它没有发生在同一个块中的其他地方**，或者在一个先前的块中，仅具有块头信息。

问题#4 是要解决的关键问题。

## 实现可扩展性

既然我已经框定了问题，让我简洁地列出一个可能的解决方案。

一种新的加密货币拥有工作证明算法和块头，就像今天的比特币一样。所有参与者自行验证块标题和 PoW 解决方案。这部分非常容易扩展。

让我们想象一下，我们的新加密货币由有限数量的不可替代令牌组成。每枚硬币都有标签和历史，而不是捆绑和重新洗牌。可能有一些方案来创建抽象在不可替换令牌之上的可替换令牌，但这与我们的讨论无关。

在每个街区，我们做不同的事情。我们添加两个数据结构。首先，我们添加一个稀疏 Merkle 树(SMT)。利用 SMT，我们证明**的会员资格**的交易。SMT 中的每一片叶子代表一个不可替换硬币的地址。这可以简单地认为是一个唯一的二进制数，表示从 Merkle 根到叶节点的左右顺序。我们创建一个语义规则。关于 ID=N 的给定不可替换令牌的任何事务必须在块中的 SMT 的叶节点 N 上发布。可以忽略不正确叶节点位置的任何事务。

SMT 的使用为我们的系统提供了一个很好的特性；对于任何给定的块和任何给定的令牌，只有一个地方可以发生消费交易。因此，我只需要在每个块的一个地方寻找；不，其他地方都有效。

用 SMT 证明成员资格是相当简单的，今天可以很容易地做到。困难的部分是证明自己不是所有其他集团的成员。

输入布隆过滤器。

每个块还具有某个长度 M 的布隆过滤器，其可以包含最多 N 个元素，并且误报率为 p。布隆过滤器的目的是验证块中是否存在事务。所以我们创建了一个新规则。为了使交易有效，我们采取以下步骤:

1.  签署从发送者 A 向接收者 b 发送令牌 T 的交易
2.  将 leaf_node_position=T 的事务 H 的散列提交给矿工。
3.  挖掘器将散列(H)包括在 SMT 中的叶节点位置 t 处的 block=Q 处。块中列出了每个叶节点。
4.  发送者查看块 Q 中的 SMT，并计算从他们的事务散列到 Merkle 根的 Merkle 路径。他们确认这是正确构建的。然后，发送方**丢弃**该块的 SMT 数据，仅保留报头数据(仅包括 SMT 根)。
5.  在块 Q+1，发送者向矿工提交第二个项目。它们产生以下级联项目的确定性签名:事务散列、token_id、来自块 q 的 Merkle 根。该签名被散列并被提交给挖掘器以包含在布隆过滤器中。
6.  发送者现在有了交易证明。来自块 Q 的 SMT Merkle 路径和来自块 Q+1 的 Bloom 滤波器。这些被转发给令牌接收者以进行离线验证，以及底层交易本身。发送方还创建确定性签名，因为它们**对于所有先前的块< Q+1 将已经存在**，并将这些签名转发给接收方。
7.  令牌接收器验证所有块报头。然后他们验证交易的内部正确性。然后，它们在正确的叶节点位置 t 验证来自块 Q 的 SMT 中的事务散列的成员资格。这仅涉及验证所提供的 Merkle 路径。
8.  在块 Q+1，接收者需要确认正确的签名存在于布隆过滤器中。他们验证所提供的 Q+1 签名是正确的。然后，他们在 Q+1 验证布隆过滤器中签名的成员资格。
9.  最后，必须验证前面块中的非成员。发送者已经发送了块< Q+1 中所有布隆过滤器的所有先前块<q the="" receiver="" verifies="" these="" signatures.="" then="" he="" that="" they="" are="" class="it hv">而非成员的每个追溯数字签名。</q>

由于 Bloom Filter 中 Q+1 块处的签名的成员资格是事务有效所必需的，因此它在前面的块中不存在意味着它从未被花费！我相信这巧妙地避开了非会员问题#4 **而不需要**维护所有交易的全局视图。

## 问题和答案

问:如果矿工没有如实公布正确的 SMT 怎么办？

答:事务发送者只需要在正确的叶节点验证他们自己的 Merkle 路径。如果剩下的是胡言乱语也没关系。任何人都无法证实。

如果发送方提交了一个事务，但它没有包含在 SMT 中，或者 SMT 构造出现了任何问题，则不会丢失任何东西，发送方可以稍后再试。这就是为什么 SMT 构造和布隆过滤器签名添加在不同的块中。前者出了问题可以忽略，后者不可以！

问:如果矿工没有如实公布正确的布隆过滤器怎么办？

答:这个比较棘手。我们必须添加约束。布隆过滤器必须具有不超过 N 个元素，其中 N 是每个块固定的某个数字。这可以通过断言填充位数不超过某个数来验证。

另一个攻击媒介是挖掘者恶意地将事务签名添加到块布隆过滤器，其中事务从未真正被花费。这将使交易**对验证者来说看起来**已花费，因此实际上是不可用的。这就是为什么我引入了确定性签名的概念，它包括在块的 Merkle 根之前的**。在不知道发件人地址的私钥的情况下，这些签名是无法伪造的，因为在发布时，发件人地址的私钥是未知的。通过包含对前面 Merkle 根的引用，它们仅对引用已知 SMT Merkle 路径证明的块有效，并且不能在 Merkle 路径不适用的分叉分支上使用。**

在将数字签名添加到布隆过滤器之前，不允许矿工预测数字签名的值是必要的，因为他们可能会恶意地将数字签名包含在错误的块中。这就是为什么在签名中使用一个秘密是必要的，这个秘密稍后会被披露。如果提前知道，就不行了。

此外，数字签名包括对适当 SMT 的引用，使得签名不能在 cousin 或其他块中重复使用。

问:为什么 SMT 和布隆过滤器都是必要的？

答:每一个都给了我们不同的东西。SMT 允许我们将任何数据附加到具有相关 ID 号的特定叶子下的特定块。布隆过滤器允许我们检查所有块的检查器预先知道的元素的存在和不存在。

问:这是如何实现区块链可扩展性的？

在我的建议中，木块由三块组成

*   一个短的块头，包括 SMT Merkle 根
*   长布隆过滤器
*   SMT 的所有被占用的叶子(仅哈希)

验证者只需要存储块头和布隆过滤器。SMT leaves 仅适用于**发送方。**他们使用 SMT leaves 来计算自己的 Merkle 路径，然后可能会丢弃 SMT 数据。换句话说，SMT 数据对于发送方来说只是暂时需要的，他们可能只存储该数据的一小部分。

这个公式将允许每个块有更多的事务。在 10^-9 的假阳性率下，1mB 布隆过滤器可以存储大约 200，000 个元素。块头信息非常小。SMT 数据虽然更大(64 字节乘以元素数)，但可以很快被丢弃，并且在发送者计算出它们的(各自短得多的)Merkle 路径之后，不需要任何人存储。因此，SMT 数据大小可以打折扣。

如果每个块有 200，000 个元素，那么每 1mB 块实际上有 200，000 个事务。目前，比特币每个相同大小的区块只能管理 3000 到 4000 个最大交易。因此，对于相同的保留数据量，如果我的提议正确，它提供的容量将是现在比特币的 50-70 倍。

问:布隆过滤器的误报怎么办？

答:布隆过滤器有一个假阳性概率。因此，在任何时候，未用完的交易都可能出现用完，这完全是偶然的，并且实际上毁坏了硬币。我们可以以可伸缩性为代价来控制这个速率。

如果我们使用 p 的假阳性率，我们发现:

随机硬币衰变的概率= 1-(1–p)^ n

其中 N 是块数。

在 p = 10^-9(正如我在上面的例子中使用的 200，000 个事务/块)和每个块 10 分钟的情况下，我们发现

1-(1–10**-9)**(144*365*100) = 0.00524

这意味着我们可以实现每 10 分钟 200，000 次交易，并且每 100 年随机损失 0.524%的硬币。

如果我们选择 p = 10^-12，则每 1mB 数据块有 140，000 个事务，每 100 年损失 0.000525%。

对我来说，这似乎是一个很好的权衡。

问:这不会给接收器带来大量计算负担吗？转移样张不是挺大的吗？

答:这个方案无疑将更多的负担转移到发送方和接收方，以从相对稀疏的块数据中构造和验证证明。我相信计算量是可以控制的。

问:这个数字签名的公式有多可靠？有没有其他方法？

答:这部分不是超级扎实，要复习。我没有描述确定性签名构造的细节，但是这可以用大素数上的模运算来完成。

问:提供/确认/检查 Q-1 数字签名和布隆过滤器是不是很繁琐？

是的，这部分很乏味。它也许可以改进。然而，这是客户端计算，比全球区块链数据便宜得多。

问:这经过审查了吗？

答:没有！请用建设性的反馈和批判性的审视来帮助我。有可能我错过了什么…我只是不确定是什么。

问:以前有没有想过这个问题？

我不确定。很多这样的概念已经存在:SMT，瘦客户机，bloom filters。但我不知道有这样的提法。

总之，我提出了一个新的区块链公式，它似乎比几乎所有区块链实现所采用的“全局视图”模型提供了显著改进的可伸缩性。它链接了两个关键的数据结构，SMT 和 Bloom Filters 来证明成员和非成员。它还对验证中的硬币衰减和客户端计算进行了折衷，这使得提高数据可伸缩性成为可能。本质上，繁重的工作被委托给发送方和接收方，仅利用区块链中节省空间的“锚”进行验证。

我的提议还没有被仔细审查，如果能得到评论、反馈和仔细的审查，我将不胜感激。

关注我的 [@abarisser](https://twitter.com/abarisser) 了解更多…