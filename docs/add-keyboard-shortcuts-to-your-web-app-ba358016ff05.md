# 如何在 Web 应用程序中添加键盘快捷键？

> 原文：<https://medium.com/hackernoon/add-keyboard-shortcuts-to-your-web-app-ba358016ff05>

![](img/919f9f026bc73746bb454c0382676930.png)

## 反应过来，几行代码就行了！

我想象了一个场景。你在一家名为 Adob 的大公司工作，你在一家名为 Abode 的初创公司工作，开发一款名为 PhotoStore 的照片编辑应用程序。这听起来像一个图像存储服务，但它不是！事实上，这是一个基于网络的流行桌面应用程序的替代品。

有一天，你的产品经理宣布，因为你的竞争对手有键盘快捷键，你也需要它们来使他们现有的用户更容易切换。毕竟，这不应该推迟我们的发射。你只要添加*document . addevent listener(' keydown '，回调)；*你完成了，对吗？

嗯，没那么快。为什么我们需要捷径？在我们的例子中，我们希望能够激活工具栏中的各种工具(比如画笔或选区)。但是，即使在我们简单的用例中，我们也可以合理地预期需要处理以下内容。

*   激活所选工具(状态管理)
*   突出显示选定的工具(CSS 样式)
*   仅在编辑器中执行上述所有操作(快捷方式不应在营销页面、指南等中使用。)

在我们写一行代码之前，考虑一个特性在未来会如何发展总是好的。通过以一种支持这种理论功能的方式来设计我们的解决方案，我们可以避免以后的许多痛苦，即使我们决定现在不实现它。

# 何必呢？

*“这不适用于我，我不是在做照片编辑应用，”*你想。

虽然这可能是真的，但每个应用程序的用户都会养成习惯，并采用特定的工作流程。这包括你的应用程序。为最常用的功能提供键盘快捷键可以让你的用户更快、更有效率、更快乐。

有时，你的用户不能或不想使用他们的鼠标，这使得快捷方式几乎成为你产品的一个必要部分。在这种情况下，我甚至会把它们算作整体可访问性策略的一部分。而你**在乎这个，对吗？我也是这么想的。所以让我们开始吧。**

**![](img/a9b1345a9586eb11bc5f658b6c3a20e7.png)**

**Meet your new friends, B and M.**

# **先决条件。**

**我们需要什么来传递这种愉快的体验？对于本文，我将使用“only”[React](https://reactjs.org/)和 [JSX](https://reactjs.org/docs/introducing-jsx.html) ，这样我就可以编写紧凑的代码。我只将*放在引号中，因为如果你以前从未使用过 React，那么设置 React 可能会令人生畏。***

**然而，如果你正在给你的应用程序添加快捷方式，很可能你已经使用了一些 [SPA](https://en.wikipedia.org/wiki/Single-page_application) 框架。我们需要的是 *onCreate()* 和 *onDestroy()* 生命周期方法，所以如果你的框架提供了一个等效的方法，这个指南将很容易理解。在 React 中，这些方法被称为[*componentDidMount()*](https://reactjs.org/docs/react-component.html#componentdidmount)和[*componentWillUnmount()*](https://reactjs.org/docs/react-component.html#componentwillunmount)。**

**如果您使用普通的 JavaScript，不要惊慌，您仍然可以继续使用。我们将关注概念，而不是特定的实现。但是你应该能够阅读 [ES6](http://exploringjs.com/es6/) ，因为我不关心冗长的代码生命。**

# **项目设置。**

**我设法得到了这个应用程序，并把它发布到了 [CodePen](https://codepen.io/lmenus/pen/QmwXxb) 上，这样你就可以快速开始并跟进了。(但愿，欧德不会因为泄露他们的产品而起诉我们。)**

**如你所见，我得到了他们系统的早期版本。他们还没有进行设计招聘，只有两个工具可供选择——笔刷和选择。我们还可以在页面之间切换。这很方便，因为我们想确保我们的快捷方式只在编辑器中工作。所以对于我们的需求来说，这就足够了。**

# **概念。**

**这项功能将如何工作？我们将需要创建以下内容。**

1.  ****可用快捷键。这将是我们可以调用的快捷方式列表。它们将映射到包含所有应用程序快捷方式的对象。****
2.  ****听众。**我们想确保快捷方式只在编辑器中有效。我们框架的生命周期方法在这里会很方便。**
3.  ****经手人。**处理键盘事件和实际快捷键执行的功能。**

# **实施。**

**让我们从定义应用程序快捷方式开始。这将是应用程序中可以执行的所有快捷方式的对象。目前，我们只能从工具栏中选择工具。每个快捷处理程序都是一个函数，接受一个 [KeyboardEvent](https://developer.mozilla.org/docs/Web/API/KeyboardEvent) 对象作为单个参数。它在执行其主体之前检查事件是否与触发模式匹配。**

```
const shortcuts = { toolBrush(event) { if (event.key !== ‘b’) return false; useTool(‘brush’); return true; }, toolSelect(event) { if (event.key !== ‘m’) return false; useTool(‘select’); return true; },};
```

**为了满足我们只能在某些页面上执行某些快捷方式的要求，我们将有一个当前注册的快捷方式列表。**

```
let registeredShortcuts = [];
```

**当用户按下一个键时，我们将遍历这个列表，看看这个键事件是否执行了任何快捷方式，此时我们停止迭代。如果我们循环使用*快捷键*键，将会很难将快捷键的执行限制在特定的页面上。**

```
const handleKeyDown = event => { for (let i = 0; i < registeredShortcuts.length; i += 1) { const shortcut = registeredShortcuts[i]; if (shortcuts[shortcut](event)) { event.preventDefault(); break; } }};
```

**为了开始监听按键，我们注册了一个全局监听器。**

```
document.addEventListener(‘keydown’, handleKeyDown);
```

**你现在可以在 *registeredShortcuts* 数组中添加*‘tool brush’*和*‘tool select’*来查看我们的快捷方式确实被调用了。**

**现在我们已经验证了快捷方式的工作，我们可以清除数组并编写一个合适的 *<快捷方式/ >* 组件来为我们处理快捷方式注册。我们将把工具栏按钮包装在这个组件中。**

```
<Shortcut name=”toolBrush”> <Button label=”Brush” onClick={useTool} to=”brush” /></Shortcut><Shortcut name=”toolSelect”> <Button label=”Select” onClick={useTool} to=”select” /></Shortcut>
```

**这有一系列的好处。首先，当我们稍后查看代码时，这个快捷方式影响了应用程序的哪些部分是显而易见的。通过键入*<Shortcut name = " searched _ name _ here ">*，也可以很容易地在我们的项目中搜索特定的快捷方式。**

**通过将每个快捷方式嵌入到视图的呈现方法中，可以将其生命周期长度绑定到父组件。使用组件生命周期方法注册和取消注册快捷方式使得状态管理变得轻而易举。当组件被创建时，我们注册快捷方式。相反，我们在 destroy 上取消注册相同的快捷方式。**

**我和其他人一样喜欢纯 JavaScript，但这将是一场噩梦。这是我们的组件。**

```
class Shortcut extends React.Component { componentDidMount() { if (!registeredShortcuts.includes(this.props.name)) { registeredShortcuts = [ …registeredShortcuts, this.props.name, ]; } } componentWillUnmount() { registeredShortcuts = [ …registeredShortcuts.filter(x => x !== this.props.name), ]; } render() { return this.props.children || null; }}
```

**现在我们需要改变工具栏，使其只出现在编辑器视图中。让我们也为它添加样式，并删除控制台信息。就是这样！**

# **附录。**

**很管用，对吧？我们已经成功地为我们的应用程序添加了键盘快捷键支持。我们现在准备好和我们的对手竞争了吗？完全同意。营销团队可以开始推广💩这个新的闪亮的功能。**

**但是作为一个工程团队，我们的工作还没有结束。也就是说，除非你打算明天辞职，让你的继任者在这个代码崩溃的美好一天处理它。为了简单起见，我在本文中使用了一些快捷方式。继续阅读进一步讨论。**

*   **捆绑优化**
*   **跨浏览器支持**
*   **开发工具**
*   **边缘案例**
*   **模式匹配**
*   **快捷选择**
*   **状态管理**
*   **支持多个快捷方式**
*   **测试**

## **捆绑包优化。**

**有两件事需要考虑。我们可以用一个变量代替多个相同值的字符串。在我们的构建过程中，这个变量可能会被缩小，从而从最终的包中去掉一些部分。**

**第二点是弄清楚我们是否需要发布这个功能？毕竟这些叫*键盘*快捷键是有原因的。您可能不希望将这些代码提供给没有键盘的移动用户。然而，截至 2018 年 3 月，还没有可靠的 API 来检测键盘的存在。**

## **跨浏览器支持。**

**本指南使用了一组现代的 JavaScript 特性。如果你支持旧的浏览器，你需要确保你的代码是可移植的，并且使用旧的浏览器 API 来检测事件。**

## **开发工具。**

**对于您的内部调试工具，如果出现问题，您可能想要查看当前注册了哪些快捷方式。这非常简单，你可以直接转储 *registeredShortcuts* 的内容。**

## **边缘案例。**

**假设有一天，我们在应用程序中添加了一个输入字段，允许用户搜索图层。现在，如果他们想搜索“背景”层，他们可以开始输入 *b* ，但哦，là là，画笔工具被选中。这还不是最坏的情况，我们可以切换一些窗口或对话框，但它说明了问题。**

**对于这种错误，您需要检查 *event.target* 以确保它不是可写的 DOM 节点。**

## **模式匹配。**

**是的，我们的捷径行得通。但是尝试按下 ctrl/⌘+b——画笔工具仍然被选中！这显然不是我们想要的。因此，我们需要添加一个精确的模式匹配函数，而不是简单地检查 *event.key* 。**

## **快捷选择。**

**[Sasha Maximova](https://twitter.com/sashika) 写了一篇关于为应用程序选择快捷方式的[好文章，所以我不会重复她的观点。就我个人而言，我更喜欢使用单键快捷键，并使用双组合键，因为这大大降低了与任何浏览器/操作系统命令冲突的几率。例外情况是格式化函数，如 **bold** 除了 Ctrl/⌘ + B 没有理由使用其他，因为你的用户已经习惯了。](/@sashika/j-k-or-how-to-choose-keyboard-shortcuts-for-web-applications-a7c3b7b408ee)**

## **国家管理。**

**为了使教程简短，我已经克制住不把像 [Redux](https://redux.js.org/) 这样的整个状态管理库扔进我们的教程，但是你可能想在你的应用中重复管理一个状态。我们无意中创建了一些全局变量，这些变量很容易被 Redux 之类的工具所包含。**

## **支持多种快捷方式。**

**现在，我们的函数只接受一个字符串参数，但是可能会有这样的情况，你想一次注册多个快捷方式。例如，如果您喜欢在视图顶部声明所有快捷方式。**

## **测试。**

**不要发布没有测试的代码。在现有功能的基础上开发测试和捕捉潜在的 bug 会容易得多。如果您使用 SPA 框架(我知道您会这样做)，您还会想要记录您的组件，以便很容易看到它们支持哪些参数。**

# **结论。**

**在你的应用程序中添加快捷键是一个立竿见影的效果，它可以改善你的用户体验，而不会让你付出太多的代价。仔细选择最常用的功能，让用户加快工作流程，让他们高兴。**

**感谢您的阅读。**

**感谢 [Scrimba](https://scrimba.com) 的朋友们阅读本文的草稿。请访问它们，了解学习代码的最简单方法。你可以在我的[网站](https://lmen.us)上读到更多我的信息。**