# 另一个秘密历史

> 原文：<https://medium.com/hackernoon/an-alternative-crypto-history-bba1cbf8acc0>

## 文件系统、版本控制和区块链

![](img/eb4726c3d7a0d215c896c0ad39b34a26.png)

*图片由* [*阿达什库姆穆尔*提供](https://unsplash.com/photos/zThTy8rPPsY)

这是我关于没有区块链的区块链的系列文章的第四篇，也可能是最后一篇。

我心里一直对文件系统有一个温暖的位置。

我自学了 shell 脚本，同时自动安装了 Sun 的免费磁盘镜像软件 [Disksuite](https://en.wikipedia.org/wiki/Solaris_Volume_Manager) 。我几乎不记得实际的工作，而是记得一个走廊。我踏上了学习编程的文字之旅，一次又一次地来到一个朋友的办公桌前，他很乐意向我解释我做错了什么。 [1](#fn1) 公平地说，如果文件系统在 90 年代没有那么痛苦，我就不会有今天。

当孙开始打广告的时候[终于](https://en.wikipedia.org/wiki/ZFS)成了(了！)Disksuite 和它所围绕的文件系统的继承者， [UFS](https://en.wikipedia.org/wiki/Unix_File_System) ，它的大部分功能看起来显然很好——让计算机管理磁盘，不要求人们预先知道文件系统应该有多大，当服务器崩溃时不要悲惨地失败，诸如此类的小事。但是这个[数据完整性的东西](https://blogs.oracle.com/bonwick/zfs-end-to-end-data-integrity)是什么呢？我不好意思说，我花了一段时间才意识到我需要它——谁真的关心你的文件系统是否擅长存储数据，amirite？—甚至需要更长的时间来理解它是如何工作的。

为了解释它，我要教你密码学。就一点点。如果您已经了解了这一部分，欢迎您直接跳过，但是我希望大多数人可以使用一点，啊，复习一下。密码学指南的第一步通常是:“获得麻省理工学院的数学硕士学位。”我希望能做得更好一点。密码学实际上只是数学的一种形式，虽然我们不能理解所有的细节(我当然不理解)，但我们至少可以理解“算法在这里发生”的流程图。

密码术最出名的是它的隐私效用:你用它来确保只有你能阅读你的文件和聊天信息。一旦我们需要在我们所有不同的设备上阅读它们，事情就变得更加复杂，但是大部分在概念上是非常相似的。更有用的是确保你和我都能阅读一些文本，但其他人不能。它更复杂，但本质上是第一次使用的扩展。

隐私不是加密的唯一用例。它对于有效的验证也很有用。也就是说，它可以用来查看您今天拥有的文件是否与昨天拥有的文件相同。我给你发了一份文件，你觉得看起来不对；我们如何确保它不会在传输过程中被改变？

显然，一种方法是再次发送。这不是一个很好的解决方案，因为如果你第一次不信任它，你为什么要第二次信任它呢？如果带宽很贵，这也可能是个坏主意。您通常希望验证机制比原始文件占用更少的空间，比直接比较两个文件占用更少的 CPU 资源。

密码学正好提供了这样一种能力，通常称为“[哈希函数](https://en.wikipedia.org/wiki/Cryptographic_hash_function)”。这是一种算法，可以将一个大的文本文件转换成一个更短的字符串。如果您想确保文件没有以某种方式改变，只需再次运行它并比较输出。短字符串比长文档更容易比较，你甚至可以通过电话把它们读给别人听，这样他们就可以在他们那端检查文件。这些算法通常产生固定长度的字符串，而不管输入是什么——这使得它们对于长期存储和比较是有效的，并且对于任何大小的文件都是安全的。下面是我的文件中的一个哈希示例:

> 03 f 39 F4 bfad 04 f 6 F2 cfe 09 ced 161 ab 740094905 c

如你所见，这只是一长串的胡言乱语。它不仅对比较有用，本身也没有意义。

这些算法的关键在于，给定一个唯一的输入，它们总是提供一个唯一的输出。如果你和我都有一个散列到给定字符串的文件，那么我们可以确信我们有完全相同的文件。当然，这不可能是真的:我们可以设计一个只有 256 个可能输出的散列函数，而显然有超过 256 个可能输入。当两个文件散列到同一个输出时，这会产生很多所谓的冲突，而且，啊，不是很有用。

所有现代的哈希函数都非常长。理论上有可能发生碰撞，但实际上不可能。你需要执行这个函数两次⁸。3.4 后面有 38 个零。所以，数学上是可能的，但是你可以预期在最安全的散列函数被破坏之前太阳会吞噬地球。我是说，你不能。到那时你已经走了。但是你的文件仍然是安全的。

既然你至少和大多数比特币持有者一样是密码学专家，为什么这些还重要呢？

我们在讨论数据完整性。

你猜对了，ZFS 使用这些散列函数来提供它。它不仅仅是验证单个文件。一个叫做 [Merkle 树](https://en.wikipedia.org/wiki/Merkle_tree)的密码天才是关键。这些不仅仅是散列磁盘上的内容以便以后验证；他们构建了一个散列树，其中叶节点由树中它们上面的节点散列，它们本身由根节点散列。如果这个系统的任何部分被破坏——因为磁盘坏了，或者有人以其他方式改变了内容——很容易检测到。不仅仅是个体哈希会不同；请记住，每个父节点都会对其所有子节点进行哈希运算，所以现在父节点是错误的。它父母也是错的。

如果内容被任何不同时更新 Merkle 树的机制改变，那么很容易通过重新散列所有内容并将结果与存储的树进行比较来检测。

这就是 ZFS 验证数据完整性的方式。它可以将一个块写入磁盘，然后提取该块，并确保它仍然与哈希匹配。当它写入一个块时，它会更新并行树，当您稍后请求该块时，它可以告诉您该块是否仍然正确。如果不是，它会抛出一个错误，而不是返回给你。

当我第一次了解到这一点时，这似乎有点过头了，但随着时间的推移，我记起了数据损坏的方式有多种。最明显的一个是有人出于邪恶的原因更改了它，但更常见的是你在写作或阅读过程中的某个地方失败了。旧的旋转磁盘容易出错，新的固态硬盘最终会降级。不过，真正困扰你的是读写的复杂性:有多层缓存、驱动程序和连接，其中任何一层都可能导致损坏。

这是第一次在正常的生产系统上，您至少可以检测到这些问题中的任何一个。太可惜了[没人用过](https://news.ycombinator.com/item?id=11909606)。 [3](#fn3)

我知道，我知道，你是来听关于如何不使用区块链就能获得区块链的全部魅力的，相反，我给你上了两个你根本不关心的课程，密码学和文件系统。别担心。从这里开始会变得更糟。

在我了解并很快忘记了 ZFS 之后很久(毕竟，我并没有使用它)，我采用了 g it。这是一个版本控制系统，用于存储和管理源代码。每个极客都知道它，但世界上大多数人只是最近才知道它，当时微软以 75 亿美元收购了 Github。我是早期采用者，在 2008 年将 Puppet 换成 Git。最终我甚至知道了它是如何工作的。我既兴奋又有点害怕，因为我在 Puppet 中复制了让 Git 工作的一个关键特性:一个存储文件的系统，允许通过文件的内容(或者更确切地说，是内容的散列)来查找它们。通常你通过名字存储文件，但是如果很多人(或者，在 Puppet 的情况下，计算机)存储同一个文件，他们可能不把它叫做同一个东西，所以 Git 和 Puppet 通过它们的散列来存储它们。这确保了我们不会备份一个文件的多个副本，节省了大量空间，并使检查文件中的更改变得容易。

对于 Puppet，我们只是用它来备份我们更改过的文件，以防人们后来想要恢复。

Git 做的远不止这些。

像 ZFS 一样，它为整个文件存储库构建了一个 Merkle 树，有一个相似的目标:了解哪些文件发生了更改以及如何更改的。毕竟，git 是用来跟踪和共享对文件集合的更改的。共享是一个重要的组成部分；您可以轻松地将整个 git 存储库复制到另一台计算机或另一个人，重要的是他们能够确认他们有一个忠实的副本。

Git 将散列树存储在所有文件旁边。在任何时候，您都可以使用该树来验证树中的每个文件。如果有变化(这几乎是版本控制系统的全部要点)，它可以自动存储新文件并更新相关的树。

就像 ZFS 一样，这里的一个关键特性是 Merkle 树允许我们验证存储的每个文件。我们可以遍历文件树，将每个文件与它的散列进行比较，然后将文件列表与它自己的散列进行比较，一直向上。任何差异都很容易被发现。

这是我最喜欢的一种小聪明:它实现简单，却让 Git 更加灵活和有用。它拥有其他版本控制系统所没有的能力，因为它依赖于这种基本的存储和验证机制。

好的。现在我们进入正题。

再说一次，我[实际上对区块链](https://lukekanies.com/blockchain-without-blockchain/)不感兴趣。我感兴趣的是把它拆开，把有用的部分投入工作，同时避免整个[无政府资本主义](https://news.bitcoin.com/love-it-or-hate-it-anarcho-capitalist-luminaries-weigh-in-on-bitcoin/)的一面。

人们很容易将区块链视为一场突如其来的革命，一场可能性的巨大变化。从这个角度来看，很难从整体中分离出部分。如果你看到的是全局，很容易忽略每个单独的组件都有自己的历史，自己的价值。

对我和这个行业来说，区块链是渐进的。这不是一个巨大的飞跃。这是一个故事的一部分，一个序列，最有趣的方面——Merkle 树——在数学中已经有几十年的历史，现在甚至在流行用法中也有几十年的历史了。《区块链》中吹捧的大多数有趣的功能都直接来自它们。不变性([不是](https://en.m.wikipedia.org/wiki/Fork_(blockchain)))和不可信系统直接派生。

了解那段历史是值得的，看看哪些阶段和步骤适用于你遇到的问题。目前的加密货币技术栈是为了解决我认为不存在的问题而构建的。当然它们不是我的问题。

然而，与整个区块链不同的是，单个的技术部件已经在生产中使用了多年，甚至几十年。专注于当前趋势会让你看不到历史所展示的机会。我认为你更有可能在那里找到广泛适用的解决方案，而不是试图取代货币。

因为我是从文件系统和版本控制的世界来到这里的，所以如果你考虑货币或交换，我会看到与你不同的好处。或者聊天信息。这并不能说明我是对是错，但至少这意味着我们将着手解决不同的问题。

我想大多数人会觉得这很无聊。太好了。它会给我更多的时间去创造一些东西。

1.  我最清晰的记忆是[了解到](https://hackernoon.com/tagged/learning)当然“echo”命令会重置退出代码变量。这是一个重要的早期教训，说明了您自己的调试如何能够极大地改变程序的行为。 [↩](#ffn1)
2.  当人们谈论试图禁止密码学是徒劳的时候，他们的意思是:[你不能禁止数学](https://derekbruff.org/blogs/fywscrypto/2012/10/08/illegal-cryptography-is-illegal-mathematics/)。 [↩](#ffn2)
3.  是的，我知道有些人使用并喜欢 ZFS。但从未达到应有的程度。 [↩](#ffn3)
4.  由于某种原因，导致我们的一个重要社区成员放弃了 Puppet 以示抗议。 [↩](#ffn4)

*原载于* [*卢克·卡尼斯著*](http://lukekanies.com/an-alternative-crypto-history/) *。*