# 生产的异步/等待要素:循环、控制流和限制

> 原文：<https://medium.com/hackernoon/async-await-essentials-for-production-loops-control-flows-limits-23eb40f171bd>

![](img/82103023509c4ffacac46bb35f42461e.png)

自从 async/await 在 ES8 中正式出现以来，它已经成为 JavaScript 未来的核心。每天都有新的 NPM 包被转换成支持承诺，然后支持全新但相对较旧的语法的承诺(有人是 C#吗？)，现在你甚至可以在 Node.js 的 core 中找到`util.promisify`，以方便回调到承诺的转换。

sync/await 是 Node 初期人人都想要的“银弹”,但今天我们认为它不仅是 Node 的未来，也是 JavaScript 的未来。然而，我不相信有足够的资源去详细介绍这个美妙的新功能。在本文中，我们将这样做，探索日常使用案例和技巧，这可能有助于您在生产中摆脱[曹兰/异步](https://github.com/caolan/async)的依赖。

# 基础知识

在我们开始并行运行和限制循环中的项目之前，让我们回到基础。async await 的一个常见模式是简单地等待一个承诺，获取它的值并继续函数，让我们假设我们想要获取一个用户并基于用户对象获取特定的提要，这可以通过用 async 标记我们的 *getUser* 函数并在每个承诺返回函数调用之前使用 **await 来轻松完成:**

一个简单的用例，适用于任何基于承诺的函数/库，但是如果我们想使用有承诺的好的旧回调怎么办？如果你以前使用过 [petkaantonov/bluebird](https://github.com/petkaantonov/bluebird) ，也许你会熟悉 promisify 方法，幸运的是，如果你使用的是 Node 8.0 和更高版本，你可以节省几分钟的时间，因为你不需要安装这个模块，而是使用一个类似的功能，这个功能在 Node 的核心下可用，作为将错误优先回调转换为承诺的`Util#promisify`:

请注意，从 v9.4.0 开始，使用`Util#promisify` [返回多个参数只对 Node 内部的](https://github.com/nodejs/node/blob/c84582cbb6362fa8b2eb2d3bc153617fef2982d1/lib/internal/util.js#L276)可用，如果您在 Node.js 环境之外，您可以退回到前面提到的蓝鸟的`Promise#promisify`。

# 错误处理

* [你不应该忘记的一个事实是](https://mathiasbynens.be/notes/async-stack-traces)与一些流传的误解不同，async/await 不仅仅是承诺上的语法糖，它还带有承诺的属性，可以极大地简化调试。它在调试和错误处理能力方面的一个最大优势就是它强大的 try/catch 块。在同一代码块中捕获同步错误和异步错误从未如此简单。

为了证明这一点，让我们写一个承诺，在任何时候都抛出大约 100 毫秒:

我们可以使用传统的 try/catch 块在异步函数中捕获来自这个承诺的错误，尽管下面的行将抛出一个永远不会到达的同步错误:

就像在承诺中捕捉一样，您可以捕捉流程中发生的错误:

# 控制流

无论您是并行运行任务，调度循环或创建级联结构或管道 async/await 都可以通过高效和可读的控制流简化您的流程在代码中的转换。让我们来看看一些常见的模式:

## 1.并行执行

使用 async/await 进行并行执行没有特定的语法，但是我们可以针对承诺数组(或任何可迭代的)使用`Promise#all`来获得预期的结果:

`Promise#all`将一个承诺列表组合成一个承诺，当所有承诺都被解析时，该承诺将返回数组中由这些承诺解析的所有值。这是并行发生的，除了这个简单而优雅的函数之外，我们不需要任何其他的技巧。

## 2.超时设定

也许 async/await 最少被歌颂的英雄是承诺超时。它是有效和必要的，尤其是在循环环境中使用时(参见下面的**延迟循环**)，我们可以将传统的定时器(`setTimeout`、`setImmediate`)包装在如下承诺中:

然后，我们可以通过在两个函数之间创建一个异步暂停(非进程阻塞)来实施这些函数，而不管它们是同步的还是异步的:

通过这种方式，我们永远不必离开函数的上下文，如果使用得当，这可以产生更优雅的代码。

# 环

使用 async/await，控制流非常简单，但我个人最喜欢的 async/await 实践是*循环*，一个简单的 async 循环可以用多种方式表示，当然我们将继续使用并行执行。

## **1。串联回路**

一个通过给定数量的项目执行多个异步操作的循环，在下面的示例中，在每一步都停止循环，以从数据库获取一些数据并记录结果，然后继续下一个项目，一个接一个，从而创建一个串联循环:

## 2.延迟回路

我们可以在循环中利用超时的概念，例如，如果我们想要创建一个方法，在总共 10 秒的时间内每秒钟向数组添加一个随机数，我们可以使用带有计数器的`setTimeout`或`setImmediate`或等待我们之前实现的`timeoutPromise`的 for 循环:

我们甚至可以用 while 循环来实现条件 `setInterval`:

## 3.并行循环

如果它是并行运行的，就并行化。可以通过将一个承诺推入一个数组来创建并行循环，该数组稍后将解析为一个值，因此所有的承诺在完全相同的时间开始，并且可以花费它们自己的时间来完成，最终结果将由`Promise#all`自动排序:

这可以用`Array#map`更好地表示，通过将项目数组映射到承诺数组并等待值，这有助于我们在现实世界的用例中实现更多的功能:

# 承诺竞赛和限制

另一个很少探讨的话题是设置限制来控制与 async/await 并行执行的任务总数。如果你是[曹兰/异步](https://github.com/caolan/async)的狂热用户，你很可能会使用`Async#parallelLimit`或`Async#eachLimit`，但不要担心，设置限制是可能的。我们将回到我们的承诺魔法，开始一场比赛！

`Promise#race`将返回一个承诺，该承诺将在给定承诺列表中的第一项解决时解决。

## 1.基本比赛

可以通过传递一组承诺来创建一个简单的竞争，在下面的例子中，这些承诺是一个异步函数的返回，该函数在随机的时间内完成解析:

第一个承诺解决将赢得比赛，并作为我们的结果收集。

## 2.设置限制

我们几乎可以利用到目前为止我们所介绍的所有内容来构建一个函数，该函数在给定的限制下并行执行其他异步函数。现实生活中的一个例子是一次只处理 5 个网页列表的截图。

为了通过承诺和纯 async/await 实现这一点，我们需要有一种方法来存储当前正在进行的承诺，或者说还没有解决的承诺。不幸的是，这并不是 spec-grade 承诺的一部分，因此我们将使用`Set`来存储和删除正在进行的承诺:

然后我们可以利用`Set.size`来检查正在进行的承诺的总数，允许我们确定我们可以继续调度循环的多少次迭代。

接下来，我们将使用`Promise#race`作为我们控制流武器库的一部分。我们需要的是一种方法来停止循环的迭代(在本例中是`Array#map`)，直到下一个承诺被解决(我们将为此使用一个竞赛)，并检查正在进行的承诺的总数是否小于我们正在寻找的限制，如果不是，那么我们继续返回进行另一个竞赛。这很容易通过下面的 while 循环实现:

将这两者结合在一起，我们将得到`parallelLimit` *(继续运行这最后一点)*:

# 范式转变还是更好的语法？

async/await 对 JavaScript 和 Node 的影响仍有争议，但其影响是巨大的。Async/await 由多年的专业技术支持，使用近乎完美的承诺和尽善尽美的*语法* *，同时保留了 Node 普及的大部分核心异步概念。有一点是肯定的，那就是它会一直存在，我希望这篇文章能够打破僵局，让几行 async/await 代码就能实现这一目标。