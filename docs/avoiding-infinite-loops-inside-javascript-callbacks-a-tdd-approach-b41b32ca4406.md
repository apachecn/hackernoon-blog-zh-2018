# 避免 JavaScript 回调中的无限循环——一种 TDD 方法

> 原文：<https://medium.com/hackernoon/avoiding-infinite-loops-inside-javascript-callbacks-a-tdd-approach-b41b32ca4406>

![](img/06ac469a01e05fc65403426ac3b226c1.png)

# 停顿问题

所有计算机科学中最著名的问题之一是 [**停机问题**](https://en.wikipedia.org/wiki/Halting_problem) 。基本上这就是[决定](https://hackernoon.com/tagged/determining)的问题，从一个计算机程序的描述和一个输入来看，程序是结束运行还是永远继续运行。早在 1936 年，著名的 Alan Turing [就证明了](https://en.wikipedia.org/wiki/Halting_problem)不可能提供一个通用算法来解决所有可能的程序输入对的停机问题。换句话说，你不能写代码总是能够决定你的程序是否会结束，或者是否会陷入无限循环。显然我不会证明艾伦·图灵是错的，但我最近想出了一些代码，可以确保许多 [JavaScript](https://hackernoon.com/tagged/javascript) 应用程序中非常常见的特定代码不会进入无限循环。

# **JavaScript 回调**

JavaScript 语言严重依赖回调来执行异步处理。在为浏览器或 NodeJS 等环境编写 JavaScript 代码时，这是一种非常常见的模式。JavaScript 回调通常作为函数实现，作为参数传递给其他函数，引发一些异步操作。当操作完成时，回调函数被调用，通常指示成功或失败。这是可能的，因为在 JavaScript 中，函数是[一级公民](https://en.wikipedia.org/wiki/First-class_function)，可以像其他值一样作为参数传递给函数。

回调机制可以通过允许多个回调订阅单个事件来一般化。回调订阅函数可以接受两个值:事件的名称，以及事件发生时要调用的实际回调函数。从而允许多个外部模块将其期望的功能与当前流程挂钩，同时能够分离不同模块之间的关注点。这通常被称为经典的**事件发射器模式**或**发布-订阅**。

基本上，这种方法的经典实现是持有一个事件名+回调对的私有映射，并添加一个公共方法来订阅(如果愿意，还可以取消订阅)这些对。我们还想为订阅的回调添加一个执行方法(emit 函数),以便实际运行它们。如果我们希望从外部触发，这个方法可以是完全内部的，也可以是外部的。

显然，调用 subscribe 方法的人必须知道所支持的键或事件名称/类型，否则它们永远不会被执行。

这通常看起来像这样:

# 所以让我们回到无限循环！

我正在开发一个类似的机制，在这样做的时候，我想到了一个理论上的例子，它还没有发生，但如果发生了，可能很难跟踪；其中执行回调的 emit 函数可以不断地自称为*。*

*假设有人订阅了我的机制的回调，在他们的回调中，他们将触发另一个已知事件(来自我的已知事件名称集)，不知不觉地，那个事件也在执行事件的回调，所以回调将被再次调用*…*和再次…再次* …**

**在回调中从外部调用另一个事件的人，不一定知道事件执行触发了一组额外的回调执行，代码将进入一个无限循环，坦率地说，这是一个很难理解的循环。**

# ****来点 TDD 的乐趣吧:)****

**所以我决定用 [TDD](http://agiledata.org/essays/tdd.html) 风格来攻题！因为我对于这个所谓的 bug 没有实际的用例，而且这纯粹是理论上的，所以我认为 TDD 方法真的可以帮助我以最简单和最纯粹的方式定义这个问题。此外，我知道如果我为这种情况添加一个真正可维护且稳定的测试，它将永远不会在生产中发生。**

**因此，首先，我想编写尽可能简单和最短的测试(即使没有人会在真实的代码示例中编写这种测试)，首先模拟问题，然后找出解决问题的方法。**

**我查过了。结果是 [**最大调用栈超过了**](https://stackoverflow.com/questions/6095530/maximum-call-stack-size-exceeded-error) ，完全如我所愿。所以我手上的危险场景测试失败了，很明显它失败了。我想到了路过的场景，以及我想在那里发生什么。我意识到我根本不需要任何断言，我所关心的是测试即将结束。**

**对于所谓的 bug 的解决方案本身非常简单，我决定存储一个状态变量，该变量在回调执行时进行标记，并在回调执行结束时重置为默认值。**

**因此，如果我得到一个回调，它将再次触发额外的回调，它们将被忽略和报告。**

**我添加了我的代码，再次运行测试，它通过了。最甜蜜简单干净的 TDD，没有断言。只是普通的绿色测试:)**

**之后，我可以重构我的代码，让它变得更漂亮、更好。我需要做的就是重新运行我的测试，并确保它仍然是绿色的！**

**嗯，实际上它最好的部分是它对未来是防弹的。如果其他人修改了我的问题解决方案或删除了它，测试将再次超出最大调用堆栈，显然会失败:)**

# ****运动侧记****

**请注意，我的解决方案只有在额外的事件发射以**同步**方式完成时才有效。如果订阅的回调以一种**异步**的方式触发了其他回调的执行，你会怎么做？我会把它作为对我的读者的一个挑战，很乐意听听你们想出的任何东西:)**

**[https://upscri.be/hackernoon/](https://upscri.be/hackernoon/)**