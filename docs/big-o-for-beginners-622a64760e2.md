# 给初学者的大 O

> 原文：<https://medium.com/hackernoon/big-o-for-beginners-622a64760e2>

![](img/27345573db22db7671d4b1e3631602e3.png)

Photo by [apoorv mittal](https://unsplash.com/@aprvm?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

大 O 符号允许我们测量代码的时间和空间复杂度。

想想 for 循环的例子。你可以在一个包含 5 个条目的数组上运行它，它会运行得很快，但是如果你在一个包含 10，000 个条目的数组上运行它，那么执行时间会慢得多。参见示例:

大 O 符号允许我们计算出一个算法运行需要多长时间。这让我们了解一段代码将如何伸缩。它衡量算法效率。

**O(1)**

这就是所谓的恒定时间。每次执行的时间是一致的。想象一下，如果你是加油站服务员。给一辆车加满油只需要 25 秒，然后这个特殊的任务就被认为完成了。不管你那天加满了一辆车还是一百辆车，你都在一个持续的时间内加满了车。

所以按照我们上面的例子，我们不关心 O(1)，O(2)，等等。我们将其向下舍入到 O(1)，也就是说，我们的操作在可伸缩性方面是一条直线。它将花费同样多的时间。这是可预测的，也是非常可扩展的。参见示例:

**O(n)**

我们的循环示例是 O(n ),因为它为输入中的每个值运行。操作根据输入以线性方式增加。(n)表示输入的数量。该算法在线性时间内运行。

**O(n )**

假设我们想要记录来自一组项目的一系列配对。我们可以这样做:

一个好的经验法则是，如果你看到嵌套循环，那么你使用乘法来计算符号。所以在我们上面的例子中，我们做的是 O(n *n)变成 O(n)(n 的平方的 O)。这就是所谓的二次时间，也就是说，每当元素数量增加时，我们就以二次方的方式增加运算。

实际上，当引入更多元素时，随着运算次数的显著增加，您希望避免运行 O(n)的代码。

**算计大 O**

要计算 Big O，您可以遍历每一行代码，确定它是 O(1)，O(n)等，然后在最后返回您的计算结果。例如，它可以是 O(4 + 5n)，其中 4 表示 O(1)的四个实例，5n 表示 O(n)的五个实例。

然而，有一种更简单的方法来计算这一点，那就是遵循以下四条规则:

1.  假设最坏的情况
2.  移除常数
3.  对输入使用不同的术语
4.  放弃任何非支配者

依次分析这些问题:

1.  **假设最坏的情况**

在计算大 O 的时候，你总是想着最坏的情况。例如，如果你要遍历一个数组并寻找一个项，它可能是第一个项，也可能是最后一个项。因为我们不确定，所以在这种情况下我们必须假设 O(n)。

2.**移除常量**

这有点棘手，但请耐心等待。考虑以下代码:

我们有一个函数可以做几件事。有些是 O(1)如第 3 行，而有些是 O(n)如第 9 行。

我们可以将大 O 符号表示为 O(1 + n/2 +100 ),但这实在太具体了。我们可以删除 O(1)操作，因为根据经验，与 O(n)操作相比，它们可能不重要。如果我们在输入数组中提供一百万个条目，那么来自 O(1)的额外 100 个操作不是我们主要关心的。

那么我们就有 O(n/2)——随着 n 变得越来越大，除以 2 会产生递减效应。所以最终这个函数的大 O 符号变成了 O(n)。

3.**不同的输入术语**

如果我们对同一个数组循环两次，那么我们的大 O 在技术上是 O(2n)，但是让我们去掉常数，这样我们就剩下 O(n)了。但是现在我们需要考虑投入的不同术语。那是什么意思？

如果我们看上面的代码，我们可以看到我们现在有两个输入。一个可能只有一项，另一个可能包含一百万项。所以我们的函数不再是 O(n)，而是 O(a + b)。我们在符号中使用的 *n* 是任意的，所以我们需要在符号中反映两个输入。

在这种情况下，我们的循环不是嵌套的。如果是，那么我们的代码将是 O(n ),这将是重构的潜在目标。通常情况下，如果有嵌套循环，那么你是在乘而不是加变量。

4.**删除非主导条款**

看一下这段代码:

所以我们在顶部有一个 O(n)的循环，然后是一个 O(n)的嵌套循环。所以我们的总数是 O(n + n)。但是正如我们在规则#2 中看到的，我们想要删除常量。那么这两个术语哪个对我们更重要呢？

在这种情况下，我们去掉 O(n ),保留 O(n ),因为这更重要。这是一个占主导地位的术语，因为它对性能的影响要大得多。

**结论**

那么这有什么意义呢？

如果我们知道我们将只处理小的输入，那么大的 O 真的不太重要。但是当你写代码的时候，你应该考虑它的可伸缩性。

通过关注 Big O，你可以看到未来，你更有可能编写出可有效扩展的代码。您可以开始考虑代码的成本，并在如何编写代码方面做出明智的选择。

**资源**

[http://bigocheatsheet.com/](http://bigocheatsheet.com/)

[](https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-o-notation) [## 大 O 符号

### 免费阅读和学习以下文章:Big-O 符号

www.khanacademy.org](https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-o-notation)