# 建立一个任务系统

> 原文：<https://medium.com/hackernoon/building-a-quest-system-cf7f1d3da132>

## 或者说，如何让玩家在你的游戏里做事

![](img/b5586152fd9077adf066581cd8c10c3e.png)

在这篇文章中，我想分享我为模拟游戏构建任务/教程系统的经验。它将由一个理论和稍微更实际的部分组成，基于用 ECS(和反应系统)开发任务。事不宜迟，让我们从理论部分开始。

在游戏中，任务是玩家为了在游戏中走得更远并获得某种奖励而完成的任务。教程可以被看作是强制性的任务。一个任务可以包含一个单一任务的列表，但是为了简单起见，我想定义一下，每个任务只有一个任务。

任务通常由游戏设计师定义，并通过解锁要求、目标或完成要求和奖励来描述。在某些情况下，提供任务取消需求是有好处的。但是在我深入研究不同需求的成分之前，让我首先列出一个任务的所有可能状态:

*   **待定** —任务还不满足解锁要求
*   **解锁** —解锁要求满足，但还没有进行，可能是因为进行中的可能任务的限制
*   **进行中** —任务解锁并显示给玩家。对于 ***新的*** 任务，拥有一个子状态或者一个单独的状态可能是有用的。这标志着任务在技术上正在进行中，但是玩家还没有看到反对意见。我没有给它单独的状态，因为它是特定于用户界面的
*   **已完成** —任务正在进行中，玩家尽了一切努力来完成它。现在是领取奖励的时候了。如果没有奖励，任务可能会直接切换到下一个状态。也有任务自动完成的系统
*   **完成** —任务完成，用户领取奖励
*   **取消**——如果你想让任务消失，这个状态很重要。这非常有用，如果你引入了一个新的任务，而这个新的任务是玩家无法看到的，这个玩家的等级已经超过了一定的界限

现在是谈论不同需求的时候了。

## 解锁要求

那些主要是基于游戏状态/玩家进度。最简单的需求是 level 或者 XP，但是将探索的解锁链到一个资源或者某个交互也是很常见的。

假设你想教一个玩家做手工。当玩家积累了正确的资源，我们应该解锁一个任务，玩家需要使用这些资源来制作工艺。这同样适用于建造，升级，培训等…甚至使用一些遥远的，或只是解锁部分的用户界面可能被设计为一个任务，与解锁的要求，这个用户界面元素出现。

我发现另一个非常有用的解锁要求是完成另一个任务。只有当任务 B 和任务 C 完成时，任务 A 才会解锁。通过这种方式，我们可以控制任务的流程，将任务的顺序线性化。

## 取消要求

正如**取消的**状态描述中提到的，在玩家过于高级的情况下，避免一些基础任务是非常重要的。如果你为初学者介绍一个任务，你将会以一种高级玩家也将会满足的方式设定解锁要求。然而，你不希望高级玩家做基本的任务。

在我看来，最简单的事情就是把取消和某种 XP 联系起来，或者在完成另一个任务的时候。

## 完成要求

完成主要有两个需求类别:

*   **游戏状态基础**
*   **特别行动**

例如，我们正在建立一个农业游戏，我们有一个基于苹果的任务。在基于**游戏状态的**类别中，我们定义当玩家拥有 2000 个苹果时，任务完成。如果苹果是一种可消耗的资源，玩家必须停止消耗它，继续收获苹果，直到他/她拥有 2000 个苹果。

在**特别行动**类别中，我们将定义在任务移动到**“进行中”**状态后，玩家应该收获 2000 个苹果。这样我们就不会对玩家施加任何消费限制，也不在乎之前的成就。顺便说一句。具有基于**游戏状态的**完成要求的任务可以自动完成。玩家可能已经达到完成游戏所需的状态。然而，基于**的临时行动**总是需要继续工作。

## 奖励

一个没有奖励的任务/任务有点令人失望，特别是如果一个任务包含一些研磨。最简单的解决方法是给玩家 XP，但是有时候完成一个任务可以给玩家一些稀有物品，或者随机的 GATCHA。

如前所述，任务是由游戏设计者定义的，它们是引导玩家走向*理想*方向的工具。然而，一个游戏设计师能想出的东西就这么多了。如果你的任务系统是结构良好的，你可以尝试程序化地生成它们。从我的经验来看，这实际上是游戏制作团队在自动化模式之前要做的最后任务之一。

## 我如何用 ECS 实现一个任务系统

在我的文章《游戏数据和实体》中，我认为数据可以分为三类:

1.  配置
2.  游戏状态
3.  运行时数据

在任务的情况下，我们需要使用所有这三个类别。任务的定义被存储为一个配置。**进行中的**、**完成的**和**取消的**任务都存储为游戏状态。

在游戏初始化时，我们会检查配置，根据游戏状态中已经存在的任务，创建一组**【待定】**和**【进行中】**任务。我们还会检查是否可以在**取消**时存储新任务。

在运行时，我们需要一套反应系统，它将监控游戏状态的相关部分，并将**未决的**任务转换为**解锁的**，如果可能的话，转换为**进行中的**。基于**特别行动**的任务，会有存储进度的组件。

我们需要另一套反应系统，它监控游戏状态和用户互动，以完成任务，或者至少在**特别行动**的情况下改变任务进度。

当一个任务移动到 **done** 时，它将被保留在游戏状态中。

这基本上就是魔酱了。细节可能会变得有点复杂，但在我看来，ECS 是一个非常友好的架构。特别是如果你严格遵循它，把每一个球员事件变成一个组件。

*顺便说一句。为程序生成的任务编写反应式系统并不是一门火箭科学。*