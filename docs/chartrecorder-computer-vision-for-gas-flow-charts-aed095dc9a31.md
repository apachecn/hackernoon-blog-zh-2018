# 图表记录器:气体流动图表的计算机视觉

> 原文：<https://medium.com/hackernoon/chartrecorder-computer-vision-for-gas-flow-charts-aed095dc9a31>

![](img/791ba91844c7de37bcb516a9f07e0b1b.png)

*   [图表结构](/p/aed095dc9a31#fde1)
*   [分割网格和痕迹](/p/aed095dc9a31#cf02)
*   [网格颜色检测](/p/aed095dc9a31#58bf)
*   [跟踪像素分类](/p/aed095dc9a31#2ad6)
*   [图表模板检测](/p/aed095dc9a31#417e)
*   [文本提取](/p/aed095dc9a31#be7d)
*   [文本识别](/p/aed095dc9a31#866d)
*   [模板匹配](/p/aed095dc9a31#374b)
*   [轴匹配](/p/aed095dc9a31#cdf3)
*   [笔轨迹评估](/p/aed095dc9a31#2c6f)
*   [剪切补偿](/p/aed095dc9a31#7d96)
*   [改进信封](/p/aed095dc9a31#acaa)
*   [异常值去除](/p/aed095dc9a31#11e0)
*   [笔轨迹评估](/p/aed095dc9a31#f84a)
*   [结论](/p/aed095dc9a31#4b63)

流程图广泛应用于燃气行业。他们在一张纸盘上记录气流的参数(如压力)。该数据然后用于计算通过管道的气体体积。

图表记录器包含两个或三个由传感器驱动的笔。这些笔在旋转的纸盘上绘制轨迹。磁盘每天或每周执行一次旋转，很少每月执行一次。旋转一圈后，圆盘被更换。

![](img/bd1aba66162ead36f21bbea50cfafc02.png)

目前，磁盘是手动处理的。操作员使用矢量图形编辑器将扫描的位图转换为等高线，然后转换为表格数据。这种方法非常依赖操作员的注意力和经验。出错的可能性很大。毕竟，这样的工作真的很无聊！

我们已经开发了一种自动执行这项工作的算法。给定带有扫描图表的位图，它生成图表数据的表格表示。

# 图表结构

光盘上的模板(通常为绿色)是预先绘制好的。它包含:

*   时间的径向弧线；
*   数量级别的同心圆；
*   数量(轴)的名称；
*   同心线的量值(范围)；
*   时标:小时和星期名称。

请注意，同一条同心线对于不同的轴具有不同的值。

![](img/6da9e07d0bfa2446e64e3b7e4bce8ea7.png)

# 分割网格和轨迹

# 网格颜色检测

首先要解决的任务是分离跟踪像素和属于空白区域的像素。这个空白区域包含两种主色:白色和绿色。理论上，知道了这一点，我们可以使用简单的阈值来检测这两种颜色。但实际上，这种方法会在网格和空白纸之间的边缘丢弃像素。发生这种情况是因为边界像素不是严格的白色或绿色，而是介于两者之间。

为了处理它，使用了线性模型。为了建立这样的模型，我们需要一个没有痕迹出现的区域。这样的区域是图表的外环，在图像上被命名为“时间区域”。

![](img/573c7c62f8248e81c19d2dfb993f205a.png)

我们对红-绿、绿-蓝和蓝-红对应关系取直方图，然后为每个建立线性模型。之后，我们使用三倍标准差评估每一对的剩余阈值。

![](img/fd06228d78f45e0fcbb4c95e9fe2de4f.png)

所有超过此阈值的像素都被标记为非跟踪像素。

![](img/f1e3607ea3da1799455e85b3b5f9b7c7.png)

# 跟踪像素分类

下一步是确定每个跟踪像素属于哪个跟踪。这是使用色调-饱和度空间的直方图来完成的。我们执行 h-s 斑点的聚类，然后将结果反投影到像素。

为了改善结果，我们使用右下角相邻像素具有相似颜色的像素来构建直方图。

因为我们需要像素之间的色调差异，所以所有具有相似颜色的像素应该具有相似的色调。这对于红色像素来说是不正确的，因为它们具有接近 0 和 180 的色调值。为了解决这个问题，我们滚动色调值，将色调直方图的重要部分移到中心。偏移值是色调直方图和下面所示的内核之间的卷积的最小值。背后的想法是“惩罚”大直方图值接近 0 或 180 的情况。

![](img/7d1a3fa8815ebce74e0e25c1f24ae4f3.png)

在直方图移动之后，我们找到其邻居具有相似色调的跟踪像素。这个步骤使得 h-s 直方图上的斑点边缘更清晰，因为轨迹边缘附近的像素被排除。

相似的像素用下面的方法找到:

1.  获取其右下角像素也在跟踪中的所有跟踪像素；
2.  找出色调差的 95%百分位数；
3.  保持色调差低于此水平的配对。

然后，对每个相邻对取平均色调和饱和度值。获得的一组色调和饱和度值用于建立“过滤的”色调-饱和度直方图。该直方图包含较少的由“边缘”像素产生的噪声。

之后，通过中值对直方图进行阈值化，并找到连通分量。我们构建 Voronoi 图，并将其标签分配给源直方图。

为了使结果更加稳健，我们将低于 10%百分点的直方图柱标记为未标记。

![](img/2d54d671ac86dcb842cffa517b3b85b0.png)

现在我们得到这样标记的跟踪像素:

![](img/3a47c5fa82cfb50a9d31068e111a733e.png)

有一些错误标记的像素。为了修复它们，我们执行以下步骤:

1.  对于每个可能的标签，我们创建一个用这个标签标记的像素的二进制掩码；
2.  高斯模糊应用于每个遮罩；
3.  对于每个跟踪像素，我们取具有最大值的掩模的索引。

这些步骤改变离群像素的标签，用周围像素的标签替换它们:

![](img/0dab48bf88f7444ed181adfa93d999d7.png)

# 图表模板检测

为了确定图表模板，我们执行以下步骤:

1.  识别图像上显示的所有文本；
2.  检测轴名、水准点和时标；
3.  选择与获得的标签集匹配的模板。

# 文本提取

首先，我们逐字符提取所有文本，将字符图像分组到标签中并识别它们。

深入执行以下步骤:

使用 Otsu 法对图像进行二值化。所有跟踪像素都变成黑色。因此，只剩下网格和文本。

![](img/4700d2e51e043fc084fb5e6da5c618a5.png)

找到连接的组件。

![](img/377527cd48b850bcdcd269774dac686f.png)

使用面积和密度(面积和边界框面积之间的比率)阈值来检测字符，然后将其分组到文本实例。

![](img/b0be8cf18599bb73800825d186472b7a.png)

以下是典型图表中所有文本实例的图表:

![](img/aedc1338b36c00226f7c1e884efef95c.png)

# 文本识别

每个文本实例都旋转到水平位置，并传递给 Tesseract。

首先，根据文本实例几何图形应用遮罩。

![](img/7c4b2d90eb63491ff7de81e9f359881f.png)![](img/cdb5bdf3f84a3642a46b0ab89c5fc0c5.png)![](img/1bbb7df7f66017a58d785686d2cab1a4.png)

然后我们将图像旋转到水平位置。

![](img/2ef60907b957c61141bdfdea4725fd56.png)

为了去除文本附近多余的斑点，我们在中间画一条线，然后使用洪水填充来去除多余的部分。

![](img/666b883f4c981d5c525b2c347c875ce5.png)

然后，我们恢复中间的行，反转图像并将其传递给 Tesseract。

![](img/0d4aedf140b99305d87af469d4289d67.png)

# 模板匹配

识别所有文本后，我们找到一个最匹配的图表模板。

首先，我们定义一个所有已知图表模板的列表。每个模板都由以下内容描述:

*   它包含的小时数(一天 24 小时，一周 168 小时，等等。);
*   出现在外环上的文本标记；
*   轴的列表；每个轴包含:

a.文本标签；

b.图表上显示的值；

c.可能的钢笔颜色。

为了找到给定图像上使用的模板，我们以下面的方式检查轴名称和范围标签的匹配:

1.  按最近的(按角度)坐标轴名称标签对图像上找到的所有范围标签进行分组；
2.  循环移位组，以处理与不同起始组的组合。这使我们能够处理非周期性轴集，如 ABCABCAB。对于每个班次:

a.为每个组形成字符串“<axis_name><range_label_1><range_label_2>……”；</range_label_2></range_label_1></axis_name>

b.为候选模板中的每个轴形成相似的字符串；

c.计算每对组轴的字符串相似度；

d.通过所有对获得平均相似性；

3.所得的匹配质量是所有偏移值中的最大值；

4.取质量最好的模板。

在检测到模板之后，通过以下步骤找到其在图像上的旋转角度:

1.  取图像外环中找到的所有标签；
2.  从检测到的模板中取出相同的标签；
3.  对于每个找到的标签、期望的标签和旋转角度，找到标签到标签的匹配质量，作为字符串匹配率和期望的标签和找到的标签之间的负角距离的乘积，旋转给定的角度。否定使积的第二部分在角距趋于零时增加；
4.  对于每一个找到的标签和旋转角度，得到最匹配的期望标签；
5.  找出匹配质量总和最大的旋转角度。

# 轴匹配

在模板匹配之后，我们需要找到轨迹到轴的对应关系。这是通过配色来实现的。对于发现的每个痕迹，取一个平均颜色。然后，对于每个可能的对(轨迹，轴),我们在 RGB 空间中找到平均轨迹颜色和已知轴颜色之间的笛卡尔距离。有些轴可能有两种可能的笔颜色。在这种情况下，取最小值。

有了所有轨迹到轴对的这样的距离，我们通过简单地迭代所有可能的对应来找到最佳匹配。

![](img/be5c5d233112fba01b0bb829b71a004f.png)

# 笔轨迹评估

我们有根据轨迹分类的轨迹点。我们也知道使用了什么样的模板。这使得我们可以将每个点的图像坐标(以像素为单位)转换为时间和值(以小时和适当的单位:kPa、℃等为单位。).结果，我们得到一组点。如果我们把它们按时间顺序排列，我们的任务就完成了，对吗？

不……因为现在我们有了大量的点，这些点没有告诉我们任何关于笔的运动的信息。让我们看看时间-价值平面中的像素和相应的图表片段:

![](img/5672483e1747412f3a810c1daf02cc55.png)

很容易看出笔是如何在这段摘录的左右两端移动的，因为我们清楚地看到了这一行。但是中间部分呢？钢笔是怎么到这里的？

直观地说，我们可以说笔上下移动，每次向右移动一点。但是如何恢复这种运动呢？

为了解决这一任务，需要执行以下步骤。

# 剪切补偿

首先，我们去除内点。仅保留边界点。这大大减少了进一步处理的点数。

![](img/1db6f935404d044ab96ffbd4eafd7988.png)

之后，我们对轨迹切变进行补偿。当笔放置不正确或没有固定在绘图头中时，会发生这种剪切。为了解决这个问题，我们迭代可能的剪切系数。对于每一个，我们找到一个最小-最大包络区域。选择具有最小结果的系数，并将其应用于跟踪点。

下图显示了剪切系数-0.01 和 0.01 的边界区域。

![](img/8aa67aa5d78cc26951ca1fa402a0d6a0.png)![](img/3d9072ae3b64a82a31938ebfdf8f7e9d.png)

以下是用最佳系数剪切的结果:

![](img/a59dca7739760f6979cbb0a00a5eb490.png)

# 改进信封

接下来，我们改进获得的最小-最大包络。最初，所有箱都是均匀分布的。有时细点“柱”出现在箱之间的边缘，产生两个箱而不是一个箱。简单地移动所有的箱子对我们没有帮助，因为如果一个“柱”对齐，我们可能会得到另一个柱。下面是两个峰值和步骤 2 的包络的示例。

![](img/5ef8d7b12fd733ae46e3b9170e4dd82c.png)

为了解决这一问题，我们通过以下步骤来改善箱子的位置:

1.  为不同的箱偏移生成 10 个包络；
2.  获取每一项的最大-最小差异；
3.  应用三项滑动平均；
4.  有了 10xN 矩阵并将其作为成本，我们使用向前-向后算法来获得最小化包络总面积的索引序列(“路径”)。

在这些步骤之后，我们得到了比初始区域更小的包络:

![](img/7cba459dd3ea846ad728fa79609edf86.png)

# 离群点去除

接下来，我们移除异常值。有时网格像素、手印或其他东西会被误标为跟踪点。例如，这里我们添加了三个离群点:

![](img/ee85fd187ddf97af597210467553dbe0.png)

应用最小-最大包络给我们一个不充分的结果:

![](img/427e581a9ebb7ec9caeae3b1e2e4b258.png)

为了解决这个问题，我们将高块分割成有限高度的垂直“块”。现在，对于每个 bin，可以存在多个块。例如，这里有三个这样的例子:

![](img/b79a6119aaa3149e7ada7c3b3c5d4770.png)

之后，我们为每个垂直块找到块的最佳索引。我们使用前后向算法，相邻组块之间的垂直距离作为代价函数。这给了我们一个覆盖内点的组块序列。

![](img/3a4f89367e4c46329c305753e89f54ae.png)

接下来，我们得到了内联器的最佳包络:

![](img/fc55744a3352289ba23a8ee314374fb2.png)

# 笔轨迹评估

完成这些后，我们准备评估笔的轨迹。我们假设笔在每个箱内线性运动，改变箱之间的运动方向。目标是最大化笔运动覆盖的容器区域。

例如，以下是每个箱的可能信封、笔路径和覆盖率:

![](img/3fff4794ff261afe5b9ca858445f9e20.png)

为了最大化覆盖区域，我们使用前向-后向算法，每个箱边十个点作为可能的状态，一个负箱覆盖作为步长的代价。以下是应用于上述示例的结果:

![](img/b0bd840a98343331ac56fceed9f1a7de.png)

现实世界的例子:

![](img/a09fd1056c50d53dcf1a84ec5dd013ed.png)

上图中的红线显示了评估后的笔轨迹。它在需要的地方跟随细线，并使用上下移动覆盖密集的点区域。

# 结论

上述算法成功地处理了从细线到密集“影线”的各种输入数据。产生的数据允许我们在没有任何人工干预的情况下计算气体流动特征，增加了整个图表处理过程的稳健性。

伊利亚·西夫科夫