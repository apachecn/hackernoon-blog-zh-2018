# Swift4 中的可编码

> 原文：<https://medium.com/hackernoon/codable-in-swift4-e24f7cc253da>

## 远离繁重的 NSCoding 和任何其他 JSON 解析

虽然这篇文章有点长，但相信我，这是值得的。

大多数情况下，当一个应用程序与外部 API 甚至有时与本地静态数据交互时，我们实际上操作的是不同的数据类型，如 JSON 或 plist，有时甚至是其他格式。

这些任务通常需要在传输或消费数据时，将数据编码为中间格式或从中间格式解码。

大多数情况下，开发人员使用 JSONSerialization 来解析 JSON，JSON 实际上将数据转换为 dictionary，您必须再次解析 dictionary 并将其转换为应用程序友好的数据模型，以便在每次需要时都能高效轻松地读取数据。同样，如果您必须使用一些 API 向外部源发送一些数据，很可能您需要再次将您的数据模型转换为字典，以便稍后将其序列化为 JSON。这显然是一项需要大量手工劳动的单调乏味的任务。

在本文中，我们将了解以下内容:

*   Swift4 中摆脱 NSCoding 和 JSONSerialization 的新功能
*   在 JSON 数据中编码和解码定制模型
*   选择特定属性进行编码/解码(跳过不必要的属性)
*   在 JSON 和模型类/结构中处理不同的键名
*   编码/解码嵌套的 JSON 数据
*   在编码和解码时合并多个嵌套层

*NSCoding* 是现有的协议，它可以使您的数据模型进出 *NSData* 以对其进行任何进一步的操作，无论是保存在 *NSUserDefaults* 中，其他源还是归档/取消归档自定义对象。

使您的类符合 *NSCoding* 协议要求您的类实现两个额外的方法 *encode(带编码器:)*和 *init(编码器 aDecoder:)* ，这再次要求您手动序列化和反序列化每个方法中您需要转换为编码/解码数据的属性。

# 1.Swift 4 中的新功能

因此，这是一种拯救，Swift 标准库现在包括新的协议:

> 简而言之，编码是将您自己的自定义类型、类或结构转换为外部数据表示类型(如 JSON 或 plist 或其他)的过程&解码是将外部数据表示类型(如 JSON 或 plist)转换为您自己的自定义类型、类或结构的过程

*   **可编码:**用于将模型编码为数据的外部表示，如 JSON 或 plist
*   **可解码:**用于将数据的外部表示解码为您的模型。
*   **可编码:**用于编码和解码。苹果将其定义为:

```
typealias Codable = Encodable & Decodable
```

在您自己的类型上采用*可编码的*使您能够将它们序列化为任何内置数据格式，以及自定义编码器和解码器提供的任何格式。

那么我可以编码和解码哪些类型呢？

如果你想编码或解码任何模型或你的自定义类型，你必须符合*编码*。少数内置类型如*字符串、Int、Double、Date* 和*数据*已经符合*可编码*。

内置类型如*数组*、*字典*、*可选*只要包含*可编码*类型也符合*可编码*。

在下面的例子中，所有属性都可以被编码或解码，因为它们要么是标准的*可编码*类型，要么包含*可编码*类型。

让我们通过对真实场景中的数据进行编码和解码来了解更多细节:

有两种编码器可以将您的数据编码成所需的格式:

1.  **PropertyListEncoder**—*将您的类型编码为 plist 格式*
2.  **JSONEncoder** — *将你的类型编码成 JSON 格式*

# 2.在 JSON 数据中编码和解码定制模型

所以，让我们从编码和解码一些真实数据开始。

考虑如下几种数据结构:

**编码:**让我们创建一个 *Car* 实例，并将其编码为 JSON

**解码:**考虑下面的 JSON，符合 *Car* 类元数据。只需用 JSON 解码器将这个 JSON 解码回 *Car* object。

# **3。选择要编码/解码的特定属性(跳过不必要的属性)**

您不太可能需要对所有的类/结构属性进行编码，或者将 JSON 的所有字段解码到您的本机模型中。在 JSON 中，Like 和 API 响应可能包含一堆值，但在您的应用程序中，您可能只需要其中的几个值。在这种情况下，您可能只需要担心您感兴趣的字段，而不是解码或解析整个 JSON。

> 可编码类型可以声明一个名为 CodingKeys 的特殊嵌套枚举，该枚举符合 CodingKey 协议。当此枚举存在时，它的事例充当对可编码类型的实例进行编码或解码时必须包括的属性的权威列表。枚举事例的名称应该与您赋予类型中相应属性的名称相匹配。如果属性在解码实例时不存在，或者某些属性不应该包含在编码表示中，则忽略 CodingKeys 枚举中的属性。

**CodingKey 枚举—** 使用 *CodingKey* 枚举时，需要遵循的规则很少。 *CodingKey* 的 RawType 为 *String* 和 *Enum* 值必须与 JSON 键名的大小写相匹配。

例子:考虑下面的辩护

**编码:**对*人物*类的对象进行编码。

**解码:**考虑下面的 JSON，符合 *Person* 类元数据。来自 JSON 的解码对象将只有填充的*姓名、年龄、性别*属性，但是“*电话*”和“*国家*”将为*空*，因为我们在*编码密钥*枚举中排除了这些编码/解码属性。

# **4。在 JSON 和模型类/结构中处理不同的键名**

正如到目前为止可能意识到的，声明*编码键*需要*枚举*值与你的类或结构中声明的属性名完全一致。

但是在现实世界中，从外部 API 接收的 JSON 格式的数据可能有完全不同的键名，这些键名可能与类中定义的属性名匹配，也可能不匹配。例如，在一些针对图书列表的 API 响应中，book *name* key 可能是' *bookName* '，但这并不意味着您也必须在您的模型中对属性使用相同的名称。如果您只想使用'*名称*'并且这个'*名称*'应该自动映射到 JSON 中定义的'*图书名称*'键，该怎么办。

嗯，你可以用一点点代码来实现它，让我们看看如何实现，考虑下面的类声明:

**编码:**让我们创建一个 *Book* 对象并编码

这个编码 json 将按照上面定义的*编码键*枚举来重命名 JSON 中的属性名。

***名称*** *属性将被重命名为* ***书名******作者*** *属性将被重命名为* ***作者******页数***

所有其他属性在 JSON 中的名称都与在 Book 类中定义的名称相同。

**解码:**考虑下面的 JSON，符合*书*类元数据。来自 JSON 的解码对象会自动将 JSON 键映射到 *Book* 类中各自的属性。

**5。编码/解码嵌套的 JSON 数据**

虽然我已经在第一个例子中介绍过了，但是让我们再来看一下如何在 JSON 数据中，甚至在您自己的类/结构中处理多层嵌套对象。让我们从下面的类声明开始，它是由 Apple 文档中的一个例子启发而来的:

任何包含*可编码*数据类型的自定义类型或集合都可以被编码和解码。在上面的例子中，我们的每个嵌套类都是*可编码的*，同样的还有*超市*。

**编码:**让我们创建一个超市并对其进行编码。

不言自明！只需检查 *encodedObjectJsonString* ，它将拥有所有级别的嵌套信息。

**解码:**考虑上例中为*encodedObjectJsonString*变量创建的 JSON，为了节省空间，我不会再放这个 JSON 了，我们只是重用同一个变量，并尝试将同一个 JSON 解码回*超市*对象。(为什么不试一试，通过添加多个*产品/货架/通道*来创建一个 JSON？)

非常管用！

# **6。编解码时合并多个嵌套层次**

所有这些例子都非常好，除非你说你不想在你的对象模型中保留和 JSON 中相同的嵌套层次，或者你不想在你的 JSON 中保留和你在类中定义的相同的嵌套层次。让我们一个一个地瞄准:

**6.A .在编码为 JSON 时移除对象级嵌套**

考虑下面符合某种 JSON 结构的类声明:

当您将它编码成 JSON 时，您将得到类似如下的内容:

但实际上你想成为这样的人:

让我们更新我们的*照片*类如下:

首先，通过指定所需层次结构中的*枚举*值，在 Photo 类中包含一个 *CodingKey* 枚举:

请注意， *CodingKeys* enum 包括 *height* 和 *width* enum 值，而不是我们到目前为止所遵循的 *Size* 。

现在，您需要在您的类中显式实现*可编码*和*可解码*协议的*编码(to:)* 和*初始化(from:)* 方法:

并且，一旦你现在通过映射 *height* 和 *width* 键到你的 *Size* struct 在你的对象模型中编码你的对象模型或者解码 JSON 数据回到你的类模型。

**6.B .解码到对象模型时移除 JSON 层嵌套**

还记得我们在第 5 点中用过的*超市*类及其相关结构吗？

那么，如果我们可以直接将 JSON 中的*产品*映射到*超市*类下，这样我的 API 仍然使用相同的 JSON 格式，即使我的应用程序将它精简为只需要的层次结构和数据，又会怎么样呢？更明确地说，我希望我的*超市*类在从同一个 JSON 解码时看起来像这样。

所以我的来自*超市*类的实际 JSON 看起来像:

但是我希望我解码的*超市*类对象看起来像下面这样，通过避免*超市- >过道- >货架- >产品*层次结构:

不幸的是，swift 还不直接支持它。但这并不意味着你能实现它。所以你能做的就是保持原来的*超市*类不变，让它用原来的层次结构解码所有数据，并创建一个新的类 *SupermarketData* ，它可以匹配上面在 *ExpectedSupermarket* 类中提到的声明，并编写 allProducts 属性的 getter 方法，它可以使用原来的*超市*类，并可以通过*过道*和*货架*返回所有的*产品*

我知道这不是一个聪明的解决方案，但你可以实现它，直到苹果公司提供内置支持。

对于本文中使用的所有场景的示例应用程序，您可以在这里使用[](https://github.com/VireshS/CodableInSwift4)**中的代码。**

**如果您有进一步的意见或问题，请随时在下面提出。**

**可以关注我上 [***中***](/@viresh.singh) 。在[***LinkedIn***](https://www.linkedin.com/in/viresh-singh-33935835/)上跟我连线。**