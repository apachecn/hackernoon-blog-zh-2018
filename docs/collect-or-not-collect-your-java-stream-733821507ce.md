# 收集还是不收集你的 Java 流？

> 原文：<https://medium.com/hackernoon/collect-or-not-collect-your-java-stream-733821507ce>

我们一直在探索一些 Java APIs，它们如何改变了我们使用这种流行语言的方式，以及如何使用这些新工具编写更好、更高性能的代码。请阅读 Java 中的[*Finally Functional Programming*](https://hackernoon.com/finally-functional-programming-in-java-ad4d388fb92e)*和[*关于并发的片段*](https://hackernoon.com/a-sad-story-about-concurrency-346990a9a3fe) 了解更多信息。*

*然而，有一个特定的 API，作为一个组织，我们广泛使用，有时与我们之前讨论过的语言的其他部分结合使用。我们将利用这篇文章来扩展我们之前的 [*文章*](https://hackernoon.com/a-sad-story-about-concurrency-346990a9a3fe) ，同时讨论 Stream API 的用法以及使用时应该注意的一些问题。*

*让我们从一些代码示例开始，这些示例将使我们对正在讨论的问题有所了解。*

*希望我们都能看到这里的问题。每次我们收集流并将其具体化为列表，然后，为了执行下一个操作，我们再次将列表转换为流，只是为了将结果具体化为列表。*

*关于流的主要观点是它们懒惰的本性，这使得它们在处理大到足以溢出内存的连续数据或数据集时非常好。*

*还有一个问题。这一条也隐含了懒惰的本性。当处理流时，如果不将其具体化，就没有实际的方法知道流的大小，这同时意味着我们实际上永远无法找到它的大小。这听起来可能令人困惑，但是让我们看一个例子。*

*如果我们试图得到它的`.size`，你的程序将永远挂起，因为这是一个无界的流。*

*如果我们试图使用一个`Collectors`来实现它，也会发生同样的情况，比如:*

*这个节目永远不会结束，因为`numbers`之流不会结束。*

*现在，假设我们可以将流`numbers`转换成有界流。*

*正如我们所看到的，即使我们知道流的具体化是可能的，收集它只是为了将它转换回流可能是非常昂贵的。*

*这些操作需要在每个`.stream`和`.collect`反复检查整个流。*

*至此，我们已经讨论了两个问题，一个是性能问题，这意味着物化和转换回流。应用程序的性能可能会受到影响，并且可能会处理无界的流，这可能会带来陷入永无止境的处理点的风险。*

*作为一个经验法则，我们不应该在处理链的最后物化流，并且物化应该只发生在我们确定我们的流在这一点上是有界的时候。*

*在一些代码审查中，我们发现了类似下面的代码片段。*

*注意我们要检查多少次整个系列。基本上，每个计算阶段至少两次。根据用户数量的大小，这些简单的例子可能会对应用程序的性能产生影响。*

*让我们看看如何能做得更好。*

*注意，现在我们所有的函数都接收并返回流。基本上，每个计算阶段都会将新的流传递到计算的下一步。如果我们仔细想想，直到最后什么都没有实现。因为最后一个迭代是先前流的组合，所以在流上只有最后一个迭代。不过有一个例外。为了分组，流必须被物化，没有别的办法。除此之外，其他所有操作都被延迟执行，直到最后一步，我们才触发这个数据集的物化过程。*

*关于性能，还有一些我们应该考虑的因素。因为我们使用流，所以我们可以处理大量的用户，而不用太担心内存消耗，因为我们可能永远不会一次处理整个数据集。当然，我们的最后一个函数`veryInterstingUser`并没有利用这一点，但是在现实世界的应用中，我们也可能在这里返回一个流，然后使用这个流而不是`List<>`。*

## *结论*

*Java 并发 API 和流 API 是非常有趣和强大的工具，我们所有使用 Java 的人都应该学习如何以负责任的方式使用它们，这样我们才能交付更好、更高性能的应用程序。可能需要一些时间来适应这些新概念，尤其是在开始使用它们的时候，但这只是一个实践和良好工程技术的问题，直到我们成为这些领域的专家。*

*享受你的 Java:)*