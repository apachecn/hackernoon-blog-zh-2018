# 清理 React 应用程序

> 原文：<https://medium.com/hackernoon/decluttering-a-react-application-d3c5f2d40f22>

## 清理和组织代码的步骤

![](img/7702a868d346fdeaed612a72b9366f31.png)

几年前，我们开始开发 React 应用程序。我们从 Flux 开始，但是当 Redux 可用时，我们转向了 Redux。随着时间的推移，需求不断发展，应用程序不断增长。我们也转向了新的表单、模态和图表框架，仅举几例。事实上，我们代码的很大一部分现在使用了 GraphQL，所以 Redux 的状态管理减少了。我们边走边学，新特性的实现通常优先于清理工作代码。

因此，清理应用程序的时机已经成熟。在本练习开始时，应用程序有 500 多个组件和数百个减少器和动作。所以，这不是一个玩具应用程序。

我们使用 [ESLint](https://eslint.org/) 所以单个文件相对干净。但是如果一个模块没有被使用或者一个导出的函数从来没有被调用过，ESLint 就没有用了。**挑战在于删除不用的代码，重组现有的代码，使代码更小、更容易理解、更易维护。**

首先，我们使用实用程序 [lxjs](https://www.npmjs.com/package/lxjs) 和商业工具 [Lattix Architect](https://lattix.com/lattix-architect) 来创建我们的应用程序的依赖关系图。对于任何文件，它允许我们看到它导入了什么以及谁导入了它。跟踪依赖链也很容易。底层数据来自 [madge](https://github.com/pahen/madge) 可以免费下载。

有了这些数据，我们开始重构应用程序。

## 删除未使用的文件

我们很快识别出不再使用的文件。当然，仅仅删除未使用的文件是不够的，我们还必须跟踪只被这些文件使用的代码。

## 组织组件

组件是我们客户代码中最大的部分。大约 70%的客户代码是组件。这是大部分工作投入的地方。我们最终将组件分成两部分:*视图*和*组件*。视图是顶层组件，通常对应于页面，而底层组件是视图使用的共享组件。特定于一个视图的组件通常保存在该视图中，但是我们并不拘泥于此。当视图之间没有交叉依赖，并且从组件到视图之间没有向后依赖时，我们知道我们有相当干净的分离。

## 清理动作和减速器

随着我们的应用程序的发展，许多动作不再被使用。由于动作由组件和缩减器使用，所以寻找未使用的动作并不简单。我们必须识别所有没有被任何组件使用的动作。这有助于我们为我们的行为和 reducers 制定强有力的命名约定。一旦删除了未使用的动作，就很容易识别和删除引用这些未使用动作的所有减速器。

## 拆除不必要的联轴器

选择器是不必要耦合的来源。虽然我们的大多数选择器位于减速器中，但也有一些位于组件中。我们只是把选择器和减速器放在一起。这也有助于将状态封装在 reducers 中，并对组件隐藏细节。有时选择器会使用其他选择器。这在异径管之间产生了耦合。我们将选择器与减速器放在一起，以避免在减速器之间产生循环耦合。

**临时助手是不想要的耦合的另一个来源。**有些帮助器最初是为了支持一个组件而创建的，然后被其他组件使用。例如，任何处理时间/日期选择的组件都必须处理时区调整。最初，这些帮助函数中有许多是时区选择组件的一部分。这些函数被移到一个单独的 helpers 目录中，供所有组件使用。

## 清理样式

我们有超过 50 个 css 文件。大多数位于一个单独的*样式*目录中，但是有些与组件放在一起。我们很容易地去掉了不用的 css 文件。我们并没有试图合理化不同组件使用的风格多样性，因为这并不是一个问题。

# 经验教训

这比看起来容易。这是一个惊喜。清理被认为是艰难和费力不讨好的，不会增加利润。然而，每当你做出改变时，技术债务就会增加一点。最初的估计是，这项工作可能需要几个月时间。事实上，这项工作的大部分是在两周内完成的。

**了解你的代码组织。**这项工作的一个有价值的副产品是，它调整了当前的团队。您通常可以通过特性或类型来组织代码[。我们在不同的层次上结合使用了这两种方法。然而，我们总是通过依赖来协调这两种方法，以确保我们不会引入](https://softwareengineering.stackexchange.com/questions/338597/folder-by-type-or-folder-by-feature)[循环依赖](https://en.wikipedia.org/wiki/Acyclic_dependencies_principle)。

**减少捆绑包的大小并不是目标。**这不是一个减少包大小的练习，尽管它确实帮助我们去掉了一些库。*图书馆的多样性本身就是一种混乱。*例如，我们的应用程序同时使用了 Redux-form 和 Formik。去掉其中的一个将有助于减少包的大小和库的混乱，但是我们把它放在了这个工作的范围之外。

# 为什么我们会堆积杂物

通常代码开始时组织得很好，但随着时间的推移会逐渐削弱。归咎于期限和业务需求很容易，但它们并不能完全解释这一普遍现象。其他原因包括:

**编程文化不强调清理。**我们通过使用正确的技术组合来解决业务问题。我们写测试。然后我们转移到 sprint 的下一个问题。在我们的开发过程中，清理是不被衡量或重视的。

**对于现在的程序员来说，并不是优先考虑的事情。随着新人的加入或新功能的加入，问题就出现了。对于当前的程序员来说，只有当应用程序增长并且他们不再理解其他人开发的部分代码库时，问题才变得明显。**

**程序员尽量减少对他们没有编写的代码的修改。即使对于专业程序员来说也是如此。将帮助函数从一个文件移动到另一个文件需要更改不熟悉的文件。删除一段代码需要理解为什么在第一种情况下创建它，并确保它确实没有被使用。所有这些都分散了人们对手头任务的注意力，妨碍了完成冲刺。**

没有代码的组织原则，没有持续清理的文化，代码腐烂是不可避免的。

# 我们取得的成就

在这个练习的最后，我们最终减少了大约 25%的代码。行动减少了一半，减少了 40%。零部件数量也下降了约 10%。

多年积累的杂物不见了。