# 迪杰斯特拉错了，我也错了

> 原文：<https://medium.com/hackernoon/dijkstra-is-wrong-and-so-am-i-f36e2fbd5ae4>

## 我后悔使用了基于 0 的数组，我错了。我来跟大家分享一下为什么。

![](img/c7a535d250c6c8f333724d798a7bdaa7.png)

程序员*应该使用索引符号*，而不是偏移量符号。偏移量表示法是一种常见的做法，通过元素在连续内存的物理分配空间中的对应位置来描述元素在数组中的位置，逻辑上从零开始。这被简称为“基于 0 的索引数组”，尽管它实际上是一个偏移量。我们应该使用 1 作为数组的开头，因为它有以下优点:

1.  自然，列表中的第一个元素基本上对应于`1`。相反，即使是 JavaScript 的官方文档也明确声明“数组的第一个元素实际上是在索引 0 处”——这很容易被忘记，尤其是对于新手来说，并可能导致错误。
2.  数学上，封闭区间在代码中被恰当地表示为`for(i = 1; i <= items.length; i++)`，因为它包含了它的端点。相反，偏移符号在技术上是一个左闭右开的区间集，用代码表示为`for(i = 0; i < items.length; i++)`。这很重要，因为代码处理整数区间，因为所有元素都有固定的大小——您不能访问元素的小数部分。整数区间是闭区间，因此决定性地证明了这一重要性。
3.  数学上，矩阵符号也是从`1`开始的。
4.  那么第`0`项应该代表什么？数组本身呢？特别是对于将`0`视为 falsey 值的语言来说，如果`0 || true`为您提供 true，那么认为`foo[0]`为您提供 foo 的根(也就是数组本身)也不无道理。
5.  列表中的最后一个元素基本上对应于列表的长度，因此允许用`items.length`轻松访问，而不是让`(items.length - 1)`算法在你的代码中无处不在。
6.  负指数与正指数对称。使得`-1`和`1`分别指最后一个和第一个元素，并且在列表中只有一个项目的情况下，它匹配相同的元素。这种便利允许简单的左右访问，这是偏移符号所不提供的。
7.  元素的不存在可以用`0`来表示，它可以方便地编码为`if( !items.indexOf('z') ) return;`。相反，人们必须决定`if( items.indexOf('z') == -1 ) return;`在哲学上是否比带有偏移符号的`if( items.indexOf('z') < 0 ) return;`更有意义，尽管忽略了等式的不对称性。

因此，我请求原谅我多年来天真、愚蠢和错误地将基于 0 的数组推给每个人。请原谅我，和我一起忏悔，现在起来反抗吧！分享、推文、HN/Reddit 等。运动了，让我们的*再做阵伟大的*！不，我不是在耍花招，**数学已经说话了**。