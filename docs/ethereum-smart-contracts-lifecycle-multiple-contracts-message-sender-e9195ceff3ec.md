# 以太坊智能合同—生命周期、多份合同和消息发送者

> 原文：<https://medium.com/hackernoon/ethereum-smart-contracts-lifecycle-multiple-contracts-message-sender-e9195ceff3ec>

![](img/0ef43d2f656a7f333713d8e404ba96b3.png)

许多人发现智能合约生命周期的更大图景不够清晰。在这篇短文中，我将尝试用一种简单的方式解释以太坊生态系统或智能合约的新手如何能够清楚地理解它。
我相信[区块链](https://hackernoon.com/tagged/blockchain)的开发者对面向对象的概念很熟悉。因此，我将以此为类比来解释以太坊智能合约的生命周期。

# 生命周期

首先，我们可以把契约看作是面向对象术语中的一个类，它是对象的模板。一个契约可以多次部署到一个网络上，每个实例都有一个不同的地址，以后可以用这个地址与该契约的特定实例进行交互。因此，契约的每一个部署都可以被看作是面向对象概念中的一个对象实例。为了进一步澄清，每个实例都是独立的，有自己的状态(持久数据)。

当将协定部署到网络时，会调用协定的构造函数，这是唯一一次调用该构造函数。所以你在构造函数中做的任何初始化，只会执行一次，而且是在部署的时候。在契约创建结束时，可以获得一个地址，该地址可用于在特定契约实例的生命周期内与其进行交互。您可以在契约中保留条款，通过调用封装了自毁的方法来销毁契约。这种终止映射到面向对象概念中对象的析构函数。

# 多重合同

如果您的解决方案需要多个协定来执行其任务，则有必要单独部署每个协定。合同 A 与合同 B 通信的唯一方式是知道合同 B 的地址。这两个合同都是网络中的一等公民，尽管它们相互依赖。如果契约 A 需要与契约 B 的不同实例进行交互，那么每当调用相关函数时，传递契约 B 的实例地址是明智的。相反，如果协定总是与协定 B 的单个实例通信，则将协定 B 的实例地址作为构造函数参数传递给协定 A 并将其保存为状态变量会更容易。

# 消息发送者

如果契约 A 中的方法 ***fooA*** ，调用契约 B 中的方法 ***fooB*** ，在 ***fooB*** 、 ***msg.sender*** 的上下文中，将契约 A 的地址作为值。如果你想识别绝对消息发起者，那么你必须在 ***fooB*** 的上下文中使用 ***tx.origin*** 。如果您从 ***fooA*** 调用 ***fooA1*** 契约 A 内的另一个方法，那么 ***msg.sender*** 仍然是发起交易的原始发送方，而不是契约 A 的地址。

# 示例项目

[multiple_contract_test](https://github.com/fidenz-chim/multiple_contract_test) 是一个示例项目，说明了上面所描述的内容。请浏览 README.md 了解更多详细信息。