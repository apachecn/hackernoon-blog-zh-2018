# 使用 Writer Monad 的事件源

> 原文：<https://medium.com/hackernoon/event-sourcing-using-writer-monad-b26a390285a>

![](img/8be8847a1dc1caf4bf3c2a62e504a180.png)

在之前的帖子中([***【A Writer Monad for F #***](https://hackernoon.com/a-monad-writer-for-f-26aa987e4a3a)***，*** [***如何登录 Apache Spark，A Functional Approach***](https://hackernoon.com/how-to-log-in-apache-spark-a-functional-approach-e48ffbbd935b))，我们讨论了使用 Writer Monad 作为聚合事件的方式的想法。然而，我们使用的是一个简单的文本记录器，与我们在应用程序中使用的任何常规记录器只有一些小的不同。

从这个角度来看 Writer monad，它似乎只是为日志聚合付出了额外的努力，实现细节可能会让这个概念的新手不知所措。

在这篇文章中，我们将把 Writer monad 作为一个事件聚合器，它可以以一种更通用的方式用于不同的用例，这表明它具有更广泛的可用性。我们还将使用 c#来展示这个概念不仅局限于所谓的纯 T21 函数式语言，而且可以在我们选择的任何环境中使用。

主要思想是使用事件源概念以及作为主要数据结构的 Writer monad 来提供一种聚合事件的方法，以支持这项工作。

# 活动采购

事件源是一种使用不可变结构记录传入系统的事件的方法，这样我们就可以跟踪影响系统状态的事件。这些事件应该可以在任何时候重放，并且连续的事件流应该集中在一个系统状态上，该状态可以通过以时序方式重放记录的事件来恢复或复制。

# 为什么是作家莫纳德？

Writer monad 呈现了与上述相同的特性，它可以记录使当前系统状态发生变化的一般事件。同时，事件被记录在不可变的结构中，而当前状态仅通过新事件的应用而改变。

# 计算器日志

让我们从一个简单的例子开始，一个计算器实现。

我们的计算器可以做一些运算，但是它使用 Writer monad 跟踪它所做的运算。这个最初的例子类似于我们在以前的文章中展示的。

注意，我们的计算器是基于一个我们称之为`Writer`的结构定义的，我们将在下面定义这个结构。主要思想是每个操作只知道如何用它所做的操作创建一个`Writer`。

书写者单子可以定义如下。

在这里，我们定义了以下操作。

*   `Bind`，通过构造函数，允许我们创建新的`Writer`。
*   `Map`允许我们改变当前状态。
*   `FlatMap`改变当前状态，同时记录状态变化如何发生。
*   `Unsafe`检索当前状态和事件日志。

注意，改变状态的唯一方法是通过`.Map`和`.FlatMap`。

使用这种结构，我们可以按以下方式使用计算器。

通过使用`.UnSafe()`，我们可以获得当前状态和事件日志。

在这个特殊的例子中，我们只使用 Writer monad 作为一个*字符串*日志，也许正因为如此，这看起来并不那么有趣。然而，这些是我们下一个例子的基础。

# 总和聚集器

这个例子展示了我们如何使用 Writer monad 来记录系统中发生的一系列整数事件，同时保存流处理器接收到的值的总和。

先定义一下我们的出处。

正如我们所见，我们将使用一个由随机整数组成的无界/无限*流*。

现在，让我们看看如何使用 Writer monad 来接收和处理这些事件。

这是一个非常清晰的事件源示例，当事件不变时，通过重放它们，我们可以获得完全相同的最终状态，在这种特定情况下，它是收到的值的总和。

# 银行账户用例

我们的最后一个例子将展示如何使用 Writer monad 来处理发送到银行帐户的事件。一个银行账户支持两个基本的操作，存钱和取钱。

现在，假设我们有一个事件生成器，它生成的事务将由我们的编写器 monad 作为流处理器来处理。

事务由类型`Extraction`和`Deposit`表示，这两个是我们将要处理的事件类型。

现在我们有了一个事务源，我们从初始化初始状态开始。

然后，我们处理一些事件，在这种情况下，我们对其中的 100 个事件感兴趣，但实际上，这可能是任何数字。

注意，对于每笔交易，我们都通过`accountState`上的`.FlatMap`对银行账户执行相应的操作。

最后，我们能够检索帐户的当前(最终)状态和已处理的事件。

有趣的是，当我们以相同的初始状态开始，然后将 Writer monad 日志上相同的事务应用到初始状态时，我们应该以相同的最终状态结束。值的状态变化是日志中记录的操作的直接结果。

# 使用纯功能方法

对于那些希望使用纯函数方法并避免变量`accountState`突变的人，我们可以在`IEnumerable<T>`中添加`.FoldLeft`方法。让我们看看怎么做。

首先，我们添加一个扩展方法，这样我们就可以在 **C#** 中做`.FoldLeft`。

那么我们只需要改变我们处理事件的方式。

注意，通过这种方式，我们已经消除了对 Writer monad 的变异，取而代之的是，我们使用`.FoldLeft`和`.FlatMap`构建新的变异。

# 结论

作者 monad 提出了一种使用不可变日志跟踪变化的函数式方法，这种日志可以在任何编程语言中使用，包括 **C#** 。

此外，`.FlatMap`的使用允许我们以一种流畅的方式链接操作，这种方式提供了一种促进不变性的声明式流控制。

有时候，写 monad 被误解了，它只与应用程序日志有关，而应用程序日志是由副作用库控制的空间。然而，Writer monad 不仅仅是一个日志记录器，它还是一个事件源，可以用来以一种简洁优雅的方式记录状态变化。

我们还展示了 **C#** 如何支持这种方法，证明了单子并不局限于*如此纯粹的*函数式语言。