# Airdrop 的演变:从普通垃圾邮件到 Merkle 树

> 原文：<https://medium.com/hackernoon/evolution-of-airdrop-from-common-spam-to-the-merkle-tree-30caa2344170>

有了一个好的算法，您可以同时解决与处理大量用户地址列表的智能合约相关的几个问题。你不能把几千个地址的列表添加到一个合同中，并允许这组地址在那个合同中做一些事情。区块链试图保存每一个字节，所以在那里保存这么多数据太昂贵了。

![](img/9fb0c32e0dec05032a1c9d447fad7c74.png)

为了解决这个问题，契约代码需要能够确定给定的地址是否在白名单中。如果验证成功，则可以执行所需的操作。提议的解决方案非常简单:合同只存储一个号码(merkle-root ),客户有义务证明该地址在白名单中。该算法由杰出的密码学家 Merkle 提出，并广泛应用于几乎所有去中心化的软件中，以确保数据集的完整性。

# Airdrop 和 ACL

一种常见的做法是发行您自己的令牌，并将其少量发送到成千上万个地址，例如，这些地址的钱包中至少有 1 ETH。这种类型的垃圾邮件是目前推广代币的一种流行方式。没有多少人喜欢有人钱包里出现不知名的代币。然而，项目需要这一点，空投订单非常受欢迎。这通常以下面的老式方式完成(基于[以太坊](https://hackernoon.com/tagged/ethereum)，但它也适用于其他使用智能合同的区块链，包括 EOS):

*   解析区块链，并根据指定的标准创建一个大的地址列表
*   创建具有足够令牌的地址，以发送到列表中的所有地址，或者将函数添加到令牌契约中，以实现为指定地址创建(铸造)所需数量的令牌的能力(当从特殊特权地址发起事务时)
*   足够的 ETH 被放置在这个地址上，以支付每次向用户发送令牌时所收取的费用
*   启动一个分发脚本，该脚本遍历地址并为每个地址创建一个事务，以将令牌转移(或铸造)到给定的地址。

这种方法包括简单地遍历一个大的地址列表，并向每个地址发送令牌。在分散式系统中，这种推送策略通常不是最好的；它很昂贵，会产生安全漏洞，而且实际上只是垃圾邮件。这些缺点可以稍微详细地描述如下:

*   费用取决于地址的数量，可能高得令人望而却步。此外，在分发时，费用可能会增加，因为交易成本会随着网络负载的增加而增加。
*   要执行分发，您需要开发一个脚本来发送事务，并包含一个密钥来访问大量令牌。
*   你需要一个算法来控制分配，如果分配被中断，它也能够恢复工作。

然而，有一个简单得多的解决方案，常见于分散式网络，将大部分计算任务委托给客户端软件。在这种情况下，访问控制基于 Merkle 树，这是一种非常方便的数据结构，它允许契约只存储一个固定大小的数字(merkleRoot ),其中包含有关该树中所有数据的信息(例如，一个巨大的收件人地址列表)。这不涉及任何魔法:客户端应用程序提供信息，证明该地址在允许的地址列表中。为此，它执行相对复杂的计算，并消除了契约查看大量地址列表的需要。如果你对加密货币感兴趣，那么你应该已经知道了 Merkle 树；如果你不知道，那么你应该了解一下，因为这种结构对于解决许多问题非常有用。

我还提到了 ACL，即访问控制列表，它指的是文件系统:这是一种以帐户和访问类型列表的形式指定对象权限的方法。我使用这个术语来说明这个算法适合于创建大型 ACL，为数百万个帐户提供对某个合同特性的访问。为此，在合同中保存一个单独的号码，以确保该帐户在列表中。

但是，让我们把重点放在包括 airdrop 在内的方案上，因为它现在在市场上非常受欢迎，并且是具有大型 ACL 的智能合约的简单而清晰的示例。

# DApp 计划

我希望您已经知道什么是智能契约(以及令牌契约)，并理解它是如何工作的。如您所知，智能合约首先部署到以太坊网络上，并接收自己的地址和余额，之后智能合约接受并处理传入的交易。

在 merkle-airdrop 方案中，令牌不是使用地址列表分发的，而是用户自己通过向合同发送交易并支付费用来“认领”他们的令牌。秘密在于，用户向交易中添加特殊数据，允许合同轻松验证他们被列入白名单，并且合同本身不必存储该列表。在这种情况下，契约是最划算的，因为它只需要一个(！)任何(！idspnonenote)地址列表的号码。)大小——这是这个伟大算法的本质。这样的契约推出也极其简单，推出后不需要任何支持；此外，这种简单性也确保了使用时的最大安全性。我们将在后面讨论这些方面。

# 智能合同

具有 merkle-airdrop 合同的方案大致如下:

1.  令牌契约被放置在网络上(或者已经存在于网络上)。
2.  为那些被允许“声明”其令牌的地址创建列表。该列表是基于区块链分析生成的，在网站上收集的，或以任何其他方式创建的。
3.  所有地址都存储在一个大文件中，该文件被上传到一个资源中，并通过某个 URL 公开。例如，我们将文件上传到 IPFS，但是您可以使用任何其他方式保存文件，以便以后可以从客户端浏览器打开它。
4.  这个文件由一个脚本处理，该脚本从文件中获取所有地址并构建一个 Merkle 树，然后得到一个称为 Merkle 根的散列。这个根是我们发布令牌的契约的主要参数。
5.  merkle-airdrop 合同在网络上公布。在这种情况下，契约存储 Merkle 根和令牌契约地址，以便它可以将此令牌传输给接收者。
6.  大量代币被转移(以通常的方式)到空投合同的余额；金额应足以在名单上的所有参与者之间进行分配。
7.  现在，airdrop 合同提供了对“merkle-proof-claim-tokens-by-merkle-proof”功能的外部访问，该功能将用户的 merkle-proof 作为用户在大型地址白名单中的证明。如果证明有效，则合同从其地址执行转移功能，并将令牌转移给用户。

# 用户

客户端浏览器中会发生以下过程。所有操作都由客户端 JavaScript 在 DApp 页面上执行:

1.  客户端在网络上某处(例如在 IPFS)公开可用的白名单中找到其地址，并确保其有资格获得令牌。
2.  客户端读取列表中的所有地址并构建 Merkle 树；然后它得到 merkle-proof，这是一组数字(散列)，其数量取决于列表的大小；但是，与列表的大小相比，它非常小；例如，对于大约 100，000 个地址，使用大约 17 个散列就足够了(merkle-proof 的大小计算如下:log2(N)，其中 N 是元素的数量)。
3.  客户端向契约发送事务以调用“merkle-proof-claim-token-by-merkle-proof”函数，并发送接收到的 merkle-proof。如果证明有效，契约只需要检查证明(使用保存的 merkle-root)并进行令牌的转移()。检查 merkle-proof 并不简单，但只需要 log2(N)次运算，比在列表中搜索容易得多。
4.  该契约存储有关交易的信息，以防止令牌被重新发行。

一般来说，merkle-proof 可以描述为“通过 merkle 树的分支从用户地址到 merkle-root 的路径”。这需要非常复杂的计算和额外的数据，我们从合同中去掉了这些，节省了区块链最昂贵的资源—存储。merkle-proof 由 log2(N)个散列组成(四舍五入到最接近的整数)。每个散列的大小对应于 merkle-root 的大小，这是我们在 airdrop 合同中保存的。因此，用户必须为 1，024 个地址的列表提供 10 个散列，但对于大约 40 亿个地址只提供 32 个散列。用于创建和呈现证据的协议是契约的基本特征，它使得存储最少量的信息以确认某些数据属于非常大的列表成为可能。而且，列表越大，你的收益也就越大。

事实上，该合同还规定了拾取未使用的令牌、更新 merkle 根以及施加时间限制的能力，例如在一定时间后禁止发行令牌。经过简单的修改，契约将能够向每个地址发放任意数量的令牌；在这种情况下，该文件不仅会存储收件人的地址，还会存储必要数量的令牌。此外，您将需要稍微修改函数来检查 merkle-proof，但是，一般的算法几乎保持不变。

# merkle-airdrop 的优缺点

让我们描述一下与传统的基于脚本的分发相比，上述方法的优点和缺点。

优势:

*   需要代币的交易不会花费太多，而这个数量是一个常数，取决于白名单的大小
*   启动的契约不需要任何支持，所有必要的操作都由客户端应用程序执行
*   这种方法允许您在区块链中以最小的存储消耗处理几乎任何大小的列表。

缺点:

*   您必须将地址列表上载到公共资源
*   客户端代码需要处理白名单中的所有地址，并执行相当耗费资源的操作。

在该算法中没有秘密，并且契约存储节省被客户端应用验证地址属于列表的密集操作抵消。这种方法清楚地展示了使用智能合约的模式与传统集中式系统之间的差异。

使用脚本分发令牌的传统方案的优势在于简单明了的工作流。此外，与 merkle-airdrop 合同的发布相比，开发人员需要付出更多的努力来运行通常的 airdrop。而且，如果操作在列表中间中断或支付交易费的资金已经耗尽，则应监控运行脚本以采取适当的措施；您还需要确保没有人能够窃取脚本用来签署事务的私钥。如果你有一个带地址的文件，你根本不需要开发者。您不必成为开发人员来部署这样的契约，通过使用公共服务就可以非常简单地完成。

Merkle-ACL 不是唯一的解决方案，从智能合约的角度来看，还有其他逻辑更简单、更有效的良好“索赔”算法。例如，当用户出示他在公共白名单中找到的“要求令牌的预签名权利”时。但从用户的角度来看，这种方式更难，因为合同所有者必须建立一个庞大的白名单，并用适当的密钥签署每一行。是的，编程中没有“免费”的特性。

# 实施功能

除了基本的智能合同之外，merkle-airdrop 的完整 DApp 还有一些实现细节。merkle-airdrop 方案将大量操作委托给用户浏览器中的代码，例如，这些代码必须在处理整个地址列表后创建 merkle 校样。地址列表应该公开存储在某个地方，对于用户来说，这个过程应该不比上传文件到服务器更困难。

因此，我们用于 Smartz.io 平台的 merkle-airdrop 构造器允许您将地址列表上传到 IPFS，并将该列表提供给客户端。此外，我们开发了特殊的 JS 小部件来处理 IPFS 的地址列表文件。在 DApp 的最终版本中，我们计划在合同中直接存储 IPFS 的信息，以便在区块链空投 100%的数据。目前，我们已经发布了一个全功能的测试版，我们正在努力提高下一步的可用性。我们还为 EOS 令牌开发了一个 merkle-airdrop 构造器，因为它有相似的接口和内部逻辑。

一般来说，增加客户端代码复杂性的趋势出现在所有最先进的解决方案中，merkle 树只是这些有趣算法中的第一个。其他方案如环签名、zkSNARKs、状态信道等。也需要复杂的浏览器端计算，所以 Smartz 准备在客户端的构造器接口中实现大型复杂的 JS 组件。我们建议你也参与到这个过程中来。

# 结论

传统的基于列表的令牌分发的主要“优点”是，这种方案允许您甚至向那些不想接收令牌的用户发送令牌。此外，还有一些该死的功能，涉及发送如此之少的令牌，以至于交易所甚至不允许与它们进行交易，用户被迫忍受他们的地址上存在这样的“剩菜”，因为他们无法摆脱它们。

空投的概念，即公司向社区分发其部分系统令牌，对于项目的生命周期当然是极其重要的。但是我们认为这种解决方案并不都是用户友好的，而且效率非常低。此外，DApps 倾向于实现“拉”而不是“推”的概念；这意味着网络用户是业务流程的发起者和监督者，所以当有人集中地将某些东西强加给成千上万的用户时，这种方法正在逐渐成为过去。

让我们总结一下 Merkle airdrop 的优点:

*   不需要额外的气体成本；
*   不需要任何支持；
*   允许处理非常大的列表；
*   占用了区块链的一点存储空间。

您已经可以尝试在 Smartz 平台上使用特定的模板部署 Merkle Airdrop 的合同。请注意，需要在合同中部署移动设备的元掩码浏览器扩展或信任钱包。对于 Solidity 技术人员来说:这个智能合约的源代码可以在 GitHub 上找到，见下面的链接。

# 参考

*   默克尔空投:要爱，不要战争【https://blog.ricmoo.com/merkle-air-drops-e6406945584d 
*   GitHub: Merkle airdrop 智能合约【https://github.com/smartzplatform/merkle-airdrop-contract 
*   Merkle Airdrop — Smartz 平台维基[https://wiki.smartz.io/en/merkle-airdrop](https://wiki.smartz.io/en/merkle-airdrop)
*   元掩码扩展[https://metamask.io/](https://metamask.io/)
*   信托——以太坊& ERC20 钱包[https://trustwalletapp.com/](https://trustwalletapp.com/)