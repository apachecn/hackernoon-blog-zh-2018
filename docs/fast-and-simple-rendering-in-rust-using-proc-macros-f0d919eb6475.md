# 使用 Proc 宏在 Rust 中快速简单地渲染

> 原文：<https://medium.com/hackernoon/fast-and-simple-rendering-in-rust-using-proc-macros-f0d919eb6475>

![](img/8214688c882719fc75c124ac5283dfdf.png)

我最近一直在做一个名为[推进器](https://github.com/trezm/thruster)的项目，需要一种开发者可以合理使用模板的方式。推进器是一个基于中间件的网络服务器，用 Rust 编写(懂了吗，th-rust-er？我正在为业余爱好者的阿波罗之夜而努力，)因此，我需要一种方法来加载 HTML 模板并以一种高性能的方式将变量插入其中。而不是在众多现有的库中翻来翻去，选择一个我不认识的人做的——更奇怪的危险！—我决定自己做。这篇文章是关于那次旅程，在 Rust 写我的第一篇`proc_macro_derive`的令人难以置信的惊险冒险。[提示印第安纳琼斯音乐](https://open.spotify.com/track/60ZYLVPmSNY9r0Uquaivvs?si=b5BbeA1tSLeIG2VNzjQhXw)。

你需要知道的第一件事是，我不是我所说的系统专家。我选择 rust 是因为我想要一种更新的基于性能的语言，但我更像是一个 web 开发人员。我已经可以通过互联网管道听到你的盐了；“我为什么要接受一个网络开发者的建议呢？他可能只是想谈谈 arrow 函数，以及他这一代人是如何发现函数式[编程](https://hackernoon.com/tagged/programming)的。”你是对的。我只是想谈谈这个，但我也正在做鳄梨吐司，我的生活教练说我应该专注于我的气，而不是谈论榆树郎。

我提到我是一名 web 开发人员的原因是，在 web 框架中，我首先要考虑的事情之一是在框架中开发有多复杂，以及框架组合和移动各个部分有多容易。有时候，我喜欢能够复制/粘贴我已经在不同项目中编写的代码，而不必重新计算将人送上月球的轨道。

你应该知道的第二件事是，Rust 是伟大的，尽管我的同事想用鞋子砸我的头，如果我看起来像是要谈论它的内存安全或速度，我对它的爱仍然比一千个太阳还要强烈。

太好了，既然忏悔室已经不碍事了，我们可以开始研究项目的实质了；`proc_macro_derive`。过程宏(以及一般的宏)是迷人的生物。许多来自其他语言的开发人员会翻着白眼，记起每次他们不得不调试一个神秘的宏，但是 Rust 有点不同。从文档中:

> …Rust 有一个[卫生宏系统](https://en.wikipedia.org/wiki/Hygienic_macro)。每个宏展开都发生在不同的“语法上下文”中，每个变量都用引入它的语法上下文来标记。

以下是我想在宏中实现的目标:

*   它应该在编译期间而不是运行时从文件中提取模板。
*   它是类型安全的，也就是说，我不会以恐慌结束！或者在运行时在我的渲染模板中出现一些奇怪的`undefined`类型的文本。
*   它很快。

不幸的是，第一点只考虑了常规的旧宏，所以我不得不开始研究过程宏。宏本质上具有额外的逻辑，可以在编译过程中引入，并实际改变代码的 AST。

过程宏是特殊的动物，所以首先，我需要声明我的代码是`Cargo.toml`文件中的一片特殊的雪花:

```
[lib]
proc-macro = true
```

我还包括了一些方便的从人类代码(oxymoron？)到一个锈 AST 又回来，`syn`和`quote`:

```
syn = "0.13.1"
quote = "0.5.1"
```

接下来，我开始编写实际宏的代码。这里要做的一个重要区别是不同类型的程序宏之间的区别。我就把这个留在这里，因为有人已经在铁锈黑魔法书中替我做了工作:[不稳定之书](https://doc.rust-lang.org/unstable-book/language-features/proc-macro.html)。

长话短说——我决定定制一个派生的程序宏！这意味着我的代码看起来像这样开始:

此时，我有了一种向结构中添加自定义实现的方法，这正是您希望使用 derive 的目的。这很好，但是我仍然希望能够从文件中加载模板。问题是，究竟如何获得要加载的模板的名称？

对我们来说幸运的是，我们处于编译器领域(比糖果领域糟糕得多)，所以我们也可以添加额外的属性。下面是添加了用于抓取模板的`TemplateName`属性的代码

是的，我知道上面有点乱。就像我的车库和我工作时的桌子一样，当我有空的时候，我会开始清理它。我在这里做的是遍历传入的 struct 上的属性，以便找到`TemplateName`属性。然后，我将基于该字符串加载一个文件的内容，并将其传递给由`quote!`生成的令牌流。

最后一步是做实际的插值，这有点乱，但相对简单。需要记住的重要一点是，除了从`quote!`传回的内容之外的所有内容都将在编译时完成，反之亦然。请注意，上面的例子实际上并不包括插值，相反，[这里有一个 GitHub](https://github.com/trezm/fuel-line/blob/master/fuel_line_derive/src/lib.rs#L49-L106) 上发布的包的源代码的链接。

你已经做到了。你已经跟随我的分散的逻辑和强迫的修辞到了纳粹的脸融化的最后场景(你不会认为我已经忘记了第一段中的印第安纳琼斯参考，是吗？)程序性宏很锈；它们是安全和卫生的，但它们不是灵丹妙药。为了开发人员的安全，以及维护您代码的人的理智，他们的权力是有限的。然而，如果有一个问题是可以在编译时决定的，那么它们就是一个非常好的工具。

你可以在这里找到代码:[https://github.com/trezm/fuel-line](https://github.com/trezm/fuel-line)和合适的货物包装:这里:[https://crates.io/crates/fuel_line](https://crates.io/crates/fuel_line)和这里:[https://crates.io/crates/fuel_line_derive](https://crates.io/crates/fuel_line_derive)。