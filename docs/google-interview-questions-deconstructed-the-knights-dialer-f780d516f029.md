# 谷歌面试问题解构:骑士拨号器

> 原文：<https://medium.com/hackernoon/google-interview-questions-deconstructed-the-knights-dialer-f780d516f029>

![](img/9fbe011f533e8b0f902eec5af4972d85.png)

*加入* [*我们的不和*](https://discord.gg/MKmwxTC) *与作者和社区一起探讨这些问题！*

这是我根据自己在谷歌担任工程师和面试官的经验，分享我对面试科技公司的候选人的建议的系列文章中的第二篇。如果你还没有，看看这个系列的[介绍](/@alexgolec/introducing-google-interview-questions-deconstructed-a012e41ea631)。

在我开始之前，声明:面试候选人是我的职业职责之一，这个博客代表了我的个人观察、我的个人轶事和我的个人观点。请不要误认为这是谷歌、Alphabet 或任何其他人或组织的官方声明。

这是我在采访生涯中使用的第一个问题，也是第一个泄露并被封杀的问题。我喜欢它，因为它击中了许多甜蜜点:

*   很容易陈述和理解。
*   它有许多解决方案，每一个都需要不同程度的算法和数据结构知识。此外，一点点的洞察力会有很大的帮助。
*   每个解决方案都可以用相对较少的几行代码实现，非常适合时间有限的环境。

如果你是一名学生或者申请技术类工作，我希望你读完这篇文章后能更好地理解面试问题。如果你是一名面试官，我想分享我的思维过程和面试风格，以便更好地通知他人和征求意见。

*注意，我将使用 Python 编写代码。我喜欢 Python，因为它易学、简洁，而且有绝对海量的标准库。候选人也喜欢它:即使我们没有语言限制，我面试的 90%的人都使用 Python。我也用 Python 3，因为拜托，现在是 2018 年了。*

# 这个问题

想象你把一个骑士棋子放在电话拨号盘上。该棋子以大写的“L”形移动:水平两步后垂直一步，或水平一步后垂直两步:

![](img/760868b0fd2cee0eea5ef81a78ce36c4.png)

Pay no attention to the poorly-redacted star and pound keys

假设你用一个骑士能跳的距离在键盘上拨号。每当骑士落在一个键上，我们拨那个键，再跳一次。起始位置算作已拨。

从一个特定的起始位置开始 N 跳，你能拨多少个不同的号码？

# 讨论

我进行的每次面试基本上都分为两个部分:首先我们找到一个算法解决方案，然后候选人用代码实现它。我说“我们”找到了解决方案，因为我不是一个沉默的旁观者:在最好的情况下，45 分钟并不是很多时间来设计和实现任何东西，更不用说在压力下了。我让候选人在讨论中带头，产生想法，解决问题的实例，等等。，但我很乐意在正确的方向上推一把。候选人越优秀，我给出的暗示就越少，但我还没有见过一个候选人完全不需要我的参与。

我应该强调这一点，因为这很重要:作为一名面试官，我不会坐视人们失败。我想写尽可能多的正面反馈，我也尽量给你机会让我写关于你的好话。暗示是我说“好吧，我会把这一点给你，但只有这样你才能继续，让我看看你在问题的其他部分得到了什么。”

也就是说，听到问题后，你的第一个行动应该是走向白板，手动解决问题的小实例。不要一头扎进代码中！解决小问题可以让你发现模式、观察到的情况和边缘情况，也有助于在头脑中形成解决方案。举个例子，假设你从 6 开始，有两跳要跳。你的序列将是…

*   6–1–8
*   6–1–6
*   6–7–2
*   6–7–6
*   6–0–4
*   6–0–6

…总共六个序列。如果你正在跟随，试着拿一支铅笔和一张纸，推导这些。这并不能很好地转化为一篇博客文章，但是相信我，当我说用手算出一个问题有一种神奇的东西，它会比只是盯着它静静地思考带来更多的见解。

综上所述，你可能已经有了一个解决方案。但是在我们到达那里之前…

# 级别 0:获得下一跳

当我开始使用这个问题时，我感到惊讶的是，候选人经常会陷入计算我们可以从给定位置跳到的键，也称为邻居。我的建议是:有疑问的时候，写一个空的占位符，问问面试官你以后能不能实现。这个问题的复杂性不在于邻居计算；我在注意你计算整数的能力。任何花费在邻居计算上的时间实际上都被浪费了。

我会接受“让我们假设有一个函数给我邻居”以及下面的存根。当然，我可能会要求您返回并稍后实现它，但前提是我们有时间。您可以简单地写一个这样的存根，然后继续:

```
def neighbors(position):
    ...
```

此外，要求使用存根并不会损失太多:如果问题的复杂性在别处，我会允许的。如果没有，我就要求你切实执行。我不介意考生没有意识到一个问题的复杂性在哪里，尤其是在早期阶段，他们可能没有完全探索这个问题。

至于这里的邻居函数，假设它从不改变，您可以简单地创建一个地图并返回适当的值:

*编辑注:我在这段代码的原始版本中犯了一个错误。以前是* `4: (3, 9, 0)` *后来我改了。很抱歉。*

# 级别 1:递归生成数字

不管怎样，继续解决问题。也许你已经注意到这个问题可以通过列举所有可能的数字并计算它们来解决。您可以使用递归来生成这些值:

这很管用，也是我在采访中看到的一个常见的出发点。但是，请注意，我们生成了这些数字，但从未真正使用过它们。这个问题问的是数字的*计数*，而不是数字本身。一旦我们数了一个数，我们就不会再去数了。作为一个通用的经验法则，我建议注意你的解决方案何时计算了它不使用的东西。通常你可以把它去掉，得到一个更好的解决方案。让我们现在做那件事。

# 第二级:数而不数

我们如何在不生成电话号码的情况下对其进行计数？这是可以做到的，但不是没有额外的洞察力。请注意，从一个给定的起始位置开始 N 次跳跃所能产生的数目等于从它的每一个邻居开始 N-1 次跳跃所能产生的跳跃数之和。数学上表述为递归关系，如下所示:

![](img/6a1b1af97bcedc784a8d43adcdc218ca.png)

当您考虑一跳会发生什么时，这一点直观上是显而易见的:6 有 3 个邻居(1、7 和 0)，在零跳中，您可以到达每个邻居的一个号码，因此您只能拨打三个号码。

你可能会问，一个人如何获得这种洞察力？如果你学过递归，在白板上做了一些探索后，这应该会变得很明显。许多练习过递归的考生会立即注意到这个问题分解成了更小的子问题，这是一个致命的漏洞。如果你在接受我的采访时，你似乎无法获得这种洞察力，我通常会给你一些提示来帮助你达到这一点，甚至包括在激励失败的情况下直接放弃。

一旦你有了这种洞察力，你就可以继续前进，再次解决这个问题。有许多实现都利用了这一事实，但是让我们从我在采访中最常看到的一个开始:朴素的递归方法:

就是这样！将此与计算邻居的函数相结合，您就产生了一个可行的解决方案！此时，你应该拍拍自己的背。如果你向下滚动，你会注意到我们还有很多内容要讲，但这一点是一个里程碑。提出任何可行的解决方案已经让你从数量惊人的候选人中脱颖而出。

下一个问题是你会经常从我这里听到的:这个解决方案的复杂性是什么？对于那些不知道的人来说，Big-O complexity(非正式地)是解决方案所需的计算量作为输入大小的函数增长的速率的一种简写。对于这个问题，输入的大小就是跳数。如果你对正确的数学定义感兴趣，你可以在这里阅读更多的。

对于这个实现，对`count_sequences()`的每个调用至少递归调用`count_sequences()`两次，因为每个键至少有两个邻居。因为我们递归的次数等于期望的跳数，并且每次调用对`count_sequences()`的调用次数至少翻倍，所以我们的运行时复杂度至少是指数级的。

这很糟糕。请求额外的一跳会使运行时间增加一倍，如果不是三倍的话。对于像 1 到 20 这样的小数字，这是可以接受的，但是当我们要求越来越多的跳数时，我们就碰壁了。例如，500 次跳跃需要等到宇宙热寂后很久才能完成。

# 第三层:记忆化

我们能做得更好吗？仅仅使用上面的数学关系，没有别的，不是真的。不过，我喜欢这个问题的一个原因是，它具有洞察力的层次，可以产生越来越有效的解决方案。为了找到下一个，让我们绘制出这个函数调用的函数。让我们考虑一下`count_sequences(6, 4)`的情况。注意为了简洁，我使用`C`作为函数名:

![](img/9d2b1f2a57f6ad144b3c182892e8e37d.png)

您可能会注意到一些奇怪的事情:`C(6, 2)`调用执行了三次，每次它都执行相同的计算，并返回相同的值。这里关键的一点是，这些函数调用会重复，每次都返回相同的值。一旦你计算了它们的结果，就没有必要重新计算了。

如果你想知道你应该如何得出这个结论，最简单的方法是通过良好的老式白板:抽象地盯着这个问题陈述是不错的，但我总是鼓励候选人在板上扔出一个样本解决方案。解决这样一个问题，并像我上面做的那样画出树，你会看到多次写`C(6, 2)`的子树，你肯定会注意到这一点。这有时足以让候选人完全绕过解决方案 1 和 2，直接跳到这个阶段。不用说，在只有 45 分钟解决问题的面试中，这是一个巨大的时间节省。

有了这种认识，我们如何解决这个问题呢？我们可以使用 memoization(不是 memo **r** ization)，这基本上意味着我们记录我们以前见过的函数调用的结果，并使用它们来代替重做工作。这样，当我们在调用图中遇到不必要重新计算整个子树的地方时，我们会立即返回已经计算过的结果。下面是一个实现:

好吧，现在运行时复杂度是多少？这很难回答。对于前面的实现，计算运行时就像计算递归函数被调用的次数一样简单，每次调用总是两到三次。这个时间计数更复杂，因为递归调用由一个条件。从表面上看，没有明显的方法来计算函数调用。

我们可以通过查看缓存来解开这个谜。每个函数调用的结果都存储在缓存中，并且只插入一次。这允许我们将问题重新定义为“缓存的大小如何随着输入的大小而增长？”假设缓存由位置和跳数决定，并且正好有十个位置，我们可以得出结论，缓存的增长与请求的跳数成正比。这符合鸽子洞原则:一旦我们在缓存中为位置和跳转计数的每个组合都有了一个条目，所有调用都将命中缓存，而不是导致新的函数调用。

线性时间！那还不错。事实上，这是值得注意的:一个简单的缓存的增加改变了算法的运行时间从指数到线性。在我古老的 MacBook Air 上，递归实现运行 20 跳需要大约 45 秒。这种实现可以在大约 50 毫秒内处理 500 次跳跃。一点也不差。

所以我们做得对吗？不完全是。这种解决方案有两个缺点，一个主要缺点和一个次要缺点。主要的缺点是它是递归的。大多数语言对调用栈的最大大小都有限制，这意味着一个实现可以支持的最大跳数总是存在的。在我的机器上，它在大约 1000 次跳跃后失败。这是一个主要的限制，而不是主要的，因为任何递归函数都可以以迭代的方式重新实现，但这仍然是一个麻烦。至于次要的限制，这实际上引导我们进入下一个解决方案…

# 级别 4:动态编程

当你从上面看递归关系时，递归记忆解决方案的次要限制是明显的:

![](img/6a1b1af97bcedc784a8d43adcdc218ca.png)

请注意，N 跳的结果仅取决于 N-1 跳的呼叫的结果。同时，高速缓存包含每(非零)跳数的条目。我称这是一个小问题，因为它实际上不会导致任何真正的问题，因为缓存只是随着跳数的增加而线性增长。要求线性空间并不是世界末日，但仍然是低效的。

怎么回事？同样，当您查看写出的解决方案和代码时，结果是清楚的。请注意，代码从最大跳数开始，直接向下递归到最小跳数:

![](img/d7abe8fc736cb625cb867d82989ae685.png)

如果您将整个函数调用图想象成一种虚拟树，您将很快看到我们正在执行深度优先遍历。这很好，它给出了一个合适的解决方案，但是它没有利用我上面指出的浅依赖属性。

是否可以执行广度优先遍历，从顶部开始，在访问了 N 跳的函数调用后，再访问 N-1 跳的函数调用？遗憾的是，没有。非零跳转的函数调用的值绝对需要来自较小跳转计数的值，所以在到达零跳转层并开始返回数字而不是额外的函数调用之前，您不会得到任何结果(注意，这里没有描述零跳转层)。

然而，你*可以*颠倒顺序:只有在你访问了具有 N-1 跳的层之后才访问具有 N 跳的层。你们中那些已经学习或正在学习离散数学的人会认识到[归纳](http://www.cs.cornell.edu/courses/cs2800/2011fa/Lectures/induction.pdf)的所有必要成分:我们知道零跳函数调用的值总是 1(基本情况)。我们还知道如何使用递归关系(归纳步骤)来组合 N-1 个跳跃值以获得 N 个跳跃值。我们可以从零跳的基本情况开始，归纳出所有大于零的值。下面是一个实现:

那么这个版本比递归的、深度优先的解决方案好在哪里呢？不是一吨，但它有一些好处。首先，它不是递归的，这意味着它可以运行非常大的值而不会崩溃。其次，它使用恒定的内存，因为它只需要两个固定大小的数组，而不是内存化解决方案中不断增长的缓存。最后，它仍然是线性时间:我可以在不到二十秒的时间内计算 200，000 次跳跃。

# 评价

所以我们结束了，对吗？差不多吧。在工作面试中设计并实现一个线性时间、恒定空间的解决方案是一个非常好的结果。我在用这个问题的时候，给了提供动态编程解决方案的考生一个优秀的评分。

你可能会问，其他解决方案呢？不幸的是，不可能给一个抽象的候选人打分。面试是乱七八糟的事情；他们可能开始得晚，人们可能会紧张，并且他们经常在会议后期才得出见解和解决方案，这使得他们几乎没有时间编写任何代码。还有一个对话正在进行:我关注候选人如何交流他们的想法，以及如何整合想法和反馈。我总是在做出雇佣或不雇佣的建议之前考虑这些因素，你不能抽象地这么做。

我会把重点放在我想说的事情上，而不是潜在的推荐。在评估算法和数据结构时，我想说类似“ *TC(候选人)探索了问题并提出了解决所有边缘情况的解决方案，并在提出其缺点时改进了解决方案。最后，他们达成了一个最佳解决方案。*“我也想能够说” *TC 为解决方案选择了合适的数据结构，并正确回答了关于他们解决方案的运行时和空间需求的 Big-O 的问题。*

在评估编码时，我的理想陈述将是“ *TC 快速而简明地将他们的想法翻译成代码。代码使用标准语言结构，易于阅读。所有的边缘情况都得到了解决，TC 遍历了他们的代码来调试它并验证它是正确的。*“对于初级职位，如果有某种测试，我会给加分，但对于更有经验的职位，我会惩罚那些至少没有列出相关测试案例的候选人。

至于进展速度，我希望能够说" *TC 推动了问题解决过程:他们开发了大部分自己的解决方案，并且能够识别和解决缺点，而无需我指出它们。TC 只需要最少的提示就能让他们朝着正确的方向前进。*”

在我的书里，我能说这些话的任何人都会得到“强聘”。但是，“聘”和“倚聘”也是正面背书。如果你在一个领域表现不佳，但在另一个领域大放异彩，那么我仍然可以给你一个积极的建议。

# 包扎

这个问题看起来令人生畏，特别是考虑到这篇文章已经很长了。然而，请记住，这篇文章比任何面试都要有目的地更全面。我没有列出我期望看到的所有东西，我只是将一个问题分解成最细微的细节，没有遗漏任何东西。

为此，这里列出了这个问题涵盖的技能和你应该养成的习惯:

*   **总是从手工解决一个小问题开始**。在这个问题中，当你手工解决一个问题时，递归关系和函数调用的重复变得更加明显。
*   **注意当你的解决方案在计算你不需要的东西的时候**，比如朴素的计数解决方案如何生成序列但实际上并不使用它们。减少不必要的计算通常可以提供更简单的解决方案，如果不是为更有效的解决方案打开大门的话。
*   **了解你的递归。**它在大多数产品代码中几乎没有用，因为它会穿透堆栈，但这是一种非常强大的算法设计策略。递归解经常可以被修改和改进:指数时间的简单解和线性时间的近似最优记忆解之间的差别是最小的。
*   **了解你的 Big-O 分析！**在面试过程中，你几乎肯定会被问到这个问题。
*   **总是寻找机会去记忆。**如果您的函数是确定性的，并且您将使用相同的输入多次调用它，那么您的解决方案可能会受益于记忆化。
*   **找出并写出递推关系。**在这种情况下，把它写出来，显然 N 跳的计数只取决于 N-1 跳的计数。

*如果你喜欢这个帖子，* ***鼓掌或者留言回复*** *！没有什么比收到读者来信更让我内心感到温暖和模糊了。此外，如果这是你喜欢读的那种东西，并且如果你一直在这里，这是一个好机会，* ***给我一个跟随*** *！这东西的来源还有很多。*

# 但是等等，还有呢！

好的，我说我们完成了，但是这个问题还有一个解。在我采访这个问题的所有时间里，我从未见过任何人提出这个问题。我甚至不知道它的存在，直到我的一个同事带着震惊的表情回到他的办公桌前，宣布他刚刚面试了他见过的最好的候选人。

我很快会发布一个详细的后续，但在此期间，我会让你们所有人都想知道如何在对数时间内解决这个问题…

如果你想问我问题或者只是想了解更多关于面试的知识，请查看我们的不和谐！

*更新:现在我们已经开始运行了，这是本系列所有帖子的列表:*

*   [*简介*](/@alexgolec/introducing-google-interview-questions-deconstructed-a012e41ea631)
*   [*骑士拨号器*](/hackernoon/google-interview-questions-deconstructed-the-knights-dialer-f780d516f029)
*   [*同义查询*](/@alexgolec/google-interview-problems-synonymous-queries-36425145387c)
*   [*比率查找器*](/@alexgolec/google-interview-problems-ratio-finder-d7aa8bf201e3)