# 我第一次如何使用领域驱动设计

> 原文：<https://medium.com/hackernoon/how-i-first-used-domain-driven-design-652814794567>

## 介绍

有一天，我打电话给我的一个老软件架构师工作朋友。他最近读完了一本他说我必须读的书。沃恩·弗农称之为[实现领域驱动设计。](https://vaughnvernon.co/?page_id=168#iddd)

我已经有一段时间没有看开发书籍了。我花了一年半的时间通过[家庭录音室:像罗德·热尔维斯的专业人士一样建造它，在我的地下室设计并建造了一个隔音的录音室。](https://www.amazon.com/Home-Recording-Studio-Build-Like-ebook/dp/B00B7R830Y/ref=pd_cp_351_1?_encoding=UTF8&psc=1&refRID=QCHHDQSPRYHZZS5WX37N)

读完那本书后，我为我将要读的书做好了准备。每一章都包含了外来的概念，随着其他章节的连接，我将开始进一步理解这些概念。在尝试应用我新发现的知识之前，我把这两本书的每一章都读了很多遍。这两本书都有很多例子来说明在不同的复杂程度上应用这些知识的不同方法。我学会了如何应用这两个主题中最复杂的部分，然后回归到对我的特定项目有意义的部分。这两个决定都归结为效率与成本(物有所值)。

因为我在我的项目中使用 C#，所以[我首先找到了一个沃恩·弗农在 github 上开始的示例项目，它使用了基于书中使用的示例的 C#。每当我不得不做出类似的决定时，这对于了解做出了什么决定非常有用。这对于从整体上理解整体架构也非常有用，而不仅仅是在整本书中到处看到代码片段。很高兴看到 C#中的代码示例。尽管它们仍然很容易理解，就像我读过的许多编程书籍一样，但是代码样本是用 Java 编写的。这本书的基础更多的是关于领域驱动设计的战略和战术实践，而不是任何特定的语言。](https://github.com/VaughnVernon/IDDD_Samples_NET)

## 关于我使用的风格

我真的很喜欢，并且有点沉迷于[紧急设计](https://en.wikipedia.org/wiki/Emergent_Design)。当你根据需要重构你的代码时，它工作得非常好。我必须对整个项目有一个粗略的概述，以了解每一个高层次的设计和想法都是可能的，但随后就去做，不要害怕前面会发生什么。我喜欢编写一个 main 函数，它的名字非常明显，用户会知道它是做什么的，然后开始在那个类中敲打我的代码，同时每当一个新的函数或对象作为一个明显的提取出现时就进行重构。根据它是如何开始的，我可能会为下一个较低级别的步骤编写一个注释，使每个注释成为一个具有相似名称的函数，然后通过自动生成那些带有“未实现”异常的函数来进行重构。如果某件事真的很复杂或困难，我可能会写一堆代码，直到它能工作为止，然后逻辑地把它分成单独的部分(类、方法等)。)直到它读起来像一本书。不管怎样，这段代码应该读起来很好，读起来就像一个故事。那就没有理由让评论最终变得过时。

所以我的观点是，这并没有成为一个[预先设计的](https://en.wikipedia.org/wiki/Big_Design_Up_Front)项目。我遵循了领域驱动设计的概念，但是在我进行的过程中，在它们的概念的指导下应用和重构了它们。

## 普遍存在的语言

DDD 战略的一个主要部分是直接与用户交流，以定义一种无处不在的语言。这个想法是开发人员和用户可以说同一种语言，开发人员在提出类名、变量名等时使用这种语言。这样，代码读起来就像用户在说话。

我从事的项目是接收健康保险公司的电子支付，并将支付与电子健康记录(EHR)系统中的费用进行匹配。许多无处不在的语言都是在文档中定义的，但是我也直接与用户交谈，以确定在交谈中可能常见的任何更随意的措辞。我也对他们如何描述某些事件有了一种感觉。

## 域和有界上下文

领域是你试图为之编写软件的逻辑划分或部分。一个领域通常有自己无处不在的语言。例如，一个企业可能有一个库存域、一个采购域、一个人力资源域、应收账款域等等。有界上下文是代表该领域解决方案的代码周围的边界。这些可以用一个简单而松散的概念来划分，就像一个模块(我在书中发现它相当于一个 C#命名空间)，或者像一个拥有自己数据库的微服务一样极端。对领域和有界环境的最好描述是，领域是问题，有界环境是解决方案。

在我的项目中，我将我的项目分成两个有界的上下文。一个表示从健康保险公司接收一个文件，该文件被解析成离散数据以便保存，另一个表示接收命令对象([数据传输对象](https://martinfowler.com/eaaCatalog/dataTransferObject.html)，应用程序接收这些对象进行处理)以便将收到的付款应用到费用中。这使得支付过账域非常易于通过自动化单元测试进行测试，并且由于它与数据来源的任何知识相分离而可重用。它接收的命令对象准确地定义了它需要什么来处理支付。

现在我想起来，第一个接收文件、创建和保存离散数据以发送到支付过账域的“域”更像是发送文件的系统和应用来自文件的支付的系统(支付过账域)之间的一个[反腐败层](https://docs.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer)。无论哪种方式，它们都像域一样被分开。

## 聚合、实体和值对象

我将尽可能简单地定义它们，但是它们是使用 DDD 设计类的主要参与者。这些类都不访问数据库或任何其他外部文件。它们是严格意义上的类，包含带有业务逻辑的属性和方法。这使得它们成为自动化单元测试的优秀候选者。

***值对象***

我将从值对象开始。这些是不可变的类(属性一旦创建就不能改变)。这有助于验证。由于您只需通过构造函数进行验证，因此您不必担心多个验证位置，因为在构造对象时，没有任何属性会在初始验证之后发生变化。这使得测试更加容易，并且减少了出错的空间。

值对象的相等性是由它们的全部属性定义的。也就是说，如果两个值对象的属性相等，那么对象本身也被认为是相等的。地址就是一个例子。如果两个地址对象具有相同的城市、州、邮政编码、地址 1 和地址 2，那么您可能不关心它们是否具有不同的 id，因为属性定义了地址是否相同。这是有帮助的，因为它们可以在应用程序的多个类中的许多不同的公共属性分组(例如:地址)中使用，同时包含要共享的公共代码。

***实体***

实体是由唯一标识符唯一定义的域类。它们包含任何与该实体特别相关的业务逻辑(值对象和集合也是如此)。我创建的一些实体的例子是 ClaimPost 和 Charge，分别使用 GetTotal()和 RollToNextInsurance(Payer next Payer)等方法。

**蕴 **

聚合是实体的逻辑分组，在“全有或全无”(事务性)的情况下保存是有意义的。根实体是聚合。诀窍是将它们定义在不会大到需要花费很长时间来检索或保存的地方。

例如，我必须将一个聚合分成两个。健康保险支付文件包含支票，在这些支票中是索赔帖子(支付信息)。一个文件中可以有多张支票，但数量通常不会很大。另一方面，支票中可以有任意数量的索赔帖子，每个帖子的信息都被拆分到多个实体中。因此，将这些聚合拆分成一个包含多个检查实体的文件聚合(根实体)，然后拆分成一个包含声明帖子中的多个实体的声明帖子聚合是有逻辑意义的(性能方面也是如此)。声明发布聚合通过其唯一标识符引用检查实体。这使得处理和检索更加高效。

## 仓库

存储库是用于保存和检索集合的类。它们由域中的接口表示(特别是在应用程序和域服务中)，并且它们的实现是注入的。这使得域永远不需要知道任何持久性机制或外部基础设施，如数据库或 web APIs 或服务，从而使它更具可测试性。我能够使用诸如实体框架或 ADO.Net 之类的东西来选择实现，我完全知道我可以在任何时候改变它以使用其他东西，如果我想的话，甚至是每个存储库，只需为该接口实现一个新的存储库。

## 应用服务程序

应用程序服务是有界上下文的入口点。它们是您的客户端(或其他应用程序服务)逻辑将访问的内容，以便为需要做的事情发送命令。应用程序服务接收存储库实现的注入。他们使用这些存储库从所有需要的类中检索编排业务逻辑的必要集合，以完成工作。应用服务方法应该简短明了。尤其是因为您的绝大多数逻辑将包含在适当的聚合、实体和值对象类中。

## 摘要

上面只提到了 DDD 的基础知识。要学的远不止这些。这只是一个非常简短的介绍。例如，我没有讨论域事件或域服务。我在这里提供了关于这些主题的最佳参考资料的链接。

虽然 Eric Evans 的领域驱动设计书是我仍然计划有朝一日阅读的原著，但我很高兴 Vaughn Vernon 的书首先被推荐给我，因为我能够参考代码示例和项目。在我能够通读这本书的时候，帮助我的几个额外的参考资料是[沃恩·弗农关于设计有效聚合的这个](https://vaughnvernon.co/?p=838)系列论文，以及[弗拉基米尔·霍里科夫的这篇](https://enterprisecraftsmanship.com/2016/09/08/domain-services-vs-application-services/)文章，其中对域服务和应用服务之间的差异有更清晰的定义。另外，[塞萨尔·德·拉·托雷撰写的这篇关于领域事件和集成事件之间的区别的文章是我所能找到的关于该主题的最佳资料来源，它参考了关于如何处理这些类型的事件的其他重要资料。我希望这篇介绍和提到的参考资料对你的学习和未来的旅程有所帮助。](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)