# 我是如何从学生到辍学者再到软件工程师的

> 原文：<https://medium.com/hackernoon/how-i-went-from-student-to-drop-out-to-software-engineer-e8123d6a4199>

![](img/79be22d12d3326e4e3ac36ccfc021fbb.png)

# 介绍

我在大学里花了三年时间学习健康和医学专业。通过一系列漫长而复杂的事件和认识，我对计算机科学产生了兴趣，随后对软件工程产生了兴趣。于是，我决定转学，进入一个软件工程本科项目。

我在那个项目里呆了不到两个月。

这并不是因为我没有明确表态。相反，我有一种被目标困扰和消耗的诀窍。由于好奇和痴迷，当我深入学习一门特定的学科时，我很容易并且意外地忘记了社会和日常责任。

对一些人来说，痴迷于学习可能听起来与通常被归因于“大学辍学生”(我自豪地戴着这个头衔)的特征不相容。

但实际上很有道理。我的班级没有给我足够的材料，也没有给我合适的材料。他们进展缓慢，我的许多问题都没有得到回答(甚至在我亲自去找教授之后)。我厌倦了抄写写在粉笔板上的程序。我厌倦了听到“面向对象的范例”，却看不到这个“神秘的”面向对象到底是什么。我厌倦了肤浅的学习。

我记得有一次下课后，我走到图书馆，挑了一本 Java 书。我整个下午和晚上都在阅读和实验。那天晚上，我学到的东西比我入学的整整一个半月还多。那么，我付钱是为了什么？我在为血统付钱。我不能让自己继续参加这个项目，因为我在教室里花了太多的时间，而花在学习上的时间太少了。

我不认为这是课程的错误，而是基于课堂的教育的错误。出于多种原因，基于课堂的教育似乎没有优化能力。除了教学上的疑虑，我还经常对基于课堂的学习有另一个问题:它非常无聊。有时候节奏太快太肤浅，有时候又慢得令人难以置信。即使课程内容很深，培训也不深。

总的来说，我发现基于课堂的教育不足以将学生推向最后一步:从对材料的知识到可操作的理解。通过“可操作的理解”，我指的是以潜在的新方式将知识应用于新环境的能力。如果你不能意识到一个概念存在于你所学内容之外的环境中，你真的理解了它吗？这就像声称知道导数，因为你能够对一个函数求导(这只是一个机械的操作)，却不能认识到它何时适用，为什么重要，或者它实际上意味着什么。计算器可以替我们进行机械操作。计算器(目前)无法看到一个问题，并使用直观的理解来推断正确的方法。他们只能执行指示他们执行的操作。难道我们的目标不应该是比非智能计算器“理解”导数更深入地理解概念吗？我也这么认为基于课堂的教育似乎不同意。

当我在解决问题、学习新东西或在概念之间建立联系时，我喜欢来回踱步，在笔记本上涂鸦，甚至大声向自己解释想法。我喜欢从不同的角度探索我的心智模型，直到我找到一个需要修补的漏洞。此外，我喜欢不断地重温已经褪色的旧主题，重新审视这些主题，让我有机会建立以前错过的联系，并重新测试我的理解。

于是，我退学，踏上了非传统教育之旅。起初，我完全是以自学的方式学习。在这个初始阶段，我将大部分精力投入到(不那么简单的)制定一个可靠的学习计划的项目中。我知道我需要从基本原则开始学习，但是整理大量的资源花费了我太多的精力和时间，以至于我的学习进展缓慢。我知道我有动力，能够吸收信息并综合它，并严格地询问我自己的心智模式——这些都是有效的自学者的特征。我不太擅长的是坚持自己的学习道路，因为我总是认为这是不够的:我不是这个领域的专家，那么我有什么资格为自己设计有效的课程呢？对于一个软件工程师应该知道什么，我不是一个权威的信息来源。我需要一些指导来让我开始…最好是专家的指导。

# 学习资源的比较

我开始寻找非传统的外部教育资源，这些资源比我自己能够提供的方向更多。

## MOOCs

我发现的第一个非传统资源是 MOOC 生态系统。在筛选了无数选项后，我意识到 mooc 提出了一个与我之前遇到的问题类似的问题:几乎每个科目都有 mooc。此外，它们在质量、深度、教学方法和时间限制方面都有所不同，这意味着如果我要依赖 MOOCs 作为主要的学习来源，我需要过滤许多其他因素。

就像以前一样，我需要筛选其中的许多课程，并决定参加哪些课程，这些课程的最合理的顺序，以及凭借这一点，哪些主题是基本的，哪些是“选修”的。MOOCs 不是一个理想的来源，所以我暂时放弃了它们，去别处寻找。

## 训练营

我喜欢训练营的想法，因为强化学习的想法吸引了我。我在压力下茁壮成长，我喜欢被推到认知极限的想法…并获得成功。当我探索无数的训练营时，我注意到它们都有两个致命的缺陷:

1.  时间限制看起来太极端了，因此排除了反复测试和回顾一个人对主题的理解的能力。没有循环学习的机会。
2.  这些题目没有教得深入。即使是最好的训练营也没有充分准备好学生的基础知识。

换句话说，我认为训练营是一种培养用户而非开发者的方式。什么用户？框架和高级开发工具。我不想局限于一个特定的工具集，或者一些基于软件时尚的狭隘的开发原则，而不是深深植根于基础知识和培训。当然，总有例外，我已经听说了一些非常优秀的训练营毕业生(我甚至见过几个)。

对于那些已经有技术背景、只想快速掌握某个特定专业(如 web 应用程序开发或移动开发)的学生来说，训练营似乎更成功。

## 自学课程

我也遇到过由自学者设计和针对自学者的多种课程。不同的“自创硕士学位”文章和要点定期在 Reddit 和 Medium 上出现。我看了很多。我也看了[自学课程](https://teachyourselfcs.com/)，它的内容实际上相当扎实。

这些课程的主要问题不是内容的质量(实际上有一些全面、合理的课程)，而是我开始意识到，在一个人已经成为一名专家，拥有坚实的基础知识和培训之后，纯粹的自学更有效。这是因为自学缺少一个对新人来说至关重要的组成部分:反馈。

反馈(来自那些有资格提供反馈的人)是自我提高的最有力的形式(假设你遵循它)。一个特定领域的新来者不知道如何识别高质量的工作或信息。他们不知道如何在自己的实践中识别反模式。他们不知道如何解释项目中的微妙之处(尤其是较大的项目)，他们不知道如何对某些标准负责，因为他们不知道那些标准是什么(或者，如果他们在理论上知道那些标准是什么，他们不知道如何在实践中识别它们)。

## 发射学校

在某个时候，我偶然发现了一个谜，那就是[发射学校](https://launchschool.com/)。我记得导航到他们的“这是给我的吗？”佩奇解释了什么是 Launch School**而不是**，然后才说什么是 Launch School (LS)。从本质上来说，T4 不是那些仍在探索自己选择的人的地方，也不是那些想尽快找到工作的人的地方。事实上，LS 以他们学习的“慢路径”而自豪。

他们重视深度、掌握、循环学习和毅力。它们与“快速简单”的道路相反。

他们的教学方法正是我一直在寻找的。他们称之为“[基于掌握的学习”](https://launchschool.com/mastery)，这是一种通过能力而不是时间来衡量进度的学习模式。在你证明你已经掌握了当前课程的内容之前，你不能进入下一门课程。

他们结合评估、面试和项目来衡量掌握程度。通常会遇到 3-4 个小时的书面评估，其中充满了要求考生用精确的语言解释概念的问题。他们的学习指南解释了他们所说的“精确”的含义，如果有任何语言含糊不清或过于复杂，给评估打分的教师或助教会让学生改正他们的答案。学生没有办法伪造他们对材料的理解，因为要求学生解释概念的水平防止任何手动波动或不清楚的答案。

如果学生没有得到满分，他们必须回去改正他们的答案。如果他们得不到 B，他们会得到一个“还没有”，并且必须在至少一周的进一步学习后重新参加评估。另一个“还没有”意味着再学习两周，以此类推。

书面评估只是掌握程度评估的第一部分。评估往往有项目和/或面试的组成部分。在项目期间，学生被给予一组技术规范和时限(通常是 24 到 48 小时)来开发满足这些规范的应用程序。讲师会对代码质量、结构和设计决策进行严格审查和评分，此时评分者会向学生提供充分的反馈。在面试中，学生将在面试官面前解决问题，类似于工作面试中进行编码挑战的方式。面试还可能要求学生陈述他们在应用程序开发过程中做出的设计决策。Launch School 的严格评估从多个角度测试学生的沟通技巧、规划、精确度和代码质量。

讲师和助教几乎可以全天候回答问题。他们还会对整个课程中的大量[编程](https://hackernoon.com/tagged/programming)作业进行无数次代码审查(记住:反馈对掌握至关重要)。

完成核心课程花了我几千个小时的学习。然后，我进入了他们可选的、基于招生的顶点计划，在那里我学习了最优化、算法分析和设计以及系统设计。我还[建立了一个项目](https://hackernoon.com/building-layr-an-experimental-decentralized-cloud-storage-system-be32e530fd8d)，展示了深思熟虑、研究、管理复杂性的能力和工程深度。

顶点计划总共又花了大约一千个小时。我在纽约市的多个活动中展示了我的工作，这引起了其他寻求推荐的工程师的足够兴趣，以至于我不得不开始**拒绝面试机会**。在发出我的第一份工作申请后的两周内，我得到了工作机会、面试机会和选择工作地点的自由。我没有追求任何入门级的职位，也没有任何职位提供低于 100K 的起薪。

我喜欢在 LS 的经历，因为我终于能够掌握掉进兔子洞的诀窍。我可以用真正苏格拉底式的方式询问一个主题的死亡。

## 补充学习

我也使用了其他的学习资源，作为 LS 课程的补充。数学是一门我实际上没有接受过正规训练的学科，我看重它的重要性和它的智力乐趣。以下是我使用的主要资源:

1.  [如何证明](https://www.amazon.com/How-Prove-Structured-Approach-2nd/dp/0521675995)
2.  [计算机科学的离散数学](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-spring-2015/)
3.  [线性代数](https://ocw.mit.edu/courses/mathematics/18-06sc-linear-algebra-fall-2011/)
4.  [集合论](https://www.amazon.com/Book-Theory-Dover-Books-Mathematics-ebook/dp/B00LOZENB2/ref=sr_1_1?ie=UTF8&qid=1529584006&sr=8-1&keywords=set+theory)(同一作者写的一本抽象代数书也是很好的读物，但不是必需的)
5.  [Apostol《微积分》第一卷](https://www.amazon.com/Calculus-Vol-1-Tom-M-Apostol/dp/8126515198/ref=sr_1_1?s=digital-text&ie=UTF8&qid=1529584056&sr=8-1&keywords=calculus+vol+1+apostol)

我还自学了一些建筑和设计，使用了以下主要资源，以及其他一些不太重要的资源:

1.  [Ruby 中实用的面向对象设计](https://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330/ref=sr_1_1?s=books&ie=UTF8&qid=1529595565&sr=1-1&keywords=practical+object+oriented+design+in+ruby)(一般适用于 OO 语言)
2.  [网络应用架构](https://www.amazon.com/Web-Application-Architecture-Principles-Protocols/dp/047051860X/ref=sr_1_1?ie=UTF8&qid=1529595478&sr=8-1&keywords=web+application+architecture)
3.  [设计数据密集型应用](https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321/ref=sr_1_1?s=books&ie=UTF8&qid=1529595542&sr=1-1&keywords=designing+data+intensive+applications)(这本书特别不可思议)
4.  [Web 应用安全:初学者指南](https://www.amazon.com/Web-Application-Security-Beginners-Guide/dp/0071776168/ref=sr_1_2?s=books&ie=UTF8&qid=1529595513&sr=1-2&keywords=web+application+security)

# 基本面的重要性

对非传统背景的软件“工程师”的一个常见抱怨是，他们知道如何编码，但缺乏“工程”方面的知识。另一种说法是:他们缺乏学生在更传统的教育课程(如大学里的课程)中往往会接触到的基础知识。

对于自学成才的开发人员，以及那些经历过非传统教育项目的人来说，很容易错过学习基础知识的机会，也很容易意识不到他们从一开始就缺少一套核心知识。过分关注实用性的程序牺牲了开发人员强大的心智模型。这方面的问题是，建立在理论理解基础上的强大心智模型实际上是一种实用的资产，因为它使开发人员能够使用这些心智模型来联系新信息和解决新问题。心智模型就像指南针，帮助开发者导航新的技术领域。

传统的教育课程倾向于把更多的时间放在理论上。因此，他们有时会犯这样的错误:过于深入理论，以至于牺牲了实践训练。非传统教育课程往往会适得其反:它们往往会犯这样的错误:过于深入实践而牺牲了理论训练。在这两种情况下，学生都没有做好准备:被他们的知识所限制，而不是被理解所激励。这是由于理论与实践的错误对立。没有实践，学生不知道如何应用他们遇到的理论。没有理论，学生就不知道如何将新信息融入他们当前的“它是如何工作的”模型，从而阻止他们有效地将新知识吸收到真正的理解中。

没有理论的实践将开发人员限制在他们最初接受培训的技术上(这里适用的术语是“框架用户”而不是“软件工程师”)，没有实践的理论培养出的学生在拿到他们的第一个特性规范时，将会不知道从哪里开始。

强大的心智模型需要实践和理论的融合。在获得你的第一个软件开发角色之前，不可能学会你作为一个软件开发人员需要知道的一切。总是有更多的东西要学。因此，最好的做法是建立牢固的基础理解，这将使您能够快速吸收新信息并适应不断变化的行业。

传统和非传统教育领域都有隐藏的例外。Launch School 是一个非传统项目，但它强调心智模型、基础理解和学习“不会改变的东西”的重要性。尽管软件行业变化很快，但基本面却没有变化。对于毕业生来说，受雇于使用他们从未接触过的技术的职位是很常见的。

西部州长大学是大多数大学标准教育模式的一个例外。我最近才听说这所学校，我对他们采用他们所谓的“基于能力的教育”的学习方法印象深刻。在 WGU，学生被要求在进入下一个主题之前证明在特定的课程中有足够的技能。课程没有时间限制:学生们需要或长或短的时间来获得他们正在学习的任何学科的能力。

开发人员的培训来源无关紧要。无论是传统的，非传统的，还是完全自学成才的，最重要的是:他们是否掌握了基础知识？

# 超出

作为一名 LS 核心人员，我目前的职位是软件工程师 II，我与一些真正熟练的工程师和主管密切合作。凭借对基础知识和实践的深刻理解，我觉得自己已经为应对职业生涯中的复杂挑战做好了充分准备。我特别喜欢我目前的职位的一点是，我们面临的一些挑战不是可以在 StackOverflow 这样的地方搜索到的，因为我们现在正在解决这些挑战，这是有史以来第一次。

我希望看到基于掌握的学习教学法变得更加主流，因为它可以防止人们在没有掌握核心概念的情况下“C”或“D”通过课程。