# 如何在没有更多抽象的情况下获得最佳可读性

> 原文：<https://medium.com/hackernoon/how-to-get-to-the-best-readability-without-more-abstraction-4de9621f75c5>

我用各种方法重构了一个复杂的“if”语句。我发现了一个有趣的趋势。使用简单的重构步骤，当追求代码的更高可读性时，您通常可以走不同的方向。每一个小的重构都是可读性的增加，有时是复杂性或抽象性的降低、或增加、或中性。

TL；DR:从这个实验中，我明白了在重构的时候，我们不应该急于增加新的抽象层次。也许有一种方法可以在当前抽象的范围内提高可读性。

您不希望您的代码看起来像这样:

![](img/9c54dd5b039156a57962a8559b801829.png)

Abstraction going wild! 🦌 source: [pexels](https://www.pexels.com/photo/abstract-art-blur-bright-373543/)

# 代码示例

我给你举个例子。我对石头剪子布编码的形有如下的实现:

That “!=” is screwing with understandability. 😖

# 第一条重构路径

我的第一个直觉是，这些“如果”陈述正在验证第一次投掷是否胜过第二次投掷。所以我认为可以提高可读性的抽象应该是:

Oh, that is exactly what I want to say there in the code! 👏

这只是解决了一个问题。“beats”方法中的代码仍然没有很好地表达意图。您几乎必须在大脑中执行代码，才能理解它与您的业务规则的关系:

Oh no! The same problem has just popped somewhere else! 🐜

我们已经引入了一个抽象层次。条件的可读性没有提高，只是被移动了一下。“播放”功能的可读性仅略有提高。

我的直觉为“beats”中的可读性问题提出了一个直接的解决方案:将 enum 类转换成一个接口，并为每种类型的 throw 提供三个具体的实现:

Abstraction, abstraction, and abstraction. 🏚

现在，显而易见，被否定的条件(如`other != ROCK`)不是我们真正需要谈论的。相反，我们需要讨论当前的“其他投掷”击败了哪一个:

Yeah, should’ve dealt with this “!=” long before. Poor me. 😞

这个重构路径可以更进一步，用字段“winsAgainst”实例化剪刀、石头和布，并在“beats”方法的默认实现中使用它:

That looks cute. Could make it a data class with 3 pre-defined values. 🗃

因此，在一天结束时，我们必须增加两层抽象，使“play”函数中的逻辑更可读，并使“if”条件更好地表示意图。

众所周知，更抽象意味着孤立地理解每一点更容易，但从整体上把握更难。

和抽象泄漏。

# 这种抽象在新特性中表现如何？

让我们看看当前的抽象是否如此。让我们把经典的石头剪子布问题转化为文化上更现代的石头剪子布蜥蜴史波克问题。以下是规则列表:

Wow! DSL!!! 😻

(顺便说一下，这其实是一个可运行的测试。感谢科特林的 DSL 善良！参见[我是如何用完整的 TDD 流程编写这个测试的](https://iwillteachyoukotlin.com/2018/10/15/how-to-make-your-tests-read-like-business-rules-w-infix-functions/)。)

第一个断言错误是“岩石应该击败蜥蜴”，但如果我只是替换“winsAgainst”字段的值，它会以“岩石应该击败剪刀”失败。

这意味着我们必须打破 Throw 接口和它的实现者之间的 API。现在我们需要“winsAgainst”作为一个列表:

Abstraction leaked. 💦🔫

虽然泄漏被很好地包含在一个文件中，但是抽象仍然泄漏。如果与最初的“如果”语句相比，这种抽象的复杂性是非常不和谐的。

# 撤销！并且限制我们自己使用更少的抽象层次。

让我们回过头来，尽量限制自己不要引入任何沉重的抽象。我们能不能把“play”函数中原来的“if”语句变得可读性更强一点？

Back to square one. Feels goooood! 😊

# 解释变量

是的。解释变量。让我们把否定从“第二！= ROCK”和类似的东西，正如我们在其他重构路径中已经了解到的:

Let me explain! 🕵

有点可爱。它更容易阅读，也更像业务规则。

这里我有一个疯狂的问题:我能在这里创建一个 DSL 来使代码看起来更接近人类对规则的描述吗？

# 疯狂 DSL

我可以！(不确定我是否应该):

Don’t do this at home! 🔥

哇，这看起来很酷。而且读起来很好。

除了“规则(第一、第二)”部分。这到底是怎么回事？

Magic, magic, and more magic! 🎩

“在这里，你失去了我，奥莱克西！”—在这一点上，我会告诉自己。Kotlin DSL 有很多神奇之处，比如中缀扩展函数和 lambda 扩展函数。

不过，在那一点上，我把注意力集中在“rules(…) {…}”块的形状上。看起来有点眼熟。

# DSL 只是模式匹配。简化！

模式匹配！

我在这里试着将“第一和第二”配对成某种组合，比如“剪刀和布”，“布和石头”，“石头和成功”

这可以通过“when”语句来实现(Kotlin 的经典“switch”语句的高级版本):

Beauty, simplicity, and readability! (if you know Pair<A,B>) 👟

现在，由于我们直接提到“真”和“假”，并在“如果”语句中使用它，让我们通过删除布尔变量来简化“播放”函数:

The final solution. ✅

# 这个解决方案的新特性怎么样？

所以我们没有更多的抽象层(除了很少使用`Pair<A, B>`类和它的`to`中缀扩展函数)。让我们看看引入新规则有多难:

Umm… Lizard… 🦎

那很容易！

# 使用函数别名的更多表达式。如果你喜欢那个…

而如果想让它更有表现力，可以为中缀函数“to:”创建两个别名 vs 和 beats(绝对可选):

Icing on the cake in the form of infix extension function aliases. Wait, what? 🍰

# 重构之旅的收获

重构时，我们的解空间似乎是一个多维函数，我们试图找到一个足够好的局部最大值。

就像教神经网络一样。你的重构步骤是梯度下降。

现在，如果你只探索单一下降，你会有好的东西。但这可能是次优的局部最大值。如果我们回头尝试一些不同的重构步骤(不一定更好)会怎么样？。

事实证明，我的第一条重构路径产生了可读的代码，但是它引入了两个抽象层次(1 个接口和几个实现)。

当回到过去，尝试不同的选择，例如尝试最多引入 1 或 0 级抽象，它产生的代码同样可读，但是其中的抽象更少；因此，更容易理解它是如何工作的，并且抽象泄漏的机会也更少。

我要说的是，我不得不在最初的几个步骤中使代码变得更糟糕，然后在接下来的步骤中迅速使它变得更简单。

# 秘密武器

不要总是凭直觉进行重构，要探索替代方案，了解可读性、复杂性和抽象性的多维功能。

你应该考虑探索玩具代码的选项，而不是生产代码:[编码卡塔](http://kata-log.rocks/)是完美的选择。从重构的道路上退出，并朝着完全不同的方向前进，这是绝对正确的。

对于生产代码，这也是可行的。你没有浪费任何东西。代码没什么价值。你获得的、现在可以应用的知识是金子，它会留在那里。

一定要看看我的 4 集电子书，350 页长的《T2 终极教程:科特林入门》除了 Kotlin，它还有很多好东西，比如 TDD、干净的代码、软件架构、业务影响、5 个为什么、验收标准、人物角色等等。下载并[学习科特林语](https://iwillteachyoukotlin.com/)。

# 谢谢大家！

感谢您的阅读！此外，如果你喜欢你刚刚阅读的内容，可以考虑在 Medium(最多 50 个)上给我鼓掌，并在社交媒体上分享这篇文章。那会让我超级开心的！:)