# 为领域建模提供案例

> 原文：<https://medium.com/hackernoon/making-a-case-for-domain-modeling-17cf47030732>

软件开发人员和架构师对领域建模的巧妙运用可以让复杂的应用程序更具可扩展性——这是阿里巴巴技术团队的最佳实践

![](img/c9759450ac27b1dcb9f18393862f3cf3.png)

领域建模是应用程序设计的两种基本方法之一。在基本层面上，可以通过将“领域”理解为业务知识的总和，将“建模”理解为业务逻辑的面向对象的抽象。在基于业务需求构建了由不同对象组成的领域模型之后，架构师编写代码来执行对象之间的业务逻辑。

另一种基本方法是事务脚本。简单、直接且易于使用，它将业务逻辑设想为一系列过程和子过程。(除此之外，还有混合方法，如命令查询责任分离(CQRS)，它基于使用不同模型读取和更新数据的概念)。

在这些选项中，没有一个放之四海而皆准的解决方案。最合适的方法取决于业务需求的复杂性。例如，将域模型用于查询和报告过程是不必要的复杂。在这种情况下，它有助于认识到简单性，摆脱领域层，并获得对基础设施层的直接访问。

然而，正如在简单的情况下默认使用领域建模方法会有过度工程化的风险一样，试图使用简单的事务脚本来处理固有的复杂业务场景也是错误的。事务脚本在处理复杂场景时往往会把代码搞得一塌糊涂，导致随着应用的发展，系统的腐蚀和复杂程度呈指数级增长。

在处理复杂的业务逻辑时，域建模提供了构建更健壮、可伸缩和用户友好的应用程序的选项。因此，问题是确定何时使用这种方法，并学习如何有效地应用它。

# 理解领域建模的好处

领域建模基于对象的本质可以帮助架构师更容易地管理应用程序的开发。它坚持对象的内聚性和可重用性，更直观地封装了业务逻辑。

这可以用一个用例来演示。考虑以下基于不同的事务脚本和域建模执行的银行转帐示例。这是一个经常用来比较这两种方法的经典例子，例如 Lorenzo Dee 的博客中的[。](https://lorenzo-dee.blogspot.com/2014/06/quantifying-domain-model-vs-transaction-script.html)

## 使用交易脚本的银行转帐

在下面的示例中，两个银行帐户之间的货币转账的业务逻辑是在 MoneyTransferService 的实现中编写的，其中 Account 只是 getters 和 setters 的数据结构。这就是我们所说的贫血领域模型。

![](img/7632176c5bd8762e0382e6864782ec1c.png)

如果这段代码看起来很熟悉，那是因为大多数现有系统都是这样编写的。通常，架构师会从需求审查开始，绘制一些统一建模语言(UML)图来结束设计，然后开始编码，如上所述。除了代码的最终目标，架构师没有太多要考虑的。

从表面上看，这似乎是一个简单的——甚至是琐碎的——方法，能够成功地实现所需的功能。这就是为什么许多开发人员认为编写业务代码是一项单调乏味的工作。但不一定要这样。在这种情况下以及许多其他情况下，事务脚本都不是理想的方法，因为它除了快速解决手头的问题之外，几乎没有提供什么其他的东西。

另一方面，领域建模是一种更加全面的方法，如果使用得当，它会产生更加可扩展、可维护的代码。虽然通常被认为是领域级的方法，但是领域建模也可以在基础设施级使用。

应用程序开发人员的另一个优势是，领域驱动开发(DDD)方法——一点也不单调乏味——需要开发人员运用他们的抽象能力和建模技能。这些是必须发展的基本技能，以便成为应用程序架构师，他在业务通常复杂得多的领域级别工作。

## 使用领域建模的银行转帐

使用无处不在的语言允许架构师使用领域建模方法来使隐含的业务逻辑更加明确，使得控制复杂性成为可能。此外，如果使用域驱动开发(DDD)，除了帐户属性之外，实体帐户还包含行为和业务逻辑，如 debit()和 credit()方法。

![](img/ac92594dd1630b9dc737f8f702e5a817.png)

透支策略也通过业务规则和策略模式从 Enum 抽象成它自己的对象。

![](img/80551fc31abec17f9b8e132384709430.png)

同时，域服务只需要调用域对象来完成业务逻辑。

![](img/cf562ee8ad19dab7110bca4be390b28b.png)

这个 DDD 重构将事务脚本中的逻辑分散到三个定义的对象中:域服务、域实体和透支策略。

## 摘要

总之，对于复杂的业务场景，域建模方法比事务脚本有优势，因为它是面向对象的，并且使业务语义清晰。

**面向对象方法:**

> **封装**
> 
> 所有与帐户相关的操作都封装在帐户实体中，具有更高的内聚性和可重用性。
> 
> **多态性**
> 
> 透支策略采用策略模式，这是多态性的典型应用，提高了代码的可伸缩性。

**明确的业务语义:**

> **无处不在的语言**
> 
> 在开发团队中共享一种无处不在的语言有利于交流、编码、起草、写作和演讲。最佳实践是确保所有重要的领域概念(如账户、转账和透支政策)都有一个一致的名称，用于从日常讨论到产品需求文档(PRD)的所有上下文中。这可以显著提高代码的可读性，减少认知负荷。
> 
> **显式逻辑**
> 
> 领域建模从事务脚本中的一堆“if-else”语句中提取隐含的业务逻辑，并使用一种无处不在的语言来命名、编码和扩展该逻辑，将其转化为一个显式的概念。
> 
> 例如，用事务脚本编写的“透支政策”的含义完全隐藏在代码逻辑中，让外行读者相当困惑。另一方面，领域建模使用策略模式来抽象这种逻辑，以确保更好的可读性和可伸缩性。

# 领域建模基础

## 入门指南

面对大量关于领域建模的工作——以及乏味的方法，如深入的语法分析——开始似乎令人望而生畏。

**关键原则:**

阿里巴巴技术团队没有钻研领域建模理论，而是发现记住两个基本原则会有所帮助:

> **了解你的领域**
> 
> 构建一个好的模型始于对业务的深入了解。没有这一点，单靠句法分析是不会产生一个好的模型的。
> 
> **从基础开始，以后再详述**
> 
> 尽管尽可能多地了解您的领域很重要，但有时架构师需要基于不完整的知识开始建模。在这些情况下，从基础开始，构建一个简单的模型，然后根据需要进行调整是有意义的。

考虑到这些，采用迭代方法进行领域建模是有意义的。首先，在编写代码和运行之前，掌握一些核心概念。如果顺利的话，没必要调整。如果有问题，下一步就是对模型进行调整。随着架构师对业务理解的加深，迭代会继续。

**第一次迭代:构建一个简单的模型:**

构建一个基本模型从从用户故事中提取名词和动词开始，以识别关键对象、属性、模式和关系。

让我们以职业介绍所为例来探讨这是如何工作的。一个典型的用户故事如下:*“汤姆正在通过一个代理机构找工作，该代理机构要求他留下他的电话号码，以便他可以被告知任何工作机会”*。

这个故事中的关键名词很可能是我们需要的领域对象:

**汤姆**是求职者

**电话号码**是求职者的属性

**机构**是指两个关键对象——公司及其员工

**工作机会**是另一个关键领域对象

动词 **inform** 表示观察者模式在这种情况下最合适。

现在，让我们考虑这些域对象之间的关系。求职者与工作机会之间存在多对多(M2M)关系；

一个求职者可以有多个工作机会

一个工作机会可以由多个求职者申请

同时，代理和雇员之间是一对多(O2M)关系，因为代理可以雇佣多个雇员。

这个模型现在已经接近完成，但是许多真实的业务场景在第一次迭代中需要比这多得多的复杂性。例如，并非所有名词都是领域对象，它们也可能是属性。这就是为什么必须在对业务有充分了解的情况下，根据具体情况制定解决方案。成功地做到这一点需要强大的抽象能力和丰富的建模经验。

例如，“价格”和“存储”是“订单”和“商品”的典型属性然而，在复杂的业务场景中，价格计算和库存扣除可能极其复杂。在阿里巴巴的电子商务业务中，它们非常复杂，以至于价格和库存各自构成了一个完整的领域。

也就是说，建模很少是一次性的工作，随着架构师对业务理解的发展，他们对系统的了解会变得更加全面。迭代和重构是建模过程中不可避免的一部分。

## 后续迭代:模型统一和演进

在第一次迭代中构建了一个基本模型之后，后续的工作通常会集中在模型的统一和演化上。这意味着提高模型的内聚性，并扩展它以适应不断发展的业务需求。

**统一:**

在盲人和大象的寓言中，几个盲人根据他们通过触摸大象的鼻子、腿或耳朵学到的东西，对大象是什么——蛇、树干或扇子——得出了不同的结论。类似地，不同的架构师会根据他们的经验和知识水平对相同的业务有不同的理解。

统一一个领域模型包括集成互补的抽象来精炼模型，同时移除不准确或错误的抽象。再来看看这个比喻的例子，两个盲人可能会触摸大象的鼻子，并分别得出结论，这是一条蛇和一条消防水管。这些抽象中的每一个都标识了鼻子的不同属性——就像大象的鼻子一样，一条蛇是活的，正在移动，而一条消防水管正在喷水——但两者都不完整。需要一种新的抽象来结合所有这些属性。

同时，新的抽象还必须排除原始抽象带来的任何不正确的属性和行为，例如尖牙(蛇)或需要卷起并存放在消防车上(消防水管)。

**进化:**

业务是不断变化的，这意味着模型精化是一个持续的过程。随着业务范围和复杂性的增长，架构师面临的一个挑战是保持他们的理解是最新的，并相应地修改模型。

同时，架构师对现有业务的理解也在不断增长。这就增加了每次他们在理解上有所突破时进行代码重构的可能性。通常，一系列的快速变化会产生一个更实用的模型，更适合用户的需求。

跟上不断发展的业务和个人不断发展的理解需要信心和能力。在一个紧张的时间表中承诺重构一个项目需要信心，同时需要能力来确保重构不会破坏现有的业务逻辑。因此，持续集成(CI)是进化的必备条件。

我们可以通过回顾前面的银行转帐例子来进一步探索模型演化的思想。假设银行的业务发展到支持不同的转账渠道——现金、信用卡、移动支付、比特币等——每种渠道都有自己的限制。假设它也发展到支持从单个借记账户到多个贷记账户的转账。在这种情况下，只使用一次转账(从账户到账户)不再合适。更好的方法是抽象一个特定的域对象“事务”来更好地反映业务逻辑。

下图说明了这一演变过程。

![](img/1e5529837f687ff69641588ecd1b0fa6.png)

*Evolution of bank transfer domain model*

## 域服务

**了解域服务:**

上面的银行交易例子提出了域服务的重要但棘手的概念。

简单地说，域中的一些动作是动词，然而它们不属于任何对象。它们代表了领域中的一个重要行为，既不能被忽略，也不能并入另一个实体或价值对象。当在域中识别出这样的动作时，最佳实践是将其声明为服务。服务没有内置状态，只不过为领域提供相关功能。

服务通常以活动而不是实体命名。在银行转帐的情况下,“转帐”行为是一个重要的领域概念；但是，它不属于任何帐户实体，因为它发生在两个帐户之间。不需要将账户实体与货币被转移到的账户实体相关联。在这种情况下，使用 MoneyTransferDomainService 是最好的方法。

总而言之，要成为一个合格的域服务，一个概念必须满足以下三个标准:

1.操作代表一个域概念，它不属于任何实体或值对象。

2.执行的操作涉及域中的其他对象。

3.该操作是无状态的。

**域服务和域层:**

一个系统通常有三个主要层，即应用层、域层和基础设施层。服务存在于应用层和域层。这就提出了一个问题，即哪些服务应该存在于哪些层上。

做这个决定时，要考虑的一个有用的规则是:

如果操作原则上属于应用层，就应该放在这一层。

如果操作涉及到域对象，并且为域提供服务，那么它就属于那个层。

换句话说，任何涉及重要领域概念的动作都应该放在领域层。其他与领域逻辑无关的技术代码应该放在应用层。这可能包括参数解析、上下文组装、域服务调用、消息传递等。

下图显示了在银行转帐的情况下，如何将服务划分为不同的层:

![](img/33ef5e765babd52c2514b5f0ad73ea9d.png)

*Partitioning services into layers*

# 支持业务可视化和配置

最后要注意的是，好的领域模型降低了应用程序的复杂性，因此可以支持优雅的可视化和配置。这有助于利益相关者直接了解并学习如何配置系统——尤其是非技术人员和客户。最终，这提供了一个无代码的解决方案，这是软件即服务(SaaS)的主要卖点。

然而，可视化和配置也不可避免地给系统带来额外的复杂性，所以建议架构师在使用它们时要小心。最佳实践是将可视化和配置的业务逻辑与业务本身的业务逻辑之间的耦合降至最低。否则，它可能会破坏现有的架构，使事情变得更加复杂。

(Original article by Zhang Jianfei 张建飞)

# 阿里巴巴科技

关于阿里巴巴最新技术的第一手深度资讯→在**上搜索 [**【阿里巴巴科技】**](http://www.facebook.com/AlibabaTechnology)**