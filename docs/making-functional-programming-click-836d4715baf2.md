# 让函数式编程点击

> 原文：<https://medium.com/hackernoon/making-functional-programming-click-836d4715baf2>

![](img/d02f4cb489831abb4ddb5a0fbba51529.png)

if only composing functions was this easy

我已经尝试过很多次函数式编程了。如果我说我完全理解它，那我是在撒谎，但至少我认为我现在已经足够理解，可以用一种有意义的方式去思考它了。

试图“得到”FP 的麻烦在于实际上并没有一个想法；实际上有两个大的想法需要你去思考，最好不要把它们不必要的混淆起来。第一个是关于函数，第二个是关于类型。在这篇文章中，我想向你展示这两个想法，并希望说明为什么它们在孤立中是重要的，然后如何将它们结合在一起。

我将使用 javascript 来说明这些例子，因为它恰好可以很好地按照我们需要的方式使用函数。然而，不要被推迟，它们是概念，并不局限于一种语言。如果你讨厌 javascript，那么让我向你保证，我不会使用它的任何疯狂的部分，你也可以将这些概念应用到其他地方。

# 功能:通用积木

在 FP 中，函数的概念有几个方面是*微小的*差别，但是这些差别有一些真正大的含义，正如我们将会看到的。取一个像**n，**这样的函数，它给出了数组中的第 n 个元素:

你有两个参数， **n** 和 **arr** ，当被调用时，它们将返回指定索引处的元素，但是在函数式编程中，我们需要稍微改变一下，以获得第一个重要的见解:一个函数应该只接受*一个参数*。这是一种单投入单产出的交易。

等等，这怎么可能呢？加法至少需要两个数。答案是，如果你需要不止一个参数，你只需返回另一个函数等待下一个参数。当你得到了你需要的一切，你返回结果。

几乎是一样的，但是我们在一点一点地提供论点。**第 n(3)**现在本身就是一个函数，等待数组部分被指定。这个概念有一个完全没有语义的名字“currying”。

对于包括我在内的大多数人来说，你使用新的**n**函数的方式感觉很奇怪，因为你必须有一系列带括号的表达式，看起来与实际的函数调用有点脱节。这就是为什么大多数像 [ramda](http://ramdajs.com) 或 [lodash](http://lodash.com) 这样的函数库都提供了一个名为 **curry** 的函数，它可以将普通函数转换成两个世界中最好的函数，在这里你可以普通地调用它，也可以一部分一部分地调用它。例如:

现在我们可以把**叫做第 n(3)(power)**和**叫做第 n(3，power)**，效果是一样的。我添加的第三个功能**可以让你很好地理解为什么这个概念实际上有意义:第 n 个**是 curried，这意味着我们可以用它构建一个更具体的版本，只需要让我们随着时间的推移把论点分开。这种建立参数的方法被称为*部分应用*，而以这种方式产生的函数被称为*部分应用*。所以无论我们给**第三个**什么样的数组，我们总是会得到元素 3。

> 这个小金块可以单独用于您的日常编程，以提高代码重用。通常，你只需要想一想最好的方法来安排这些论证，让它尽可能的一般化。规则通常是 ***把数据作为最后一个参数*** 。这就是你要处理的数组，你要操作的字符串，对象，数字，数组，等等。

再用一个小工具，我们就能真正把不起眼的功能变成编程的通用构建块。该工具称为 **compose** 。

这可能开始看起来很复杂，但和我在一起，我们会分解它。 **compose** 取 2 个函数 **f** 和 **g，**和一个变量**x**它然后运行**g(x)**，其结果直接被 **f()消耗。**将**第三路 1** 的混凝土 **x** 进入**第 n(2)**生产 *4* ，再由**add(1)**生产 *5* 消耗。

**缀**犹如一条组装线。如果你放了什么东西进去，它就会被我们的某个功能拾取，经过变换，然后被传递给下一个功能，再次进行变换。我第一次思考这个问题时被一件事给误导了，那就是从右到左的*天性使然；因此**composite**中的第一个参数实际上是最后一个运行的操作。如果你看看实现，这是有意义的，但它肯定是一个棘手的问题。*

*当然这是相当随意的，你也可以把它翻转过来。在函数式编程中，这个函数被称为**管道**，它实际上和指定从左到右的转换一样简单。事实上，一些语言实际上有一个用于这种事情的第一类操作符( [unix](https://alvinalexander.com/blog/post/linux-unix/linux-unix-command-mashups) ， [R](https://www.datacamp.com/community/tutorials/pipe-r-tutorial) ， [Swift](https://github.com/jarsen/Pipes) ， [F#](http://theburningmonk.com/2011/09/fsharp-pipe-forward-and-pipe-backward/) ，[c++重载](http://pfultz2.com/blog/2014/09/05/pipable-functions/)，[JavaScript 提案](https://github.com/tc39/proposal-pipeline-operator))。*

*无论哪种方式，像 curry 一样，许多[函数库](http://ramda.com)实现了 **compose** 和 **pipe** ，通常以一种让你指定任意数量的函数的方式，所以我们从现在开始就使用它们。让我们再看一个更接近现实生活的例子。*

*These are real colour names. I didn’t make these up*

*我们已经定义了几个更有用的通用函数，它们与 **compose 配合得很好。**大多数实际上只是将方法转换成普通的函数( **map，join** )，或者采用某种语法，比如读取对象属性并将其转换成函数( **property** )。*

*因此，我们新编写的 **namedColorToHex** 函数隐式地接收一个“x”值，这是我们的颜色名称。这被输入到**属性**中，给出了“蓝色泻湖”数组。该数组被提供给 **map** ，该函数采用一个变换函数和一个数组，并将变换应用于数组中的每个元素。**映射**这里部分应用了 **toHex** 函数，所以输出的是每个数的十六进制表示的数组。 **join** 把我们的新数组变成一个字符串，最后**前缀**在前面弹出一个“#”把它变成一个合适的十六进制颜色。*

*就像伟大的巴赫和莫特扎特一样，他们用同样的 88 个钢琴键编织出精湛的作品，我们用**作曲**和一堆*通用函数*来编写一个程序，不过是把不同的乐高积木粘在一起。没有循环，没有特殊语法，没有中间变量。只是描述如何转换数据。如果到目前为止你已经跟上了一切，那么恭喜你！现在，您已经理解了函数式编程的两大理念中的第一个。*

*嗯，差不多了。我前面提到过，FP 中的函数有几种不同的方式。另一个主要的方法是你的函数应该是“纯”的。这意味着:*

*   *你不用任何没有给你的参数来计算(没有全局状态)*
*   *你不会修改任何给你的东西，你总是只是归还一个新的副本(没有突变)*

*思考这个问题的一个好方法是:*如果我把这个输入给一个函数，我会得到相同的输出吗？如果答案是否定的，那么它可能不是一个纯粹的函数。**

*当然，这对于错误意味着什么？API 调用？随机数生成？这是下一个伟大的想法。*

# *(代数)类型*

*如果你来自面向对象编程，那么你可能知道接口是什么；基本上是一种应该在对象上实现什么的蓝图。这个概念在函数式编程中也很重要，但是方式稍有不同。*

*数组对象上有一个函数叫做 **map** ，如上所述，它对每个元素运行一个函数并返回一个新数组。数组是值的一种*容器*，而**映射**函数让我们不用从数组中取出这些值就可以得到它们。但是，如果您可以将**映射到其他类型，比如 object，会怎么样呢？那意味着什么？***

*你可以在对象中的每个关键元素上运行一个函数，改变值但保留结构。*

*For when you want to shout your favourite fruit at someone*

*这很合理；现在我们可以映射一个对象。现在，这是完全违反规则的，但是如果你继续将 **map** 添加到对象原型中，那么我们就有了一个数组和对象之间的公共接口！*

*The first rule of fight club is never modify the prototype of an object you don’t own*

*现在我们有了一个新的、更通用的概念，即*可映射*——它对**映射**有了一个合理的定义。函数式编程([和数学](https://en.wikipedia.org/wiki/Functor))将这种可映射的想法称为*函子。函子只是值的容器，你在容器上工作而不是直接在值上工作。**

*我希望你的脑子里充满了其他可能的函子。答案是很多事情——只要处理得当，每个函子都可以有自己有趣的小领域。*

*让我们花点时间想象一个容器，在这个容器中，*中的内容可能是一个正常值，但也可能是 null/undefined/垃圾值。我们可能希望从这个特殊的容器中得到的是，如果它存在，那么**映射**值，但是如果它不存在，那么不要导致错误。当然，我们应该能够打开容器，得到有意义的东西——正常值，或者“什么都没有”——并做出相应的响应。**

*我们将构建这个仿函数——通常称为**或者**——但是为了避免暴露一些棘手的 javascript 细节，我将使用一个名为 [daggy](https://github.com/fantasyland/daggy) 的库。从 github 页面:*

> *用于创建标记构造函数的库，也称为“联合类型”或“求和类型”*

*不要担心那到底是什么意思，让我们边做边学。*

*我们要让这个坏男孩崩溃。首先，我们使用 daggy 为一个**或者**构造一个“sum”构造函数——这是封装可能的空值的东西。我们将其命名为 Maybe，它可以是一个具有“x”值的“ **Just** ，也可以是一个没有值的“ **Nothing** ”。*

*接下来，我们为我们的 **Maybe** 实现一个 **map** 函数，其中我们使用一个名为 **cata** 的 daggy 函数(如 [catamorphism](https://en.wikipedia.org/wiki/Catamorphism) 中所示)对类型进行某种切换/case。如果是**只是**类型，我们运行我们提供给**的函数映射**上的“x”值，并把它放回一个新的**中。就**。如果它是一个什么都没有的东西，那么我们可能只需要返回另一个。没事。*

*最后，我们制作一个*有效的东西*和一个*无效的东西*，并在它们上面运行相同的**映射**。我们看到**映射**在两者上运行都没有错误，正如我们所料，我们可能在 *validThing* 和**上看到一个转换后的值。无效的那个上什么都没有。***

*所以我们现在有两个问题。首先，这不是一个真实的例子——谁实际上没有创造任何价值？第二:即使它是现实的，我们的价值仍然被困在**或者**里面！我们需要一种方法把它表现出来，所以让我们重温一下之前的合成颜色的例子，看看我们是否能让它更加防错。*

*分解一下，第一个变化是我们有了一个 **extractMaybe** 函数。它为**没有**的情况取一个函数，为**只有**的情况取一个函数，而**可能是**对象。因此，当它运行时，它将查看 **M** 是否只是的一个**，如果是的话，它将返回提取的值，并对其进行**成功 Fn** 运行。如果不是，那么它将返回 **nothingFn** 的结果。***

*然后我们有了另一个新的函数叫做 **safeProperty** 。这将检查对象是否真的有我们试图获取的属性，如果有，则返回值的**和**，如果没有，则返回 **Nothing** 。*

*我们定义了一个总是返回其参数的函数(我们很快就会知道为什么)，以及一个名为 **defaultColor** 的新变量。*

*最后，我们修改了 **namedColorToHex** 函数，使用 **safeProperty** 代替 **property** (记住 compose goes*right-to-left*，或者在本例中， *down-to-up* ) **，**，这意味着我们从另一端得到了**可能是**。正因为如此，我们需要使用**映射**函数定义在**也许**上来改变这个值，记住，如果这个值是 **Nothing** 什么都不会发生！所以我们将所有其他转换包装在一个映射中，最后我们可以调用 **extractMaybe** 来提取值。Nothing 情况返回一个函数，它给我们提供了 **defaultColor** ，而 **Just** 情况给我们提供了通过 **identity** 函数运行的值，这就是……嗯，就是这个值！*

*我第一次碰到这种代码时的反应是一种惊愕；我非常习惯于使用这些 try/catch 块、空检查和非线性代码来处理错误，这些代码会将所有东西都分成 if/else 块。现在有一个函数包装了错误处理，甚至更好的方式是让我们以线性方式推理代码。条件的处理只是转换链中的又一步！*

## *集装箱中的集装箱*

*想象一下，如果你必须深入一个物体。如果你每次都使用 safeProperty，你将会以**可能**在**可能**中结束。示例:*

*这可能会失去控制；不知不觉就在跑 *map(map(map(xyz)))，*这是不可持续的。我们需要一种方法把那些**的可能**变成一个单一的**的可能。**幸运的是，FP 远远领先于我们。*

> *旁注:翻转函数参数的想法很常见。如果你在家玩，为什么不试着写一个名为 **flip** 的函数，它接受一个带两个参数的函数，并返回该函数的翻转版本。*

*在函数式编程中，这种思想叫了几个名字，有时叫 flatMap，有时叫 chain，但我认为最清楚的是 **flatMap** 。基本上就是说，在返回另一个容器的容器中运行一个函数，然后将这两个容器合并成一个。那种两个想法对——先**贴图**，再**展平**。以一个数组为例， **flatten** 只会说如果我有一个数字数组，那么就把它变成一个数字数组。让我们实现 **flatMap** for Maybe。*

*非常简单，虽然我应该说这不是你可能称之为坚如磐石的实现！所以现在如果我们知道我们正在运行一个返回**也许是**的函数，那么我们只需**平面映射**而不是**映射**，瞧！不再有集装箱中的集装箱。*

*因此，在某种程度上，我们通过为**或许是**类型配备一些像 **map** 和 **flatMap** 这样的接口，让它成为一个更强大的工具。这种类型我们称之为[代数数据类型](https://en.wikipedia.org/wiki/Algebraic_data_type)。当你遵循一定的规律时，这种类型有一些非常有趣的性质。*

*你可以为一个类型配备很多接口。这不是没有原因的代数——你可以写方程，关于这些不同的接口如何根据彼此来写。例如，我们将 **flatMap** 写成 **map** ，然后**展平**(有时也称为 **join** )。但是你实际上可以先写 flatten 函数，从 **flatten** 和 **map** 构造 **flatMap** 。如果你写 **lte** (小于或等于)，你可以自动导出每隔一个的比较函数。*

# *结论*

*所以我们已经看到了我认为的函数式编程的两大思想——函数组合和类型。最重要的是，我们已经看到了如何将它们结合在一起。如果你一直跟进到现在，你已经有足够的理解走出去学习所有这些晦涩难懂的术语，更深入地了解代数数据类型的规律和关系，以及如何在函数组合方面编写一个完整的程序。*

*如果你有兴趣了解更多，我认为布莱恩·朗斯多夫的《函数式编程基本指南》 是一本很棒的书。它在更深但仍可理解的层次上介绍了本文中的所有内容。他在网上也有很多精彩的演讲，可以帮助你掌握 FP 的一些更具体的方面。*

*为了使用这种方法制作完整的 javascript 应用程序，我在[wearereasonablepeople](http://wearereasonablepeople.nl/)[Aldwin Vlasblom](https://github.com/Avaq/)的同事编写了一个名为 [**Fluture**](https://github.com/fluture-js/Fluture) 的惊人的库，它让你能够以函数式风格处理异步，并提供了一种替代承诺和可观察性的方式，用它编程感觉很棒。*