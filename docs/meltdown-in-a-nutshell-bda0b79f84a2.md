# 简而言之，彻底崩溃

> 原文：<https://medium.com/hackernoon/meltdown-in-a-nutshell-bda0b79f84a2>

## 例外、渴望和电子

![](img/4cdef980bcbefc1d4da20d94c78e00f0.png)

## 例外是起点

考虑这个伪代码:

x = read(memory _ location _ of _ OS _ where _ secret _ lies)//将导致异常

y = arr[x *4096] //根据 x 读取一些其他本地内存

## **CPU 的急切**

但是，第一行是一个例外，它不应该读取操作系统(OS)内存。由于在微操作中指令被中断的优化，在系统发现这是非法访问并清除/删除/清除 x 的值之前，x 仅包含神圣的 OS 存储器的一小部分时间。

与此同时，信不信由你，下一行代码已经准备好执行了，而且在操作系统清除 x 的值并引发异常之前就已经执行了。因此，如果 x 的值是' s '，那么内存 arr['s' * 4096]将被 CPU 访问。

## 电子产生热量

在 x 被清除后，y 的值也将很快被清除，因此攻击者无法再读取 x 或 y。为了知道 x 的值，我们将检查缓存行，并以某种方式猜测 x 应该是什么。对 arr['s' * 4096]地址的后续访问将激活高速缓存命中中的特定位。通过检查所有高速缓存地址中哪个地址是“热”的，我们可以找到“s”的值* 4096。然后我们做简单的数学运算，得到 s。接下来，我们一次又一次地这样做，得到' e '，' c '，' r '，' e '，' t '。