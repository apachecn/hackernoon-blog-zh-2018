# C/++中的负索引多数组

> 原文：<https://medium.com/hackernoon/negative-indexing-multi-arrays-in-c-b551ce252972>

## 一个方便的谎言——C/++中的多数组

*灵感来自* [*【格兰南·卡尼*](https://blog.feabhas.com/2016/12/a-convenient-untruth/) *的《一个方便的谎言》。*

当在 C/++中声明一个多数组(多维数组)时，我们得到的是一个连续的内存块。这个内存块跨越了所有维度的乘积的大小。

对于一个 2×3 的数组`arr[2][3]`，我们得到一个 6 单元的内存块。我说单位而不是实际大小(以字节为单位),因为大小会根据数组的数据类型和机器架构而有所不同。

当我们查询数组(即访问元素)时，我们执行指针算法来从单个 6 单元内存块中提取值。

```
int arr[2][3] = {11,22,33,44,55,66};
cout << arr[1][1]; // 55 int *ptr = &arr[0][0];
cout << *(ptr + 1*3 + 1*1); // 55 data      11  22  33  44  55  66
address  100 104 108 112 116 120
           ↑               ↑
         ptr            ptr+4
```

这让我想知道——我能回到过去吗？

# 负索引

现在有趣的部分来了。在上面给出的 2x3 整数数组中，如何查询数字`33`？显而易见的答案是`arr[0][2]`。这是正确的。

在指针中，它变成了`*(ptr + 0*3 + 2*1)`，也就是`*(ptr + 2)`。那么接下来的问题就是:我们有多少种方法可以让`x * 3 + y * 1`等于`2`？换句话说，对于`x`，`y`的什么值，等式`3x + y == 2`成立？

以下是解决方案的示例:

```
x  0  1  2 -1 -2 ...
y  1 -1 -4  5  8 ...
```

我们可以使用这些`(x, y)`对中的任何一个来查询数字`33`:

```
int arr[2][3] = {11,22,33,44,55,66};cout << arr[0][2];  // 33
cout << arr[1][-1]; // 33
cout << arr[2][-4]; // 33
cout << arr[-1][5]; // 33
cout << arr[-2][8]; // 33 data      11  22  33  44  55  66
address  100 104 108 112 116 120
           ↑       ↑
          ptr    ptr+2
```

这种行为适用于所有维度为`n`的多[数组](https://hackernoon.com/tagged/arrays)。唯一的问题是，在 3D 和以上阵列中可视化这个原理变得相当麻烦。幸运的是，我做了一个很小的工具来帮你做这件事:)

这个工具有助于创建一个多阵列高达 5D 阵列，每个“水平”可以容纳多达 4 个“细胞”。生成数组后，您可以对其运行查询，该工具将突出显示用于得出[输出](https://hackernoon.com/tagged/output)值的内存单元。

***注:*** 我所说的“水平”和“细胞”的意思稍后会解释。

# 展示和讲解

为了更好地解释，我将使用下面的 2x3x2 数组的内存映射。看一看它，让自己相信下面的等式`arr[0][2][0] == arr[0][0][4] == arr[1][0][-2]`

```
 _____________________________________________________________
|        | L0 |           0           |          1            |
|        |----|-----------------------------------------------|
| Memory | L1 |   0   |   1   |   2   |   0   |   1   |   2   |
| Levels |----|-----------------------------------------------|
|        | L2 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 |
|=============|===============================================|
|  Data Level | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10| 11| 12|
 ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
```

另外，我使用了函数`PROD()`和`SUM()`，它们给出了一个数组范围的乘积和总和。

```
prod(i, [a..b], arr) = arr_a * arr_(a+1) * ... * arr_(b-1)
prod(arr) = arr_0 * arr_1 * ... * arr_(n-1)sum(i, [a..b], arr) = arr_a + arr_(a+1) + ... + arr_(b-1)
sum(arr) = arr_0 + arr_1 + ... + arr_(n-1)where n = size of array
```

## 单元格和级别

这两个术语都是虚构的。这些只是我用来指代特定内存位置的符号。

一个**存储单元**只是一个可以被指针或数组索引指向的存储单元。当我们访问元素`arr[0][2][1]`时，我们以数据值`6`结束。

但是`[0][2][1]`代表什么呢？我回答说它们是指向“记忆细胞”的指针。一种解读方式是:

```
* access 0th cell in the block
* access 2nd cell in the 0th cell
* access 1st cell in the 2nd cell
* retrieve the value
```

**内存级别**是驻留在相同内存维度中的内存单元的集合。

## 观察

最初的观察是比较明显的:

*   维度计数:`**N** = 3`
*   尺寸规格:`**D** = [2, 3, 2]`

如果我们访问`arr[1][2][1]` ，那么查询将是:`**Q** = [1, 2, 1]`

## 单元格跨度

站在`ith`内存级别，如果我移动 1 个单元，数据级别的跳跃大小就是该内存级别的**单元步幅**。

各级的单元格跨度为:

*   L0: 6 = 1*2*3
*   L1: 2 = 1*2
*   L2: 1 = 1

这为我们提供了这样的关系:对于`ith`内存级别，步长是该级别以上所有维度大小的乘积。

```
S_i = 1 * prod(j, [i+1..N], D)
or
S_i = S_(i+1) * D_(i+1)
```

## 查询匹配(M)

当我们运行一个查询时，我们在每一层匹配一个存储单元。这形成了跨越级别的跳转链**，在数据级别结束，并产生数据值。**

这为我们提供了以下关系:对于`ith`存储级别，匹配单元为:

```
M_i = (1 / S_i) * sum(j, [1..N], S_j * Q_j)
or simply
M_i = (1 / S_i) * sum(S_j * Q_j)
```

不幸的是，我的这段感情之旅很难解释清楚。所以我就直接跳过了。

我使用这个值(查询匹配)来突出显示查询产生的存储单元和最终数据值。

## 混杂的

**细胞计数**:在`ith`内存级别
`**C_i** = prod(j, [0..i], D) = C_(i-1) * D_i`中的细胞数量

**数据计数**:存储的数据值总数
`**n** = prod(i, [0..N], D) = prod(D)`

通过比较关系`C_i`、`S_i`和`n`，得到关系`n = C_i * S_i`，因为:

*   `n = prod(i, [0..N], D)`
*   `C_i = prod(j, [0..i], D)`
*   `S_i = prod(j, [i+1..N], D)`

# 结束了

C/++允许在多数组中使用负索引，因为它只是一个连续的内存块，索引查找只是指针运算。
那里。那是你现在知道的事情。

你可以在这里或者在[代码笔](https://codepen.io/zhirzh/pen/yKPNjo)上找到代码[。](https://gist.github.com/zhirzh/aa02be34407eebe8998d2ff35946cdc9)

此外，如果你想知道在其他语言中是否可能，答案是“视情况而定”。将多数组实现为真正的多数组(数组的数组)的语言不能有负索引。像 C/++这样实现多数组的语言*可能*支持它。

# 奖金

假设我们有一个整数数组`arr[3]`，我们访问元素`arr[1]`，我们得到什么？我们得到了第二个值。那没意思。

*有趣的是*编译器如何通过将查询重写为`*(arr + 1)`来解决这个问题。这是简单的指针加法。因为加法是可交换的，我们可以…

```
arr[1]     -> *(arr + 1)
*(arr + 1) -> *(1 + arr)
*(1 + arr) -> 1[arr]
```

…并得出结论`arr[i]`与`i[arr]`相同。这一点对于多阵列也是正确的。

```
int main () {
  int arr[2][3] = {11,22,33,44,55,66};cout<<arr[0][2]; // good
  cout<<2[0[arr]]; // bad
  cout<<2[arr[0]]; // also bad
  cout<<0[arr][2]; // ???
}
```

从那里来的还有很多。查看格兰南·卡尼的文章
[【一个便利的谎言】](https://blog.feabhas.com/2016/12/a-convenient-untruth/)。