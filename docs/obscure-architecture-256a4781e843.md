# 晦涩的建筑

> 原文：<https://medium.com/hackernoon/obscure-architecture-256a4781e843>

![](img/950612698472d3737a0c996075230d01.png)

[source](https://static.pexels.com/photos/1404/nature-night-dark-tree.jpg)

在[之前的一篇文章](https://hackernoon.com/let-the-code-speak-52d1cebf0394)中，我们讨论了编写表达性代码的重要性。表达性使得我们的代码更容易理解。新开发人员可以添加新功能或修复缺陷，而无需花费太多时间来试图解密原作者的想法或他们为什么最终会有一个特定的解决方案。代码应该尽可能清晰地反映作者的决定。

当我们提高抽象层次时，所做的决定变得很重要。在架构级别，每个组件的存在以及它与其他组件的通信方式应该对团队的每个开发人员都很清楚。正如*马丁·福勒*在[中所说，“谁需要建筑师？”](http://files.catwell.info/misc/mirror/2003-martin-fowler-who-needs-an-architect.pdf)，对系统的共同理解与架构高度相关。归根结底，这一切都与沟通有关。

一个架构应该指出它的意图，以及所有响亮而清晰的决策！在本帖中，我们将讨论决策沟通不畅的架构所存在的问题。我们称这样的架构*晦涩难懂。*

# 架构不断发展

久而久之，我们系统的需求经常变化。例如，如果一个企业成功了，那么系统的容量可能需要增加。此外，随着时间的推移，我们对系统如何工作的理解也越来越好。因此，架构不断发展。

通过发展，我们过去做出的架构决策可能会改变。这是很平常的事情。一个原型从微服务架构开始是没有意义的。不仅早期采用微服务架构的成本非常高，而且我们创建原型时的关键要求通常是灵活性和速度。微服务解决非常具体的问题，通常，这些问题在原型阶段都不重要。关于这个主题的一个不错的帖子是由 Randy Shoup 撰写的。

如果原型成功，这些需求将会改变。架构师所做的决策应该在现在需要什么和这些选择对未来的限制程度之间取得平衡。我们的目标是尽可能多的选择。关于这个主题的更多信息(以及软件架构的总体情况)请见这本令人惊奇的书:[干净的架构:软件结构和设计的工匠指南](https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164)作者:*罗伯特·c·马丁(鲍勃叔叔)*。

由于将来可能会再次讨论这些决定，因此对它们进行良好的记录非常重要。团队的每个成员都应该能够说出为什么系统的架构处于当前状态。

这是[康威定律](https://en.wikipedia.org/wiki/Conway%27s_law)适用的另一个例子！

# 黑客们。

在系统生命周期的某个时刻，架构师可能会决定处理问题的最佳(或者唯一)方式是进行某种黑客攻击。我们在这里使用术语 hack 来指代不遵循“标准”模式的解决方案。如果一个系统中的所有用例都使用相同的模式实现，那么一个以不同方式实现的用例就是黑客。工具(库、框架等)也是如此。)那我们用。如果一个工具在系统中以某种方式被使用，而在某些情况下它被改变以不同的方式工作，那么它也被认为是黑客。黑客是系统中常用规则和模式的例外。

这种攻击包括以非预期的方式拦截和更改框架或库的行为，使用反射等专门功能，修改框架的源代码并构建其自定义版本，甚至从头编写一个框架来提供定制的解决方案。后一类很容易在生命周期长的项目中找到。在某些情况下，这些技巧可能是解决特定问题的最快(或唯一)的方法，所以当我们想要快速工作的东西时，弄脏我们的手也是可以的！

但是，这种解决方案在大多数情况下是复杂的。仅仅看代码是不容易判断这些解决方案的意图的。更难讲的是，将来它们如何被更方便的解决方案所取代。当我们使用流行的框架或库时，我们得到的最大好处之一就是我们可以免费获得文档！当我们构建一个定制的解决方案时，我们必须向用户提供类似的东西。

复杂解决方案的问题是，读者必须经历最初作者走过的路。解决方案是问题解决过程的最后一步。读者几乎不可能走过完全相同的道路并建立相同的理解。因此，带有隐藏黑客的系统很难维护。因此，对于复杂的黑客来说，有必要解释它们的存在，而不是隐藏在代码中。此外，黑客应该以一种易于处理的方式开发。一旦情况允许，例如，一个更好的标准解决方案出现，或者我们意识到有一个更好的方法来解决我们的问题，黑客应该被取代！我们不希望有一个充满黑客的系统，没有人(或只有少数人)知道他们在做什么！

# 一些黑客解决方案的例子

例如，让我们假设我们想要使用一个提供某种外来数据结构的库，但是这个 API 不是线程安全的。我们可以考虑包装 API，并用我们的线程安全逻辑丰富它，使数据结构符合我们的用例。但是如果这个库的未来版本提供了我们以前想要的线程安全 API，那会怎么样呢？现在线程安全逻辑被复制了。

此外，当新开发人员看到一个与库完全相同的包装器时，他们可能会感到困惑。他们将无法判断包装器的意图。更糟糕的是，如果没有好的文档来说明包装器到底解决了什么问题，他们将不能完全确定逻辑是否是重复的，是否可以安全地删除。包装器将永远存在于项目中！当然，在这种情况下，测试可以挽救局面，因为测试可以验证 hack 的行为，因此可以放心地替换它。

上例中的包装器不仅影响性能，还会给系统架构增加一些噪声。这种噪声会影响系统中组件意图的传达。在[“累积代码”气味](https://hackernoon.com/cumulative-code-smell-6d5344646c46)帖子中，我们讨论了沟通中的问题如何影响我们代码的质量。

Hacky 解决方案也是为了提高性能。对于一个架构师来说，改变*一些*组件相互交互的方式来获得更好的性能是不常见的。这样的变化会导致系统形态的改变。后来看到该系统的人可能会对某些组件的神秘通信方式感到困惑，而其他组件则以“标准”方式进行通信。这种解决方案应该以某种方式记录下来；否则，建筑就是*晦涩的*。

# 沟通影响可维护性

一个充斥着黑客解决方案的系统很难维护和扩展。每个黑客或快捷方式的意图都应该被很好地描述。架构师应该描述他们解决了什么问题，检查了其他哪些候选解决方案，以及为什么在这些解决方案中选择了当前的解决方案。这是至关重要的，因为黑客是技术债务，需要在某个时候支付；否则，系统最终会在技术债务上违约(更多关于技术债务应该如何处理，在以后的文章中)。因此，黑客应该很容易处理，以避免增加技术债务。

同样，系统的每一个框架和库都应该小心使用，这样它们才不会“污染”我们的架构，黑客和快捷方式也必须小心对待。一个好的架构师应该消除黑客和快捷方式给系统带来的所有干扰，这些干扰会使交流变得很糟糕。如果一个问题的解决方案不明显，应该有一个好的理由！

我遵循的经验法则是:当你试图解决一个问题时，避免制造新的问题。如果这是不可避免的，为这个决定提供一个非常分析性的描述。描述当你做那个决定的时候是什么情况，有什么选择，这个决定产生了什么样的新问题。这种描述可以是代码中的注释，也可以是我们的问题跟踪系统中与提交消息相关联的标签，甚至可以是 wiki/confluence 页面，当然还有一个验证“不常见”决策行为的完整测试套件，因此将来可以很容易地替换它。

在[“让代码说话！”](https://hackernoon.com/let-the-code-speak-52d1cebf0394)，我们看到代码中的噪声使得我们的代码更难维护。在这篇文章中，我们描述了为什么架构中的噪声会降低整个系统的可维护性。显然，一个晦涩的方法或模块的维护成本要比一个晦涩的架构的维护成本低得多。

*抽象层次越高，沟通不畅的维护成本越大。*

# 进一步阅读

1.  [干净的架构:软件结构和设计的工匠指南](https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164)作者*罗伯特·c·马丁(鲍勃叔叔)*
2.  [“谁需要建筑师？”](http://files.catwell.info/misc/mirror/2003-martin-fowler-who-needs-an-architect.pdf)作者*马丁·福勒*
3.  [康威定律](https://en.wikipedia.org/wiki/Conway%27s_law)
4.  [进化架构](https://codeburst.io/evolutionary-architecture-27dae14b323d)由[兰迪*寿普*](https://medium.com/u/2af66a8472ae?source=post_page-----256a4781e843--------------------------------)
5.  让代码说话！
6.  [“累积码”气味](https://hackernoon.com/cumulative-code-smell-6d5344646c46)