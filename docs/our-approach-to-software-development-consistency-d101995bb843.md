# 我们的软件开发一致性方法

> 原文：<https://medium.com/hackernoon/our-approach-to-software-development-consistency-d101995bb843>

## 不要记录您可以自动化的东西

访问 https://www.mikenikles.com 的[](https://www.mikenikles.com)****获取我的最新博文。****

***这篇博文是我分享我们从部署在 AWS 上的单片应用程序(每个都有自己的源代码库)迁移到部署在 Google 云平台上的分布式服务架构(所有源代码都托管在 monorepo 中)的系列文章的一部分。***

*   ***第一部分:* [*一个 monorepo，GitHub 流和自动化 FTW*](https://hackernoon.com/a-monorepo-github-flow-and-automation-ftw-c41a2d9c48bb)**
*   ****第 2 部分:“* [*一对多——为什么我们从多个 git 回购转移到单一回购，以及我们如何设置它*](/@mikenikles/one-vs-many-why-we-moved-from-multiple-git-repos-to-a-monorepo-and-how-we-set-it-up-f4abb0cfe469)*”****
*   ****第三部分:*[](/@mikenikles/a-mostly-automated-release-process-63bb9516985a)***
*   ******第 4 部分(本文):“我们的一致性方法和对开发者体验的关注”******
*   *****第 5 部分(即将推出):“本地调试微服务”*****

# ****什么是软件开发中的一致性？****

****我认为一致性是成功交付软件不可或缺的一部分。我经常加入或者与很少或者没有一致性的软件团队一起工作。****

****它适用于开发的所有方面:代码风格、注释、工具、入职、新服务的创建。它还扩展到产品管理、定义和跟踪任务，以及一般的公司流程。****

****让我们以我当前项目的“创建新的包和服务”为例，在这个项目中，我们从单一的应用程序迁移到更小的、独立的和分布式的服务。下面是我们如何创建前 3 项服务的:****

*   ******服务 1** : 100%手工制作，试用&误差，很多死角。****
*   ******服务 2** :复制&粘贴服务 1，必要时进行调整，用与服务 2 相关的新业务逻辑替换旧业务逻辑。重复，直到希望一切都以某种方式工作。****
*   ******服务 3** :复制&粘贴……*我们到底在做什么？*****

****你能看出这种一致性吗？正确，*复制&粘贴*看起来相当一致。当花了一周时间建立服务 1 的人离开时会发生什么？谁知道创建服务 8 需要调整什么？想象一下当一个基本错误发生并影响所有服务时的噩梦…👻。****

****现在的问题是，我们如何使这更一致？我问了几个朋友，很多人回答:**记录过程**。****

*   ******服务 1** : 100%手工制作，试用&误差，这里那里几句脏话。****
*   *******记录流程*******
*   ******服务 2** :复制&粘贴服务 1，按照文档清单更新新服务。****
*   ******服务 3** :遵循上述步骤，只要没有任何变化并且文档仍然是最新的🤞。****

# ****不要记录您可以自动化的东西****

****作为一个在软件行业度过了大半辈子的人，我意识到在这个快速发展的环境中保持理智的最简单的方法是编写适合我的脚本。****

****文档是伟大的，只要它是准确的。有些情况下文档是必要的，但是对于我们在这篇博文中讨论的用例(创建新的包和服务)，文档是错误的方法。****

****每一个新的包或服务都有某种形状，在所有其他的包或服务中相当相似，就像每所房子都有某种基础、一些墙壁、窗户和屋顶。****

****想象以下过程来创建 3 个服务:****

*   ******服务 1** :运行服务生成器，提供服务特定值，点击回车。****
*   ******服务 2** :运行服务生成器，提供服务特定值，点击回车。****
*   ******服务 4** :运行服务生成器，提供特定于服务的值，点击回车。****

# ****自动化流程****

****现在让我们不仅想象上面的过程，让我们看看我们是如何在我们的项目中实现的。****

****为了透明起见，我们显然有类似 service 0 的东西，我们手工制作一切，测试服务，部署，调整等等。然而，我们知道我们想自动化这个过程，所以我们从一开始就密切关注。****

****我们选择的工具是[扑通](https://plopjs.com/)。一个流行的选择是自耕农。我们选择扑通是因为它简单，现在它支持 [AddMany](https://plopjs.com/documentation/#addmany) ，它提供了我们需要的一切。****

****我们目前有两台发电机:****

*   ****包裹****
*   ****服务****

****所有模板文件都保存在一个`_templates`文件夹中。目录结构是:****

```
**.
├── _templates
│   ├── packages
│   │   ├── README.md
│   │   ├── iso
│   │   ├── svr
│   │   └── web
│   └── services
│       ├── README.md
│       ├── svr
│       └── web
└── scripts
   └── generators
       ├── helpers.js
       ├── index.js
       ├── packages
       │   └── index.js
       └── services
           └── index.js**
```

****`README.md`模板文件一个用于包，一个用于服务。这确保了每个包(和每个服务)遵循相同的结构。一个`README.md`文件包含任何人对一个包或服务做出贡献的必要信息。****

****再往下，`generators`被定义。生成器入口点和包生成器如下所示:****

****服务生成器稍微复杂一点，因为它们还负责一些额外的服务设置，比如[在 GCP](https://cloud.google.com/deployment-manager/runtime-configurator/create-and-delete-runtimeconfig-resources#creating_a_config) 创建一个 RuntimeConfig 资源、[在 Slack](https://api.slack.com/methods/channels.create) 创建一个通道、[在吉拉](https://developer.atlassian.com/cloud/jira/platform/rest/#api-api-2-component-post)添加一个新组件，等等。****

# ****结论****

****生成器可以很好地捆绑到存储库根目录`package.json`中的 NPM 脚本中，如下所示:****

```
**{
  "scripts": {
    "generate": "plop --plopfile ./scripts/generators/index.js"
  },
  "devDependencies": {
    "plop": "^1.9.1"
  }
}**
```

****现在生成一个新的包只需要`yarn generate`。然后，一个交互式 CLI 引导开发人员回答几个问题。一个很好的特性是，您可以将生成器名称作为一个参数传递，例如`yarn generate service`会将您带到与服务相关的问题。****