# 用 JS 编程:位运算

> 原文：<https://medium.com/hackernoon/programming-with-js-bitwise-operations-393eb0745dc4>

![](img/36d042d788452bbc00a53c50d957f25d.png)

在这一系列文章中，我们从 JavaScript 的角度来看不同的计算机科学主题。我们已经尝试了不同的算法，对一堆数组进行了排序。然而，回到最基本的概念总是一个好主意。

当我说基本时，我指的是它们中最基本的，1 和 0，也称为位。公平地说，我总是忽略位运算，因为我在日常工作中不使用它们，而且可能永远也不会使用。但是对于计算机来说，一切都取决于它们。

理解位和位运算不会让你成为更好的 JavaScript 开发人员。它可能不会对你正在开发的 React 应用有所帮助，但通常会让你成为一名更好的软件开发人员。

你不需要知道所有的事情，事实上你永远也不会记得所有的事情。我在这篇文章中的目标将是涵盖一个人必须拥有的关于位和位操作的最基本的知识。

# 比特是什么？

好的，从技术上来说，对于计算机来说，一切都是 1 和 0。它不处理数字、字符或字符串，只使用二进制数字(位)。这个解释的简短版本是，一切都以二进制形式存储。然后，计算机使用 UTF-8 等编码将保存的位组合映射为字符、数字或不同的符号(ELI5 版本)。

你拥有的比特越多，排列就越多，你能代表的东西就越多。

让我们以 113 这个数字为例。JS 中获取它的二进制形式最简单的方法是这样的:`Number(113).toString(2)`。这会给我们`1110001`。知道一切都只是引擎盖下的比特，我们现在将看看我们如何操纵它们。

很多文章都有十六进制数字的例子。这一次，我们将只看十进制和二进制数。背后的原因是，我觉得这是更直观的理解。当你有疑问时，你可以在一张纸上写下比特和所有的操作，并追踪正在发生的事情。

另外需要注意的是，在 JavaScript 中没有办法直接输入二进制。如果你想将二进制数转换成十进制数，你可以使用`parseInt`函数:`parseInt(1111, 2) // 15`。

# &(和)

很像我们已经在日常编程任务中使用的`&&`逻辑运算符，如果两个被比较的位都是 1 和 0，那么这个运算符将返回 1。它在两边取一个数(数，不是它的二进制形式)，然后逐个比较它们的位。

让我们想象一下。数字`12`和`15`有`1100`和`1111`的二进制表示。让我们对这些数字使用`&`运算符。如果您刚刚注销，您将再次收到`12`。奇怪，那有什么作用吗？

是的，它将`12`的每一位与`15`的相应位进行比较，由于操作者的工作方式，它再次得到`1100`，实际上是`12`。

`&`操作符的一个有趣的技巧是找出一个数字是奇数还是偶数。如果一个数是奇数，它的第一位将总是`1`。因此，我们可以使用`&`并将该数字与`1`进行比较，因此，如果该数字是奇数，则结果总是`1`。然而，我不建议在你的实际代码库中使用它，因为它并不清楚你在做什么。

# |(或)

这个和`||`很像。它用于逐位比较两个二进制数，每次比较返回一个`1`，其中当比较位都是`0`时，至少有一个`1`和`0`。如果我们以前面的例子为例，使用这个操作符`12 | 15`将返回`15`。为什么这样

`1100 | 1111`将为每个再次等于`1111`或`15`的比较返回一个`1`。

# ~(不是)

这是一个按位非运算。在二进制补码运算中，结果是负数。它的作用是将所有位从 1 转换为 0，反之亦然。

然而，如果您退出`~15`，您将会看到结果是`-16`，即使这些位是正确的。这是因为在二进制补码运算中，为了得到一个数的负表示，你首先需要翻转它的位，然后加 1。

你可以在谷歌上找到更好的解释，但这是你需要想当然的事情之一。

# ^(异或)

这种运算符称为异或运算符或异或运算符。像`&`和`|`运算符一样，它接受两边的数字，以不同的方式进行比较。

它将比较相应的位，只有在只有一个`1`时才返回一个`1`。也许这不是一个很好的解释，所以让我们给出一个更直观的解释。`1 ^ 0`将回归`1`。但是`1 ^ 1`会回归`0`。

`^`操作符只在我们比较`1`和`0`的特定情况下返回 1。

# 移位运算符

有两个运算符处理移位— `>>`和`<<`。正如你所猜测的，它们之间的区别在于它们移动数字的位置。

`<<`运算符将一个数的所有位移位`n`次。这里要注意的是，数字移位时出现的空格都是用 0 填充的。

另一方面,`>>`操作器向右移动。这与前面的移位运算符的不同之处在于，它将正数的位填充为 0，负数的位填充为 1。

这里需要指出的是，通常数字的第一位用来表示它的符号。如果是`1`则为负，如果是`0`则为正。因此，右移背后的原因是——它意味着保持我们正在移动的数字的符号。

# 位操作

现在我们知道了操作符是做什么的，让我们看看如何利用它们来操作比特。

假设我们想在给定的位置设置一个位。我们希望从右边数第二个位被设置(为`1`)。这让我们想到了**面具**的概念。掩码是二进制形式的数字，根据我们想要实现的目标，我们只需要将我们想要修改的位设置为`1`或`0`。我们也可以说它们被用作一个标志来定义哪些位要被改变。

如果我们想设置第一位，屏蔽将是`0001`。如果我们想要设置秒，它将是`0010`等等。

一个例子将使这一点更加清楚:

到目前为止，一切顺利。让我们看看如何清除一点——将其设置为`0`。这不会像前面的例子那么简单，因为我们需要保持所有其他位的原样。

这里的区别是，我们希望有一个充满 1 的掩码，并且只在我们希望清除的位置有一个`0`。然后我们使用`&`操作符，它将只把需要的位置设置为`0`。

我们现在知道如何设置和清除位，但如果我们想翻转它呢？我们不知道该位是否被置位，但我们确实希望改变它的当前状态。这是 XOR 的工作。

在这种情况下使用 XOR，因为将它与`1`一起使用可以保证翻转该位的值。

# 结论

这篇文章的目的是覆盖位操作和操作符的基础。尽管我们仅仅触及了表面，但这足以揭开这个话题的神秘面纱，因此你可以独自冒险进入 1 和 0 的世界，进行不同类型的逐位恶作剧。

感谢您的阅读，希望这篇文章对您有所帮助。你可以帮我，按住鼓掌按钮一会儿(双关语)，把这篇文章分享给一个可能感兴趣的朋友！

> **用 JS 编程:**
> 
> **递归**:[https://hacker noon . com/programming-with-js-Recursion-31371 e2bf 808](https://hackernoon.com/programming-with-js-recursion-31371e2bf808)
> **合并排序**:[https://medium . com/@ KondovAlexander/programming-with-js-Merge-Sort-deb 677 b 777 c 0](/@KondovAlexander/programming-with-js-merge-sort-deb677b777c0)
> **二分搜索法**:[https://medium . com/@](/@KondovAlexander/programming-with-js-binary-search-aaf86cef9cb3)