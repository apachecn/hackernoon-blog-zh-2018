# 在脸书建立实时 API 的思考

> 原文：<https://medium.com/hackernoon/reflecting-on-building-real-time-apis-at-facebook-6089f4b7de56>

![](img/94b71f60eac6db8dbd71d9e42269ad43.png)

Real-time APIs stream data from the server to the client over a persistent connection

免责声明:我已经不在脸书工作了。这些意见都是我一个人的。

上个月，我花了一些时间反思我在脸书构建实时 API 时所学到的东西。一个有用的技术脱颖而出:*首先构建空 API*。

考虑一个新 HTTP API 的空端点，它返回状态代码 200 和一个空主体。使用 null 200 API，客户端可以:

*   检查网络连接
*   测量延迟
*   验证访问令牌
*   测试 SSL 证书
*   测试中间缓存层

客户端还可以检测和处理各种故障情况:

*   网络不可用(飞行模式)
*   DNS 查找失败
*   请求超时(重试请求？)
*   洪水响应(503)

注意，我们没有提到*应用数据*。这才是重点。工程团队通常首先关注*功能需求*，其次关注*、*和*非功能需求*。通过省略*应用数据*，空 API 技术迫使我们向后工作，首先面对*非功能性*需求。

至于*流空 API* ，我们需要通过讨论流和请求/响应的区别来建立基础。在流式 API 中，客户端打开到服务器的*持久连接*，该持久连接可以是实际的持久连接(例如 WebSocket)或模拟连接(例如 HTTP 长轮询)。在这个连接的生命周期中，服务器选择何时将数据推送到客户端。

虽然请求/响应 API 可以是有状态的或无状态的，但是流式 API 总是有状态的。例如，在聊天应用中，服务器需要存储至少三种状态:

1.  用户加入了哪些聊天室？
2.  客户端收到的最后一条消息是什么？(如果我们想要连贯的对话)
3.  哪个持久连接会将数据传送给正确的用户？

像 HTTP 这样的无状态应用层协议有极端的健忘症。他们只记得单个请求/响应的必要内容。相比之下，实时 API 在[应用协议层](https://en.wikipedia.org/wiki/OSI_model#Layer_7:_Application_Layer)也是有状态的。也就是说，他们必须记得过去发生的事情。例如，实时协议经常依赖于[发布者-订阅者模式](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)(例如 [MQTT](https://en.wikipedia.org/wiki/MQTT) 和 [Redis](https://redis.io/topics/protocol) )，其中*取消订阅*请求可能仅在它跟随对同一频道名称的*订阅*请求时才有效。

大规模处理这种状态极具挑战性。首先:服务器必须在一致性、可用性、分区容忍度( [CAP 定理](https://en.wikipedia.org/wiki/CAP_theorem))、持久性和延迟之间做出权衡。第二:某些类型的状态，如聊天室成员，必须在网络上同步。如果客户端和服务器对当前用户的聊天室设置意见不一致，结果要么是用户体验不佳，要么是资源泄露。不幸的是，[状态同步很难](https://en.wikipedia.org/wiki/Two_Generals%27_Problem)。第三:客户端缓存通常不具备处理实时数据流的能力。

一个客户端需要多少个持久连接？“一”似乎是显而易见的答案。但是，如果这个单一的持久连接断开，共享该连接的所有数据流将同时断开。话又说回来，也许多重持续连接也不会好到哪里去，比如你的手机进入了一个盲区。关键是，实时 API 比请求/响应 API 复杂得多，部分原因是它们在应用协议层和传输层都是有状态的。

有了这些概念，我们就可以为空流 API 建模了:一个 API，客户端打开一个到服务器的持久连接，但是服务器不推送应用数据。客户可以使用这样的 API 来预测各种各样的成功和失败案例:

成功案例:

*   到达服务器(网络可用，DNS 解析，服务器证书合法)
*   创建持久连接
*   通过持久连接发出请求
*   检测服务器启动的流终止(流结束)
*   关闭溪流
*   关闭持久连接
*   暂停流

失败案例:

*   无法创建永久连接(传输层):网络不可用、DNS 查找失败、请求超时、证书错误、访问令牌错误
*   无法创建数据流(协议级别):未经验证、未经授权、无效请求、泛洪响应
*   连接中断:服务器减载、服务器网关节点故障
*   流中断:连接中断(如上)

流/连接中断的情况特别有趣。被中断的流不可能产生数据，但中断可能发生在传输层和协议层。如果该流向客户端提供重要数据(例如，多人游戏中的玩家健康)，让用户知道发生了什么是很重要的:“嘿，你落后了，坚持住！”。

这个非功能性情况的列表显然不是详尽的，但是它已经显示了当处理边缘情况时，客户需要多聪明。通过首先构建这样的 API，团队可以在构建运行于不可靠网络(如移动网络)上的应用程序时，发现并设计最佳的用户体验。

如果你已经成功地使用了一些 null API 技术的变体，或者你知道更好的方法，我很乐意在评论中听到你的意见！