# Scala 类型类——名称打印机

> 原文：<https://medium.com/hackernoon/scala-type-class-es-the-name-printer-beb0ea4dc4b0>

![](img/b9418aabb405a996f47be383971fa3b6.png)

任何来自 Java 的人都会问什么是类型类，为什么使用它们，以及如何使用。这篇文章并不打算解释如何完全实现类型类，而是展示一个实际的例子，**name-printer。**

在之前的一篇文章[***MapR-DB 的 Scala 对象序列化***](https://hackernoon.com/scala-object-serialization-for-mapr-db-792817d3962d) 中，我们使用了一个简单的 type 类来解决在我们心爱的 Scala 中使用 MapR-DB 时遇到的序列化问题。现在，我们给出一个更简单的例子来展示类型类的 *why* 和 *how* 。

# 名称表示

让我们从陈述正在讨论的问题开始。在这种情况下，我们有一个名为`Name`的业务对象，正如您可能猜到的，它表示一个人的名字。我们可以用下面的类来表示某人的名字。

现在的问题是，一旦我们有了这个需求，我们要如何表示这个对象？

对于那些来自 Java 的人来说，答案很简单，我们需要覆盖`.toString`函数，问题就解决了。实际上，比这要复杂得多。

根据特定的上下文，相同的名称可以用不同的方式表示。例如，`Nicola A Perez`在正式场合可能是`Mr. Perez`，或者在非常社交化的环境中可能是`Nico`。有时，完全相同的名称可能必须被完全寻址，而其他时候(web id)它可能只是`anicolaspp`。

如果我们试图将表示附加到`Name`对象本身，我们肯定会每次都很短，因为总会有我们没有考虑的上下文。

这个想法是解耦对象及其可能的表示，同时启用多态机制在需要时将它们紧密结合在一起，即使我们无法访问类本身的原始源代码。

# 可打印类型类

我们可以从定义一个特征开始，这个特征表示我们将在这个例子中使用的类型类。

在上面的代码片段中，我们已经定义了可能的表示的接口，现在让我们看看如何实现其中的一些。

如我们所见，我们添加了多种方式来表示名称。现在我们可以在不同的上下文中使用它们。让我们定义一些函数，每个函数接收一个名字并打印出来。注意，每个函数代表上下文本身。

重要的是要注意，每个函数都知道上下文，并使用它来获得正确的打印机，以便根据函数表示的上下文正确地表示名称。

有趣的是，我们给`name`对象添加了`.asString`函数。仅当给定类型的相应隐式存在时，此即席功能才可用。添加发生在编译时，Scala 编译器能够查看上下文以选择可能的类型添加。

最后，我们可以看到所有的事情是如何一起发生的。

# 结论

Scala 强大的类型系统允许超越我们在 Java 或大多数编程语言中所能做的任何事情，同时在编译时保持类型安全。

在我们的特殊情况下，类型类也是一种非常好且有趣的方式，可以在不修改原始代码的情况下向现有对象添加功能。在 Java 中，使用继承可以部分地做到这一点，但是这个问题并没有完全解决，而且在大多数情况下，如果类型被标记为 final，这甚至是不可能的。

最终，我们将动态地向我们的对象添加功能，并且只有当我们启用正确的上下文时，该功能才可用。同样，这远远超出了您在大多数编程语言中所能做的任何事情，尤其是在类型安全领域。