# swift 中的单例对象创建

> 原文：<https://medium.com/hackernoon/singleton-object-creation-in-swift-b249d2f0d594>

在 swift(iOS)中，Singleton 类将仅实例化一次，并将在整个应用生命周期内存中。因此，我们可以说，在应用程序生命周期中的任何给定时间点，只使用了 singleton 对象的一个实例，它提供了从项目中的任何位置访问它的全局访问点。

所以它有全局访问权，如果在项目中开始使用许多单例对象，那会给我们带来很多麻烦。例如，你有一个单例对象来改变你的应用程序中某个特定屏幕的字体，你不可能知道这个改变是在哪里被触发的(从哪个控制器),你在不同的控制器中分配多个字体给单例对象。这就导致 app 出现了很多 bug。

单身显然是有原因的，有时候他们是你的最佳选择。如果你需要控制对共享资源的访问，比如应用程序设置或钥匙串，singletons 是一个完美的选择。

为了不损坏我们的数据，我们需要控制 singleton 中的写访问。我们可以做到这一点的方法之一是提高调度障碍。调度屏障将确保一段代码被执行，并且当它被执行时，没有其他代码被执行。这一点非常重要。有了这个简单的 GCD 标志，我们就能解决我们的问题。

例如:

> MyClass 类{
> 
> *private init() {}*
> 
> **public static let shared = my class()**
> 
> func some function(){
> 
> }
> 
> }

像上面的例子那样创建一个单例是很好的，并且是线程安全的。它将被实例化一次，并将在应用程序生命周期的所有时间内存中。有时候我们不使用它，那么它存在于内存中又有什么用呢？。这种方法的缺点是，即使从未使用过，类 get 也会加载到内存中。

请注意，在上面的例子中，它有私人初始化器，以限制对象创建，即使是在应用程序的其他部分意外。这确保了我们只有一个实例。

为了在需要的时候将单例实例加载到内存中，我们需要使用 lazy 关键字来创建它。一旦创建，它将驻留在内存中，直到应用程序终止。

假设上面的单例对象被两个线程访问，这两个线程稍微一个接一个地运行。在这种情况下，单例对象可能有机会被创建两次。因此，为了解决这种重复或多重创建，我们在创建对象时设置了障碍来停止所有当前正在运行的任务。它可以确保在 iOS 的多线程环境中，任何情况下都只能在应用程序中创建一个对象。

— — — — — — — — — *********************** — — — — — — — — —

如果你喜欢我的教程请关注我的 ***中*、** [***推特***](https://twitter.com/Leelakrishn4)&[***linkedIn***](https://www.linkedin.com/in/leela-prasad-penumutchu-b44023157/)*账号*

*感谢阅读…*

*****************************!！！再见！！！*****************************