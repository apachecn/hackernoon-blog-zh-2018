# 关于退货单的几点思考

> 原文：<https://medium.com/hackernoon/some-thoughts-on-the-return-statement-9d99771f2838>

![](img/7d6cadab144da06d53b471edc64339c3.png)

首先，javascript **返回**是一个语句。不是功能。

从表面上看，语句和函数是 javascript 引擎“做某事”的命令。然而从技术上讲，它们是不同的。一个**语句**是一个不返回值的命令。

一个**函数**可以在 javascript 环境中的任何地方被调用——不管它在哪里被定义——并且它经常被用来返回值。程序中的函数是子程序。

> **子程序**是执行特定任务的程序指令序列，打包成一个单元。这个单元可以在程序中任何需要执行特定任务的地方使用。
> 
> -维基百科

***return*** 语句结束一个函数在 JS 环境中的执行，并用于指定一个值(对象、数组、变量)返回到该函数的调用者范围。

在这上面会发生什么？

尤其是我们的退货单。

**解释功能的伪代码**

1.  我们初始化用户变量，将其声明为用户数组。这些元素是带有道具的物体本身。
2.  第二行是一个从零开始的计数器
3.  一个过滤函数，它将根据我们在函数中定义的条件创建一个新的数组。
4.  注意到箭头功能了吗？折叠我们的函数，使其易于阅读(如果函数中的条件使用箭头会更简单，那么至少会缩短两行)。不仅如此，它已经能够处理那些怪异的**。【绑定(本)】**情况。

让我们来讨论一下箭头函数

你能看到哪些东西？代码更短，而且没有绑定调用就“工作”。

在这篇文章的最后，我写了一篇关于 ES6 箭头功能的短文。

TL；DR ES6 arrow 函数语法将总是覆盖任何先前绑定或动态确定“this”的值，以及它对引擎和代码的重要性。

**

5. ***最后*** ，我们的迭代器根据我们的条件遍历数组，返回少数通过“测试”的元素。网上退货是我们关注的焦点。我们看到两个值被返回给 filter 方法。用户被返回。但状态为“已丢弃”

“状态”不一定会被删除，更像是被忽略了。JS 引擎为什么要这么做？引擎希望元素“e”返回到过滤器方法，所以事实上，当你用 return 语句写一些值或表达式，声明时，return 语句与这个值无关，但是它将继续返回已经通过指定条件的元素。

这是独特的 ES6 方法的特殊行为，这种行为不适用于传统函数。

按照下面的代码。

当代码运行时。这个测试的值是“世界”为什么？

忽略返回后的所有语句(当然是运行它们)和表达式，但选择最后一个声明的值并返回该值。

在函数的末尾，我们返回满足条件的范围内的每个“用户”,但是没有返回 state。如果你不感到惊讶，那可能是因为你明白函数显式返回单个变量。

注意:“this”上下文通过词法范围起作用。运行代码的 JS 引擎将查看包含函数的作用域，并在函数中使用该作用域的“this”上下文。有趣的是，箭头函数的“this”上下文不能被覆盖。不能将其绑定到想要绑定函数的对象。一些开发者认为这是一件坏事。但这令人不安，因为 JS 本应是一种 ***动态*** *和* ***严格*** *语言，同时才能真正意识到这种语言的潜力。在 React 这样的环境中，使用 arrow 函数确实有助于避免组件之间尴尬的绑定，在* **render ** *函数和*函数中绑定这一点以及 arrow 函数动态做的其他事情。所有这些加起来提高了应用程序的性能。