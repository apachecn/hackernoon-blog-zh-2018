# GraphQL 订阅的混合策略

> 原文：<https://medium.com/hackernoon/the-hybrid-strategy-for-graphql-subscriptions-dd5471c45755>

订阅真的很难。这就是它们有趣的地方。GraphQL & Relay 支持它们已经有几个月了，但例子仍然很少。最糟糕的部分？如果你试图在你的大规模应用中实现它们，那些确实存在的使用模式会让你头疼。相信我。

![](img/c521ba0e0643f052ff45f9a137d776f3.png)

经过大量的反复试验，我终于发现了一种模式，它可以随着你的应用程序线性扩展。希望它能让你在开始实时应用程序时免受痛苦。

## 一些背景

圣杯是一个页面，其中每个域状态都实时更新，代码可维护，并且没有过度蚀刻。自从第一次 AJAX 请求以来，情况一直如此。毕竟，伪实时应用已经存在几十年了。你每 5 秒钟发送一个 AJAX 来显示屏幕上的所有内容，然后你就在那里了。问题是真正算的时候，5 秒太长，活动稀疏的时候，5 秒太短。订阅解决了这个问题，因为服务器会告诉你发生了什么变化，而不是无休止地与服务器打交道。

Meteor 是第一个真正利用 LiveQuery 的框架。它跟踪 [MongoDB](https://hackernoon.com/tagged/mongodb) Oplog，并将更改推送到订阅的客户端。RethinkDB 后来通过构建一个本地反应数据库完善了这一点。这两种策略都不错，但是有两个问题:

首先，过度蚀刻:如果你关心一个`Todo`的`content`并且有人改变了`priority`，你仍然在处理整个糟糕的文档。当然，你可以在发送给客户端之前选择单独的字段，但是订阅不能在整个应用程序中重复使用，从那里开始，它会一路向下溢出。

其次，也是最重要的一点，它们受到数据存储方式的限制。如果您关心一个`Team` 以及它们所拥有的 Todos 的数量，您要么需要将该计数反规格化到`Team` 表中，要么您还需要订阅一个`Todo` 计数并将 2 个计数拼凑在一起。后端改变以适应前端？那是代码的味道。

## 输入 GraphQL

GraphQL 用他们新奇的数据转换管道改变了这一切。它甚至可以用于上面提到的那些 **LiveQuery** ，尽管我不推荐它(要了解为什么，我强烈推荐 GraphQL 峰会的[牛逼演讲)。有了 GraphQL，订阅不再受限于它在数据库中的存储方式，因为每个订阅都会触发一个客户端定义的查询。剩下要解决的唯一问题是如何对订阅进行细分。在与许多人交谈、阅读了大量代码并尝试了许多愚蠢的事情之后，我了解到有 3 种方法来划分订阅:**按查询、按实体和按变异**。让我们来看看每一个。](https://youtu.be/BSw05rJaCpA?t=19m30s)

## 每个查询的订阅

人群中的警笛声。你刚刚竖起大拇指，让你的应用程序的一部分反应，这样你就可以围绕单个组件建立订阅。如果该组件的查询中的任何数据发生变化，您的订阅将通过一个漂亮的有效负载让您知道。不幸的是，您的营销团队随后会更改页面的布局，您很快就会发现，随着组件的更改，您的服务器也必须更改。因为增加了一个新的`<Footer/>`而更新 10 个突变和你的订阅是蹩脚的，所以你寻找更好的模式。

## 每个实体的订阅

这种订阅方式最受欢迎。从 PubSub 教材到 GraphQL 示例 repos，你随处可见。这非常简单:如果您有一个突变，它修改了 ID 为`123`的`Team`，那么您就以完美的`Topic.Channel`方式向`Team.123`发布一条消息。简单吧？嗯，直到你称之为`AddTeam`突变。如果你发布到频道`Team.124`，还没有人在听，所以你需要发布到父频道，比如`Team.userId`。另一个听你加入的队伍的频道？不算伟大，但也不可怕。

接下来，假设你有一个`RemoveFromCompany`突变，它将你从每个`Team`中移除，并为每个团队移除每个`Todo`项目。在`Team`和`Todo` 频道上收听的贫穷客户端将接收每个待办事项、团队和公司的 1 条消息；那可是 m*n + m + 1 条消息啊！一个连续快速处理 100 次更新的客户端可能会降到 60fps 以下，但这并不可怕。智能批处理策略可以轻松缓解这一问题。

第三，有趣的是，每个实体的订阅本质上是过度的。想象一个`ChangeTeamName`突变。您只更改了单个字段，但是订阅返回了整个`Team`对象，因为您与其他变体共享它。当然，获取这些字段中的一些可能会很昂贵，但是如果这意味着代码是可维护的，那么什么是有点过度提取呢…

不幸的是，可维护性是一场噩梦，这让我们明白了每实体订阅是坏消息的真正原因:它们传输的是*状态*，而不是*事件*。例如，如果我在一个`Todo`被移除时弹出一个祝酒词，那么`RemoveFromCompany`会触发 100 个祝酒词吗？如果一个用户加入了一个团队，他们是全新的，还是重新激活的？谁加的？当你在电脑上看着同一个网页的时候，是你从手机上发来的吗？那天结束时，我残酷地意识到我需要的不仅仅是国家。我需要这个活动。

在意识到问题是什么之前，我通过将状态和事件分成单独的`Team`和`Event`通道来解决这个问题。我告诉自己，`Team`通道将处理对`Team`对象的更新，而`Event`通道将处理任何祝酒词或一次性消息。随着应用程序的增长和业务逻辑的改变，我意识到`Event`有效负载通常包含整个`Team`对象，我甚至不需要`Team`通道！事实上，`Event`的有效负载几乎与触发它的突变的有效负载相同，然而在这里，我不知疲倦地工作来消除错误，以保持 3 个独立的查询和处理程序返回相同的结果。像个白痴一样。

## 每变异订阅

订阅是一种你不知道自己想要的变化。考虑到这一点，订阅一个突变是非常有意义的。想象一个订阅负载，它看起来与突变负载相同，共享一个处理程序和查询片段。当业务逻辑发生变化时，您需要更新单一的事实来源。

不幸的是，每查询订阅失败是因为它们需要对后端进行不断的更改，而每变异订阅失败是因为它们需要对前端进行不断的更改。想象一下，如果每个突变都有一个通道，就像`ChangeTeamName.123`。任何使用了`team.name`字段的组件也必须订阅它。看起来可维护性的另一个死胡同。

其次，我们还在过度蚀刻。突变负载可能提供了比组件所需更多的数据。例如，`RemoveFromCompany`负载可能包括`teams`，但是您的`TodoList`组件只关心被移除的`Todos`。你是选择过度提取，还是编写第二个处理程序？

## 混合订阅

如果您已经订阅了，您可能会在没有意识到的情况下实现某种混合。要么您有单独的添加/删除/更新订阅并在客户端同时订阅所有 3 个订阅，要么您的订阅有效负载是添加的项目、删除的项目或更新的项目的联合，要么您只获取整个项目而不管其类型(这对于删除的项目来说很棘手！).无论如何，每个实体和每个变异的订阅都缺乏可维护性，并遭受过度提取，但方式相反。回到固定有效载荷订阅的时代，我们必须选择一个。谢天谢地，这就是 GraphQL 拯救世界的地方。我们可以利用每个实体和每个突变策略的最佳部分，创建一种新型的混合订阅，这是以前不可能的，*直到现在* …

![](img/f4af1aba0713d64a68e5a56e0993851d.png)

…开个玩笑！付费墙很烂，中等。

## 如何实现混合订阅

让我们从服务器开始。在`ChangeTeamName`突变中，我们返回一个`ChangeTeamNamePayload`像`team { name }`。我们知道发布到像`ChangeTeamName.123`这样的渠道会让前端开发人员的日子不好过，所以我们改为发布到`Team.123`。为什么要使用基于实体的渠道？因为这是完美的妥协。如果我们将所有内容发布到一个频道，那么我们将向用户发送每一条消息，即使是那些不影响她当前视图的消息。如果她现在不看她的待办事项列表，她可能不关心更新的`Todo`项目！相反，让一个`<Team/>`组件依赖于影响团队的不断变化的突变列表是很残酷的；但是都订阅了`Team`订阅的`<Team/>`和`<TodoList/>`组件呢？是的，这是可以控制的。

接下来，唯一要添加到对`publish`的调用中的是突变名称:`publish(Team.123, {team, type: ChangeTeamNamePayload})`。订阅有效负载只是一个基于具体类型解析该类型的[联合。它太简单了，就像实时应用程序中的贝蒂·克罗克。](https://github.com/ParabolInc/action/blob/002996f0fbbb646fde7e5ca673e25a734f871d52/src/server/graphql/graphQLSubscriptionType.js)

由于变异和订阅返回相同的对象类型，它们可以共享处理程序。因为订阅在服务器上进行分组，所以组件不必这样做。剩下要解决的就是过度蚀刻了。

为了解决这个问题，我将每个突变查询分解成[个独立的片段](https://github.com/ParabolInc/action/blob/002996f0fbbb646fde7e5ca673e25a734f871d52/src/universal/mutations/AddTeamMutation.js#L9-L32)。举个例子，

```
fragment ChangeTeamNameMutation_team on ChangeTeamNamePayload {
  team {
    name
  }
}
ChangeTeamNameMutation {
  ...ChangeTeamNameMutation_team
}
TeamSubscription {
  ...ChangeTeamNameMutation_team
  ...ChangeTeamColorMutation_team
}
```

正如所见，在订阅中，我包含了每个带有 _team 后缀的片段。这并不太难，但是 codemod 可以让它变得更简单。编写每个通道的片段和处理程序非常有意义，因为 1 个变异调用许多订阅通道，1 个订阅由许多变异触发。因为 GraphQL 允许在类型上进行分段，所以这不是问题。即使对于可以返回变化很大的有效载荷的变异(即增加或删除的`ToggleTeam`变异)，你仍然可以使用联合和接口。更好的是，这意味着如果您的所有业务逻辑都在同一个处理程序中。需要为 mutator 干杯，悄悄地更新 mutator 的其他设备上的状态，并向团队的其他成员宣布单独的消息吗？没问题。这是[在生产中的样子](https://github.com/ParabolInc/action/blob/002996f0fbbb646fde7e5ca673e25a734f871d52/src/universal/subscriptions/TeamSubscription.js#L12-L33)。

## 结论

希望这能激发你在你的应用中添加一些实时功能！多亏了 GraphQL，我能够编写使用与我的变异相同的查询和处理程序的订阅，这意味着它们是可维护的，大大减少了过度提取，更好的是，模式可以模块化扩展，所以你可以让你的应用程序一次反应 1 个变异，这应该会让你的老板高兴。研究类似的东西？伸出手来！