# 时机就是一切:理解灾难和幽灵袭击

> 原文：<https://medium.com/hackernoon/timing-is-everything-understanding-the-meltdown-and-spectre-attacks-5e1946e44f9f>

![](img/a06d7ff86cf39606d1a81f49b8ea7e7c.png)

如果你读过今天的科技新闻，你一定听说过新的灾难和幽灵袭击。与大多数攻击不同，这些攻击针对的是硬件缺陷，而不是软件缺陷。虽然计算机安全研究人员显然已经知道了几个月，但他们一直保密——“被禁止”——以便让供应商有机会解决问题。但是谣言在假期周末开始流传，现在秘密已经泄露了。

# 背景

一纳秒是非常短的时间。光和电信号每纳秒传播一英尺。但是对于几千兆赫的处理器来说，一纳秒的时间足以在几个不同的内核上同时执行 3 或 4 条指令。访问内存大约需要 20 纳秒，因此如果处理器必须等待那么长时间，它将在大部分时间处于空闲状态。

处理器设计者采用了两个技巧来避免这个问题。第一个是**缓存**:经常使用的内存区域保存在一个特殊的超高速内存中，它是处理器的一部分，通过一个超高速接口连接。第二种称为**推测执行**:如果一系列指令依赖于来自内存的值，处理器可能会执行**两个选择**，然后，当值从内存返回时，丢弃不需要的选项。这有点违反直觉，因为这意味着处理器肯定在做 50%不必要的工作。但是因为与处理器的速度相比，对内存访问的等待是如此巨大，所以在实践中是值得的。

【Spectre 和 Meltdown 的核心问题是 **即使推测性执行的一组指令被证明是不需要的，运行它们仍然会影响缓存。**这似乎是许多处理器硬件设计的一部分，可以追溯到推测执行的发明。如果您可以让处理器推测性地执行一些代码，读取它不应该读取的内存区域——也许是一个试图读取您的系统密码的网页——代码可能会失败，但它仍然会将数据泄漏到缓存中。

将机密数据放入缓存是不够的。你也必须想办法把它从缓存中取出来。现代处理器提供精确的定时指令，让用户程序计算出哪些数据在高速缓存中，哪些数据在内存中。这使得攻击者能够构建一个“侧通道”，使用缓存在推测性执行的代码和常规代码之间进行通信。没有纳秒精度的计时，这些攻击是不可能的。

# 灾难

在这两个问题中，熔毁更容易理解，也更容易防范。

Meltdown 是用户程序读取操作系统内核内存的一种方式。通常，用户程序没有办法访问这个内存。

攻击代码看起来有点像这样(极度简化):

```
variable x = false*/* Do some operations to make sure x is not in the cache */*if (x) { *// This will fail, but it will take dozens of nanoseconds to 
    // fail if x is not in the cache*    secret_data = read_some_kernel_memory() *// Now, send the secret data to the outside world by using 
    // the cache as a side channel
    // We have ~20 nanoseconds to do something here* send_secret_data(secret_data) *// The program will fail after ~20 nanoseconds and any changes 
    // to main memory will be discarded*
}
```

攻击中最复杂的部分是将数据从投机分支渗透回外部世界。通过精确地定时访问高速缓存来创建这些“侧通道”已经是多年来的研究课题，并且有几种很好的既定方法。

幸运的是，熔毁相对容易预防。通过改变用户程序与内核交互的方式，可以完全取消内核内存与用户程序的映射。有一个适度的性能损失。Linux、Windows 和 Mac OS 显然已经对秘密漏洞披露采取了行动，并在其最新版本中修复了该问题。

# 幽灵

Spectre 使用与 Meltdown 相同的工具，但它更通用，也更难防范。

在 Spectre 中，攻击不是简单地读取不应该读取的内存区域，而是通过传递不良用户数据来迫使“受害者”程序泄露机密。它怎么能这样呢？想象一个程序对一些用户提供的数据执行一个函数。首先，受害者程序检查数据是否有效；然后它对数据进行一些处理。**但是请记住，在检查数据是否有效完成之前，处理数据实际上可以开始许多纳秒。**

处理器在意识到它是坏的之前，根据坏的用户数据推测性地执行。通过非常仔细地构建用户数据并预先设置缓存，有可能迫使受害程序泄漏数据，就像 Meltdown 中一样。

在他们的演示中，谷歌 Spectre 研究人员攻击了 Linux 内核，使用了一个名为 eBPF 的 Linux 内核功能，该功能允许将一个小“脚本”上传到内核中执行。这个脚本被仔细检查，以确保它不会做任何坏事。但是通过非常仔细的设置，这些检查实际上可以在脚本已经通过推测性执行执行之后发生。

尽管最初的演示依赖于 Linux 内核的 eBPF 特性，但它可以为任何接受用户数据的程序或操作系统工作，并且可以在检查完成之前推测性地执行。很难想到*不是*易受攻击的代码。对于 Spectre 来说，没有简单的解决方法。

# 这些攻击对你有影响吗？

这两种攻击都只适用于在你的计算机上运行别人不信任的代码。

对于我们大多数人来说，我们做到这一点的唯一方法是浏览网页，进入有 JavaScript 的页面。主流浏览器已经在限制 JavaScript 执行精确计时的能力，这将使两种攻击都变得不可能。

如果你是一个云提供商，并且你的业务是在你的电脑上运行他人不可信的代码来赚钱，那么你应该非常担心。一个客户可以读取另一个客户的秘密数据！有证据表明，亚马逊和微软已经重启了数千个虚拟机来应用初步修复。

# 为什么袭击花了这么长时间才被发现？

自 20 世纪 90 年代中期投机性处决开始流行以来，这些攻击十有八九是可能的。那么为什么他们花了这么长时间才发现？

许多人认为处理器会泄露秘密信息。[我甚至帮助了一个始于 2008 年的项目](https://dl.acm.org/citation.cfm?id=2556322)。但当时，除了英特尔之外，没有人知道他们的高速缓存和推测性执行算法是如何工作的确切细节。

在过去的几年中，研究人员已经对这些处理器的内部设计进行了足够的推断，使这些攻击成为真正的威胁。[谷歌的博客文章](https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html)详细介绍了他们如何对这些处理器细节进行逆向工程。

现在我们知道了这些细节，这些攻击和其他之前理论上的攻击在实践中是可能的。在安全研究中，正如攻击本身一样，时机就是一切。

# 我们将如何修复它

在短期内，操作系统供应商将使用取消映射修复来防止崩溃。程序可以特别禁止在关键位置的推测性执行，以防止攻击。浏览器可以防止使用高精度计时器将缓存用作辅助通道。我们可以在 Linux 中关闭 eBPF 特性。但这些都不是完整的措施，这些攻击的新变种将绕过它们。

从长远来看，只有一个解决办法:处理器不能让推测性执行的代码影响缓存。但这需要重新设计和更换硬件，这将需要数年时间。

# 参考

[谷歌零项目](https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html)

[厉鬼纸](https://spectreattack.com/spectre.pdf)

[熔毁纸](https://meltdownattack.com/meltdown.pdf)