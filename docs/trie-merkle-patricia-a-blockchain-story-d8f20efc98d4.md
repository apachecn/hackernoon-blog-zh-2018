# 《区块链的故事》

> 原文：<https://medium.com/hackernoon/trie-merkle-patricia-a-blockchain-story-d8f20efc98d4>

我们讲述了帕特丽夏树的故事。

![](img/aa106d53cf66420ccb97e811be8488d3.png)

You’ll see.

# 一.导言

花几天时间和区块链的工程师们在一起，你会开始对某些词汇感到熟悉。特别是“默克树”和“帕特丽夏树”将开始变得…重要起来。你最终会发现这些是整个区块链事件中非常重要的部分…但是为什么呢？它们到底解决了什么问题？

您可能会快速搜索并偶然发现许多解释这些事情的#content，但是在看到看起来复杂的图表时就退缩了。亲爱的读者，不要害怕。在这里我们将解释这些事情，不是用图表，而是用故事。

从哪里开始？我想是开始吧。

# 二。散列表

最初有了**计算机，**向四面八方无限延伸。事实上，很难说甚至有*是*计算机，因为存在意味着不存在，没有什么不是计算机。所以有了计算机，但是计算机是惰性的。T4 什么都没发生。无聊。于是计算机决定创造一个**程序员。**流行。

起初这位程序员不太好，但随着时间的推移，她变得更好了。这个时候没有太多别的事情发生，所以程序员继续工作，为这个世界编写越来越多的东西。动物之类的。过了一会儿，有了很多动物，这意味着要记住很多名字。这是个问题。

程序员想——“我怎样才能记住所有这些动物的名字呢？我希望能够方便地查找我给每种动物起的名字。我可以把所有的名字写在一个大名单上，但是最终查找这些名字会变得很慢。要是我有正确的数据结构就好了。

因此程序员创建了**散列表。**

什么是哈希表？首先，它是将要发生的所有事情的基础，所以我们要花一分钟来讨论它。本质上，哈希表是一种“键值存储”。这意味着对于一个给定的“键”(即一个动物物种)，你可以保存“值”(即动物的名字)。哈希表的主要属性是，当你有一个键时，你可以快速的找到值*，而不管哈希表中还有多少其他的项。在计算机科学术语中，这被称为“常数时间查找”，非常有用，这就是为什么散列表是[“可以说是人类已知的最重要的数据结构】](http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html)。这里有一个例子:*

```
*>>> hashtable.set("dog", "fido")
>>> hashtable.get("dog")
"fido"*
```

*它们是如何工作的？为了理解哈希表，我们不得不暂时离题，谈谈**哈希函数**。哈希函数是一种神奇的秘方，它让一些神奇的事情成为可能。哈希函数是人们在谈论区块链时谈论的“密码学”。哈希函数是合法的。*

*什么是哈希函数？幸运的是，哈希函数很容易理解。它们本质上是微小的机器，接受一些值，摇晃一会儿(想象一个调酒师摇晃一杯鸡尾酒)，然后输出一些其他看起来疯狂的值(一个大数字)。它们的基本属性是:*

*   *对于给定的输入(如“cat”)，您将总是得到相同的输出(如“0x52763589”)*
*   *两个相似的输入(如“猫”和“汽车”)不应有相似的输出。换句话说，给定一个输出，你应该不能猜测输入。*

*这使得散列函数非常有用，因为它们让我们能够安全地处理敏感信息。你有没有想过负责任的网站是如何保护你的密码安全的？他们不储存你的密码，他们储存你的密码散列。当您输入密码登录时，他们会获取您的密码散列，并将其与他们数据库中的密码进行比较。但是如果黑客进入了，他们所知道的只是你密码的乱码——毫无用处，因为他们没有办法知道你的真实密码是什么。*

*它们的另一个用处是制作哈希表。为什么？记住散列函数的输出是一个*数*。所以当你散列这个键的时候，你实际上得到了一个数字，告诉你在哪里可以找到这个值。想象哈希表是一个有 100 个抽屉的柜子。你`hash("dog")`并得到`34`——你去 34 号柜子并得到名字。你`hash("cat")`拿到 89——你去 89 号柜子。无需浏览整个列表——您可以直接跳到终点线。*

*![](img/bca4cbbd8d1315a4fb0d556b06f05065.png)*

*All hail Lord Kallax (src: Ikea)*

*很酷吧？是的，它是。*

*所以程序员有了哈希表，有一段时间一切都很好。甚至很棒！但这并没有持续多久。最终，**程序出现了。***

*起初，他们之间的关系很好:他们分享想法，分享代码，分享空间。但最终乌云出现在地平线上。他们想要不同的东西。程序员可以接受一些随机性，但是程序员需要确定性，他不再喜欢散列表了。他说，它们“不是决定性的”。*

*他是什么意思？为了理解这一点，我们必须多谈一点关于哈希函数和哈希表的内容。首先要注意的是，哈希函数的“范围”(输出可以取的可能值)非常大——取决于计算机，它可以取多达 2 个⁵⁶，但更典型的是 2 个或 2⁶⁴可能值。2 是 4，294，967，296，其他的要大得多。哈希表必须支持这一系列，但是我们不能用那么多抽屉做橱柜，那样就没有空间放其他东西了！所以在幕后，我们做了一点小把戏:我们取杂凑值*模*柜子的大小。模运算(`%`)本质上是除法的助手:它给你*余数*。模的好处是输出(余数)总是在 0 和基数之间——所以无论输入有多大，输出也只能有多大。*

*所以在幕后，我们做了一个有 100 个抽屉的柜子，当决定把`"dog"`的名字放在哪里时，我们查看抽屉`hash("dog") % 100`。因为哈希值是随机的，所以余数仍然是随机的，只是更小。这很好，但是有一个很大的缺点:两只动物可能会在同一个抽屉里！假设`hash("dog")`是`1,000,034`，而`hash("shark")`是`200,034`。不同的值，但取模后都是`34`。所以我们把它们放在同一个抽屉里，我们必须翻遍抽屉才能找到狗的名字。还是很快，因为抽屉里通常只有一两个名字。*

*所以这在实践中很好，但是程序员的观点是你放名字的地方并不是 100%由你使用的散列函数决定的。还有两个因素:橱柜的大小和其他动物！橱柜的尺寸很重要，因为有 10 个抽屉的橱柜会把`72`和`182`放在同一个地方(`2`)，但有 100 个抽屉的橱柜会把它们放在不同的地方(`72`和`82`)。此外，你无法提前知道一个名字是否会单独放在一个抽屉里，或者它是否必须与其他名字共享。*

*这位程序员对此很不高兴，但他以一种健康的方式处理了自己的情绪，并去山里呆了几个星期，思考替代方案。“每样东西都有一个位置，每样东西都在它的位置上，”他不断在脑子里重复着。当他最终下来时，他有了一个新的想法。*

# *三。特里*

*程序员意识到，问题在于我们试图把所有东西都放进一个巨大的柜子里，但这个柜子永远都不够大。程序员说，解决办法是使用一系列*更小的*橱柜。第一个柜子会给你第二个柜子的地址，第二个柜子给你第三个柜子的地址，最后你会找到有你要找的名字的柜子。你可能需要更多的橱柜(但事实证明不是那么多)，而且每个橱柜都可以很小(可能有 16 个抽屉，甚至 2 个！).下面是一个使用 8 个抽屉、3 个机柜系统的示例(总共有 8 = 512 个抽屉):*

```
*>>> hash3("dog")
0x237>>> firstCabinet = trie.find(firstCabinetLocation)>>> secondCabinetLocation = firstCabinet.drawer(7).contents
>>> secondCabinet = trie.find(secondCabinetLocation)>>> thirdCabinetLocation = secondCabinet.drawer(3).contents
>>> thirdCabinet = trie.find(thirdCabinetLocation)>>> thirdCabinet.drawer(2).contents
"fido"*
```

*注意，每个数字都告诉我们要打开哪个抽屉，每个数字都意味着多了一个柜子。程序员称这个系统为“ [Trie](https://en.wikipedia.org/wiki/Trie) ”(如 re **trie** ve)，并说它的妙处在于你不需要一次组装所有的橱柜——你可以只从一个橱柜开始，只在第一次需要的时候，在有空间的地方组装新橱柜。虽然这意味着要做更多的工作(打开更多的抽屉)，但每个名字都会有一个专用的抽屉，总是在同一个地方。程序员知道没有人会需要所有的抽屉，所以大多数橱柜都不需要建造(尽管你不能排除这种可能性)。*

*程序员看了看特里树，同意这是一个聪明的想法(尽管它需要走更多的路)，而且它们之间很和谐。*

*几年过去了，一个新的**人**开始出现在附近的山谷里。出于好奇，程序员和程序员去拜访这些人，了解他们的文化。他们发现这里的人很有趣，一种好奇的宗教围绕着对特定排列的花岗岩雕刻的崇拜。*

*![](img/aa106d53cf66420ccb97e811be8488d3.png)*

*A particular arrangement of blocks (src: public domain)*

*人们非常友好，在与他们的一些牧师会面后，程序员和程序员了解到这些人曾经是好战的，但经过多年的冲突后，他们发展了一种新的“信任”系统，这使他们能够在非凡的和平与繁荣中共存。他们说，计算机只能和程序员一样好，人类不能被信任独自编程。这些人知道散列表和 trie 树，但他们发现人们会作弊:有时人们会在夜里进来，更改抽屉里的名字；没有办法证明抽屉里的名字是正确的。有一段时间，这些人有一个战士阶级谁守卫内阁，但发现这只会导致更多的冲突。*

*最终，他们的一些最熟练的工匠发展了雕刻花岗岩块的技术；他们意识到这些木块很难雕刻，所以刻在这些木块上的东西可以被信任，而柜子上的名字却不能。然而，把每个名字都刻在积木上，当名字改变时再刻新的积木是不可行的。他们说，他们需要的是用某种方法在木块上刻上名字的签名，这样，如果任何一个名字改变，签名也会改变；但是如果名字相同，签名也总是相同的。最终，他们的一位科学家 Ralph 开发了一个解决方案:Merkle 树。*

# *四。默克尔树*

*Merkle 树的行为很像 Trie 树，但是有一个新的规则:每个橱柜的抽屉将不包含下一个橱柜的位置，而是包含下一个橱柜的所有内容的*散列*。另外，我们跟踪每个机柜的位置(首先使用一个简单的散列表):*

```
*>>> hash3("dog")
0x237>>> firstCabinetLocation = hashtable.get(firstCabinetHash)
>>> firstCabinet = trie.find(firstCabinetLocation)>>> secondCabinetHash = firstCabinet.drawer(7).contents
>>> secondCabinetLocation = hashtable.get(secondCabinetHash)
>>> secondCabinet = trie.find(secondCabinetLocation)>>> thirdCabinetHash = secondCabinet.drawer(3).contents
>>> thirdCabinetLocation = hashtable.get(thirdCabinetHash)
>>> thirdCabinet = trie.find(thirdCabinetLocation)>>> thirdCabinet.drawer(2).contents
"fido"*
```

*还记得我们的哈希函数吗？前面我们讨论了散列像“dog”和“cat”这样的简单值，但事实上你可以散列任何东西，包括其他散列或散列集。Ralph 意识到的是，通过将散列保存在橱柜中，你可以创建一个“散列轨迹”,它将随着任何值的改变而改变(还记得网站如何存储你的密码吗？同样的想法)。以下是更新值的方法:*

```
*>>> hash3("dog")
0x237### Find cabinet same as before>>> thirdCabinet.drawer(2).contents = "rover"### But then you start working backwards...>>> thirdCabinetHash = hash3(thirdCabinet.drawers)
>>> hashtable.set(thirdCabinetHash, thirdCabinetLocation)>>> secondCabinet.drawer(3).contents = thirdCabinetHash
>>> secondCabinetHash = hash3(secondCabinet.drawers)
>>> hashtable.set(secondCabinetHash, secondCabinetLocation)>>> firstCabinet.drawer(7).contents = secondCabinetHash
>>> firstCabinetHash = hash3(firstCabinet.drawers)
>>> hashtable.set(firstCabinetHash, firstCabinetLocation)>>> firstCabinetHash
0x375*
```

*现在，最终值`0x375`是整个 Merkle 树的“指纹”。你可以保存这个指纹(或者把它刻在花岗岩块上)，并且知道如果任何人改变了抽屉里的任何一个名字，散列的过程会给出不同的结果——你会知道有些事情已经改变了。请注意，与简单的 Trie 相比，这增加了更多的步骤:您需要一个单独的哈希表来跟踪位置。但是你得到的是*安全感*。*

*程序员和程序员走上前去仔细查看花岗岩块，令他们惊讶的是，他们看到上面刻着一系列的散列！`0x736`、`0x264`、`0x123`等等，`0x542`是最近的。他们大吃一惊！在附近，他们注意到一些活动:这个奇特部落中的一个想要证明他从另一个部落买了一匹马。他提出了这匹马的名字和他自己的名字，设定`trie.set(horse, name)`，并通过一个精心设计的仪式显示出他的名字，与某些其他名字混杂在一起，与某些其他名字混杂在一起……瞧！他到达`0x542`，因此所有人都同意这匹马是他的。*

*多么了不起的社会啊，程序员和程序员都同意。不过，程序员还是有些困扰。这是一个小部落——只有 512 名成员。随着他们的成长，他们将需要一个范围更大的新散列函数——数千、数百万、数十亿。因此，更新和验证 Merkle 树中的值将变得越来越昂贵——从三个机柜到五个、十个、六十个甚至更多！为了什么？这些抽屉大部分都是空的。这似乎是一个昂贵的系统，又慢又贵。肯定有更好的方法吧？要是有一种实用的算法来检索用字母数字编码的信息就好了…*

# *动词 （verb 的缩写）帕特里夏树*

*为了收集他们的想法，程序员和程序员走到山谷上方的山上。“一定有办法优化这棵树！”他们心里想。程序员建议他们查看一些随机散列，以建立一些直觉:*

```
*>>> hash8("cat")
0x14350235>>> hash8("dog")
0x14350762*
```

*然后程序员变得兴奋起来——他注意到这两个散列恰好以相同的数字开始:`14350`。有了这两个条目，到达最后一个抽屉应该只需要两个柜子:一个放`14350`，一个放剩下的东西:`235`或者`762`。这将比使用八个机柜快得多。您可以随时添加更多橱柜，但为什么要制造超出您需求的橱柜呢？在每个抽屉上，我们贴上一张小纸条，写下那个抽屉的常用前缀。最后，第一个柜子实际上只是一个抽屉。*

*查找值的过程如下:*

```
*>>> hash8("dog")
0x14350762>>> firstDrawerLocation = hashtable.get(firstDrawerHash)
>>> firstDrawer = trie.find(firstDrawerLocation)
>>> split(14350762, firstDrawer.commonPrefix)
(14350, 762)>>> secondCabinetHash = firstDrawer.contents
>>> secondCabinetLocation = hashtable.get(secondCabinetHash)
>>> secondCabinet = trie.find(secondCabinetLocation)
>>> secondDrawer = secondCabinet.drawer(7)
>>> split(62, secondDrawer.commonPrefix)
(62,)>>> secondDrawer.contents "fido"*
```

*程序员很兴奋——她对此感觉很好。这将使算法变得更加复杂，以确保正确地创建了文件柜，并确保通用前缀保持最新，但没有他们无法解决的问题。从长远来看，在开始设置这一切时多做一点工作将会为硅谷人节省很多时间。*

*这两个人坐下来研究这个新系统的细节，他们称之为[、【帕特里夏树】](https://github.com/ethereum/wiki/wiki/Patricia-Tree)。满意之后，他们来到山谷，把他们的作品展示给那里的人们。他们是快乐的人；缓慢的 Merkle 树已经拖累了他们的社会。他们希望，有了帕特里夏树，他们能够更快地发展他们的艺术、科学和工业。*

*程序员和程序员心满意足地离开了山谷。当他们登上山脊，开始穿过周围的草地时，他们听到了一种轻柔的嗡嗡声。抬头望去，他们看到一辆飞车消失在地平线上。*

# *不及物动词摘要*

*我们从这个完全原创的故事中学到了什么？*

***首先是**，散列表、尝试、merkle 树和 patricia 树本质上都在做同样的事情:它们让你将*键*映射到*值*。虽然它们之间存在差异，但这本质上是它们所做的事情。*

***第二**，在计算机科学中，没有什么是免费的(但有些东西是便宜的)。凡事都有取舍。哈希表很快，但是有一些随机性。尝试是完全确定的，但速度较慢。Merkle 树有很好的安全属性，但是使用更复杂的算法并且更新更慢。最后，Patricia 树比 Tries 和 Merkle 树更快，但是需要更复杂的算法。*

***第三**，帕特里夏树对区块链很有用，因为它们让你“证明”潜在的大量数据是正确的，而不必存储所有的数据。这非常方便:您可以拥有一棵包含大量数据(比如过去 24 小时内的所有事务)的大树，但是您只需要在实际的区块链上存储几个数字(比如 0x323757382)。您可以将其余的数据保存在某个常规数据库中，并且知道没有人能够篡改它并逃脱惩罚。请注意，这里区块链只是系统的*部分*:它依赖于其他数据存储来运行。*

***第四个**，哈希函数是让这一切成为可能的神奇机器。哈希函数的设计和实现是计算机科学家几十年来一直在进行的工作，他们很难做对。你应该花一点时间来欣赏让这项神奇技术成为可能的多年工作。*

**原载于 2018 年 7 月 4 日*[*kronosapiens . github . io*](http://kronosapiens.github.io/blog/2018/07/04/patricia-trees.html)*。**