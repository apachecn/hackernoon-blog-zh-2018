# 取消对 C++预处理器的定义

> 原文：<https://medium.com/hackernoon/undefining-the-c-pre-processor-c4eeb3d06e1f>

> 世界上只有两种语言:人们抱怨的语言和没人使用的语言——比雅尼·斯特劳斯特鲁普

我喜欢这句话。它解释了 JavaScript 和 Haskell。从这个角度来看，预处理器是一门伟大的语言，因为人们经常使用它。它从未与 C 和 C++分开考虑，但如果是的话，它将是 TIOBE 上的头号语言。预处理器非常有用，而且无处不在。事实是，如果没有预处理器的参与，编写任何严肃的可移植的 C++应用程序都是非常困难的。

> —预处理器很烂
> 
> 我知道，对吗？这是最糟糕的。嘿，你能合并我的提交吗？我添加了一堆有用的宏。

我想很多人都熟悉这种对话，如果我们不小心，20 年后我们可能还会有这种对话。因为不幸的是，现有的是预处理器的唯一可取之处。唉，我的问题既不是理论的，哲学的，也不是理想主义的。

我一点也不在乎预处理器让任何人在没有任何检查的情况下替换标识符、关键字(有人说，这是非法的，在实践中……)。我也不关心预处理器在不能正确处理逗号的情况下设法完成了。我甚至不关心包括和不包括警卫，我和`#pragma`之间没有任何问题。有时候你必须务实。

然而。

让我给你提供一个场景，你可能会发现这是人为的，但请原谅我。所以，假设你正在重构一个跨平台的应用程序，你决定做一些不寻常的事情，比如说，重命名一个函数。

那是不可能的。从来没有，可能永远不会。

Renaming foo — an unsolvable problem for which there is no Millennium prize

从根本上说，编译器和您的工具(一个工具必然是一个成熟的编译器前端)都不了解您的代码。被禁用的部分不被编译、解析、词法分析或以其他方式分析。

首先，被禁用的路径没有义务是有效的 C++。这是有效的:

The best way to distribute your C++ application.

因此，如果编译器考虑到预处理器的禁用路径，它可能无法获得有效的 AST。更糟糕的是，预处理，顾名思义，作为一个单独的状态发生，预处理指令可能被插入到任何两个 C++标记之间，包括任何表达式或语句的中间。

Some of these branches may form a valid C++ statement.

另一个同样相关的问题是，编译器不可能知道什么样的`#ifdef`和`#defines`语句的组合应该构成一个有效的程序。

例如，Qt 提供了一组`defines`,可以设置它们在编译时启用或禁用 Qt 的某些特性。假设你不需要一个日历小部件，你可以定义`#QT_NO_CALENDAR_WIDGET`,这样可以得到一个更小的二进制文件。它不起作用。我怀疑它*从未*起作用。看，在某个时候 Qt 有大约 100 个这样的编译时配置选项。假设可能的构建配置的数量随着变量的数量呈指数增长。当你的程序有两个⁰⁰版本时，自动化证明是困难的，即使是在大网深云的规模上。

> 未经测试的代码是破损的代码。

你可能知道这句著名的格言。那么甚至没有编译过的代码呢？

我应该指出，在平台特定的文件中放置一些平台特定的方法会导致完全相同的问题。基本上，编译器看到的代码应该是一个独立的真实来源，但是代码是支离破碎的，你对它的看法是不完整的。

# 预处理器被认为是有害的，我们能做些什么呢？

顺便说一下，不仅仅是预处理程序有缺陷。所有现代处理器显然也是如此。也许任何进行某种处理的东西都应该避免？

无论如何，今天让我们来看看我们能对预处理指令做些什么。

## `1\. Strongly Prefer`常量超过#define

这个很简单，但是我仍然看到很多使用宏定义的常量。总是使用`static const`或`constexpr`而不是`define`。如果您的构建过程涉及到设置一组变量，比如版本号或 git hash，请考虑生成一个源文件，而不是使用 defines 作为构建参数。

## 2.函数总是比宏好

Windows.h considered harmful

上面的片段来自 **Win32 API** 。即使对于“简单”和简短的一行程序，你也应该总是喜欢函数。

如果你需要函数参数的延迟计算，使用 lambda。讽刺的是，这是一个使用宏的解决方案，但这只是一个开始！

[](http://foonathan.net/blog/2017/06/27/lazy-evaluation.html) [## C++中函数参数的惰性计算

### 有时你计算一个昂贵的参数，然后函数根本不需要它！例如…

foonathan.net](http://foonathan.net/blog/2017/06/27/lazy-evaluation.html) 

## 3.抽象出可移植性问题。

在单独的文件、单独的库和方法中适当地隔离特定于平台的不愉快应该会减少代码中出现`#ifdef`块。虽然它不能解决我上面提到的问题，但是当你不在这个平台上工作的时候，你不太可能想要重命名或者转换一个特定于平台的符号。

## **4。限制软件的变化数量。**

> 这种依赖真的是可选的吗？

如果你有可选的依赖项来启用你的软件的一些特性，考虑使用一个插件系统或者把你的项目分成几个部分，当依赖项丢失时，无条件地构建组件和应用程序，而不是使用`#ifdef`来禁用一些代码路径。确保在有和没有依赖的情况下测试您的构建。为了避免麻烦，考虑永远不要让你的依赖成为可选的

> 这段代码真的只能在发布模式下执行吗？

避免有许多不同的调试/发布代码路径。记住，没有编译的代码就是坏代码。

> 该功能真的应该禁用吗？

甚至比依赖关系更重要的是，特性在编译时不应该是可选的。为插件系统提供运行时标志。

## 5.首选杂注一次超过包含

现在不支持`#pragma once`的奇葩 C++编译器少之又少。使用`#pragma once`更不容易出错，更容易也更快。和警卫吻别。

## 6.喜欢更多的代码而不是更多的宏

虽然这种方法适用于每种情况，但在大多数情况下，用宏代替几个 c++标记是不值得的。遵循语言的规则，不要试图过于聪明，容忍一些重复，这样可能会更易读，更易维护，你的 IDE 会感谢你的。

## 7.整理您的宏

宏应该尽快用`#undef`取消定义。不要让一个未记录的宏出现在头文件中。

宏没有限定作用域，请使用以项目名称为前缀的大写长名称。

如果你使用的是第三方框架，比如 Qt，它既有短宏名又有长宏名(`signal`和`QT_SIGNAL`)，一定要禁用前者，尤其是如果它们可能作为你的 API 的一部分泄漏的话。自己不要提供这么短的名字。宏名应该独立于代码的其余部分，并且不与`boost::signal`或`std::min`冲突

## 8.避免在 C++语句中间放置`ifdef`块。

```
foo( 42,
#if 0
  "42",
#endif
 42.0
);
```

上面的代码有一些问题。它难以阅读，难以维护，并且会给`clang-format`等工具带来问题。而且，它也碰巧坏了。

相反，应该写两条不同的语句:

```
#if 0
foo(42, "42", 42.0);
#else
foo(42, 42.0);
#endif
```

您可能会发现在某些情况下很难做到这一点，但这可能是一个信号，表明您需要将代码分成更多的函数，或者更好地抽象您正在有条件编译的东西。

## 9.优先选择 static_assert 而不是#error

简单地使用`static_assert(false)`来使构建失败。

# 未来过去的预处理器

虽然前面的建议适用于任何 C++版本，但是如果您有足够新的编译器，有越来越多的方法可以帮助您减少每天摄入的宏。

## 1.优先选择模块而不是包含

虽然模块应该提高编译时间，但是它们也提供了一个屏障，宏不能从中泄漏。在 2018 年初，还没有具备该功能的生产就绪编译器，但 GCC、MSVC 和 clang 已经实现了该功能，或者正在实现该功能。

虽然总体上缺乏经验，但有理由希望模块将使工具更容易，更好地实现一些功能，例如自动包含与丢失的符号相对应的模块，清理不需要的模块…

## 2.尽可能使用 if constexpr over #ifdef

当被禁用的代码路径是格式良好的(不引用未知符号)时，`if constexpr`是比`#ifdef`更好的选择，因为被禁用的代码路径仍然是 AST 的一部分，并且被编译器和您的工具检查，包括您的静态分析器和重构程序。

## 3.即使在后现代的世界里，你也可能需要求助于#ifdef，所以考虑使用后现代的。

虽然它们根本无助于解决手头的问题，[一组宏](http://en.cppreference.com/w/cpp/experimental/feature_test)正在被标准化，以检测你的编译器提供的一组标准设施。如果需要，就使用它们。我的建议是坚持使用所有编译器提供的特性。选了一条底线，坚持到底。考虑一下，将现代编译器移植到目标系统可能比用 C++98 编写应用程序更容易。

## 4.使用 std::source_location，而不是 __LINE__ 和 __FILE__

每个人都喜欢写自己的日志。现在您可以使用 [std::source_location](http://en.cppreference.com/w/cpp/experimental/source_location) 用更少的宏或不用宏来完成这项工作。

# 走向无宏应用的漫长道路

一些工具为一些宏的使用提供了更好的选择，但是实际上，你还是需要求助于预处理器，越早越好。但幸运的是，我们还有很多可以做的。

## 1.用编译器定义的变量替换-D

`define`最常见的用例之一是查询构建环境。调试/发布、目标架构、操作系统、优化…

我们可以想象通过一个`std::compiler`公开一组常量来公开一些构建环境变量。

```
if constexpr(std::compiler.is_debug_build()) {  }
```

同样，我们可以想象在源代码中声明某种类型的`extern compiler constexpr`变量，但是由编译器定义或覆盖。如果有一种方法来约束这些变量所能容纳的值，那么这只会比`constexpr x = SOME_DEFINE;`有真正的好处。

也许是类似的东西

```
enum class OS {
    Linux,
    Windows,
    MacOsX
};[[compilation_variable(OS::Linux, OS::Windows, OS::MacOsX)]]  extern constexpr int os;
```

我的希望是，给编译器更多关于各种配置变量是什么的信息，甚至什么样的变量组合是有效的，将导致源代码的更好的建模(以及工具和静态分析)。

## 2.更多属性

C++属性很棒，我们应该拥有更多。`[[visibility]]`将是一个很好的起点。它可以将 constexpr 变量作为参数从导入切换到导出。

## 3.从 Rust 的书里拿走一页

Rust 社区从不错过激烈宣传 Rust 语言优点的机会。事实上，铁锈能做很多事情。编译时配置就是其中之一。

Literally taken from the rust book

使用属性系统在编译单元中有条件地包含一个符号确实是一个非常有趣的想法。

首先，它是真正可读和自我记录的。第二，即使一个符号不包括在构建中，我们仍然可以尝试解析它，更重要的是，唯一的声明为编译器提供了关于实体的足够信息，以实现强大的工具、静态分析和重构。

考虑以下代码:

```
[[static_if(std::compiler.arch() == "arm")]]
void f() {} void foo() {
    if constexpr(std::compiler.arch() == "arm") {
        f();
    }
}
```

它有一个惊人的特性:它结构良好。因为编译器知道`f`是一个有效的实体，并且它是一个函数名，所以它可以明确地解析被丢弃的`if constexpr`语句的主体。

你可以将相同的语法应用于任何类型的 C++声明，编译器将能够理解它。

```
[[static_if(std::compiler.arch() == "arm")]]
int x = /*...*/
```

这里，编译器只能解析左侧，因为静态分析或工具不需要其余部分。

```
[[static_if(std::compiler.is_debugbuild())]]
class X {
};
```

出于静态分析的目的，我们只需要索引类名及其公共成员。

当然，从活动代码路径中引用一个被丢弃的声明是不良的，但是编译器可以检查它*永远不会*发生在任何有效的配置中。当然，这在计算上是不自由的，但是你可以保证所有的代码都是格式良好的。因为在 Linux 机器上编写代码而破坏 windows 版本会变得更加困难。

然而，这并不像听起来那么容易。如果被丢弃实体的主体包含当前编译器不知道的语法怎么办？也许是供应商扩展或一些更新的 C++特性？我认为解析尽最大努力进行是合理的，当解析失败时，编译器可以跳过当前语句，并警告它不理解的源代码部分。“我无法在第 110 行和第 130 行之间重命名 Foo”比“我已经重命名了 Foo 的一些实例”好得多。也许不是全部，祝你好运手动浏览整个项目，真的不用麻烦一个编译器，用 grep 就行了”。

## 4.constexpr 所有的东西。

也许我们需要一个`constexpr` `std::chrono::system_clock::now()`来代替`__TIME__`

我们可能还需要一个[编译时随机数生成器](https://www.youtube.com/watch?v=rpn_5Mrrxf8)。为什么不呢？不管怎样，谁会关心可复制的构建呢？

## 5.使用反射生成代码和符号

元类的提议是自切片面包、模块和概念以来最好的东西。特别是 [P0712](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0712r0.pdf) 在许多方面都是一篇令人惊叹的论文。

引入的众多构造之一是`declname`关键字，它从字符串和数字的任意序列中创建一个标识符

`int declname("foo", 42) = 0;`创建一个变量`foo42`。考虑到字符串连接形成新的标识符是宏最常见的用例之一，这确实非常有趣。希望编译器能有足够的关于以这种方式创建(或引用)的符号的信息来正确地索引它们。

声名狼藉的`[X macro](https://en.wikipedia.org/wiki/X_Macro)`也应该在未来几年成为过去。

## 6.为了摆脱宏，我们需要一种新的宏

因为宏只是文本替换，所以它们参数被延迟计算。虽然我们可以使用 lambda 来模拟这种行为，但这相当麻烦。那么，我们能从函数的惰性求值中获益吗？

这是我去年思考的一个话题

[](https://github.com/cor3ntin/CppInjectionReflection) [## cor 3n tin/CppInjectionReflection

### CppInjectionReflection——c++中代码注入和反射的研究

github.com](https://github.com/cor3ntin/CppInjectionReflection) 

我的想法是使用代码注入提供的工具来创建一种新的“宏”,由于没有更好的名称，我称之为“语法宏”。基本上，如果您给一个代码片段(您可以在程序的给定点注入的一段代码)命名，并允许它接受一些参数，您就有了一个宏。而是在语法级别检查的宏(而不是预处理器提供的标记源)。

它是如何工作的？

Definition of usage of a S-Macro

好吧，这里发生了什么。

我们首先用`constexpr { }`创建一个`constexpr block`。这是元类提案的一部分。constexpr 块是一个复合语句，其中所有变量都是`constexpr`，没有副作用。该块的唯一目的是在编译时创建注入片段并修改声明该块的实体的属性。(**元类**是位于 **constexpr** 块之上的语法糖，我认为我们实际上并不需要元类。)

在 constexpr 块中，我们定义了一个宏`log`。请注意，宏不是函数。它们扩展为代码，它们不返回任何东西，也不存在于堆栈中。`log`是可以限定的标识符，不能是同一范围内任何其他实体的名称。语法宏遵循与所有其他标识符相同的查找规则。

他们使用`->`注射操作器。`->`可以用来描述所有与代码注入相关的操作，而不会与其当前的用法相冲突。在您的例子中，因为 log 是一个语法宏，是代码注入的一种形式，所以我们用`log->(){....}`来定义这个宏。

语法宏的主体本身是一个 constexpr 块，它可以包含任何可以在 constexpr 上下文中计算的 C++表达式。

它可以包含 0 个、一个或多个由`-> {}`表示的**注入语句**。注入语句创建一个代码片段，并立即在调用点注入它，在语法宏的情况下，这是宏展开的位置。

一个宏既可以注入一个表达式，也可以注入 0 个或多个语句。注入表达式宏只能在需要表达式的地方展开，反之亦然。

虽然它没有类型，但它有一个由编译器决定的性质。

您可以将任何参数传递给语法宏，而语法宏可以传递给函数。参数在扩展之前进行计算，并且是强类型的。

但是，您也可以在表达式上传递反射。假设能够反射任意的表情。表达式`e`上的反射具有对应于`decltype(e)`的类型。

就实现而言，在上面的例子中，`std::meta::expression<char*>`是一个与类型为`char*`的表达式上的任何反射相匹配的概念。

评估宏的最后一个神奇之处是，表达式在扩展之前被隐式转换为它们的反射。

在基本层面上，我们四处移动 AST 节点，这与当前的反射和代码注入方法是一致的。

最后，当我们注入`print(->c, ->(args)...)`时，请注意`->`标记。将反射转换回原始表达式，然后进行计算。

从调用点来看，`log->("Hello %", "World");`看起来像一个常规的 void 函数调用，除了`->`表明存在一个宏展开。

最后，在求值之前将标识符作为参数传递的能力可以减少对新关键字的需要:

在对 x 求值之前，`std::reflexpr->(x)`可以扩展到 __ `std_reflexpr_intrasics(x)`。

## S-Macro 会完全取代预处理宏吗？

他们没有，但他们也不打算这样做。值得注意是，因为它们必须是有效的 c++且在多个点(在定义时，在扩展之前、期间和之后)被检查，所以它们主动禁止令牌汤。分别是有效 C++，注入有效 C++，使用有效 C++作为参数。

这意味着它们不能注入部分语句、操作部分语句或者将任意语句作为参数。

它们确实解决了懒惰求值和条件执行的问题。例如，你不能用它们实现`foreach`，因为`for(;;)`不是一个完整的语句(`for(;;);`和`for(;;){}`是，但它们不是很有用)。

关于姓名查找有很多问题。宏应该“看到”它展开的上下文吗？and 参数应该知道宏的内部吗？这是声明上下文。

我认为限制是一件好事。如果你真的需要发明新的结构，也许语言是缺乏的，在这种情况下，写一个提议。或者你需要一个代码生成器。或者更多的抽象，或者更多的实际代码。

## 这是真实的生活吗？

这是非常幻想的，绝对不是任何当前提议的一部分，但是我确实认为这是代码注入特性的逻辑发展。

它有点像[rust macros](https://doc.rust-lang.org/1.10.0/book/macros.html)——除了它不允许任意的语句作为参数——同时(我希望)感觉像是 C++的一部分，而不是另一种具有独立语法的语言。

预处理程序看起来肯定是致命的。但是你可以做很多事情来减少对它的依赖。通过提供更好的选择，C++社区可以做很多事情来降低宏的用处。

这可能需要几十年的时间，但这是值得的。不是因为宏从根本上来说是不好的，而是因为工具越来越成为评判语言好坏的标准。

因为我们迫切需要更好的工具，我们需要尽我们所能减少我们对预处理器的宿命依赖。

`#undef`