# 关于 Python 单元测试的未知故事

> 原文：<https://medium.com/hackernoon/untold-stories-about-python-unit-tests-a141501f0ee>

如果方法正确，单元测试将成为你最好的伙伴。一旦产品进入维护级别，您在编写测试上投入的时间将以最意想不到的方式派上用场。单元测试会像你的宠物狗一样呆在你身边，对你在添加功能、重构甚至修复 bug 时犯下的愚蠢错误吠叫。单元测试和静态代码分析器可以防止大多数容易犯的错误。

![](img/410c8bf0ee4b5cfdb7a78edeef02a906.png)

Unit testing is your best buddy

> Pytest 无疑是 python 最受欢迎和最稳定的测试解决方案

这篇文章将分享我在 pytest 上的经历，特别是关于单元测试的经历，以及我从艰难的道路中学到的东西；或者更确切地说，是关于一些大多数在线文章或论坛不谈论的东西。

# 测验的剖析

> 在深入 pytest 之前，让我介绍一下单元测试的基础知识。

> 作为一种实践，我在心里把我写的每个单元测试分成 3 或 4 个部分！！

作为总结，首先将有几个关于**设置测试**的陈述。然后将会有一些关于**执行实际方法**的语句，接着是一些关于**做** **断言**的其他语句。偶尔作为第四步，我们可能还需要**结束**测试。让我们更详细地看一下这些部分。

**第一部分**对*“使测试成为单元测试”*很重要。模仿被测试的函数或方法的所有副作用*是至关重要的。否则，你写的测试可能第一次就通过了，但不是所有时候都通过。例如，如果该方法执行实际的数据库操作，当数据库中存在特定值时，测试可能通过，否则将失败。这个概念类似于函数式编程中的*纯函数*，无论你调用函数多少次，都将相同的输出返回给定的输入。事实上，一个单元测试函数本身可以被认为是一个纯函数。因此，测试方法的第一部分可以用来执行正确运行测试的所有基础工作。 [python 模拟](https://docs.python.org/dev/library/unittest.mock.html)库、*现在是*[*python*](https://hackernoon.com/tagged/python)*标准库*的一部分，在为 python 项目编写单元测试时，它将在这方面帮助我们。*

然而，一般来说，一个模块中的多个测试用例需要相同的初始化步骤。为了避免在这种情况下的返工和不一致，我们可以使用**设置&拆卸**方法来指导测试运行者分别在每次测试之前和之后运行期望的步骤。在像 Javascript 这样的一些语言中，setup & teardown 函数被称为`before`和`after`钩子。

**测试的第二部分**可以用来调用实际的方法并执行任何其他需要的操作。虽然这不是写断言的地方，但是在某些情况下，测试本身可能会产生结果。例如，如果您曾经使用过 ReactJs，那么在某些情况下只需呈现一个组件就足够了。如果组件的重要属性写得不正确，测试就不会通过。这个理论也适用于其他非反应场景。然而，最好是在之后再写一些断言来验证被测试的方法或函数的行为。按照术语，不做任何断言，而只是检查执行而没有意外中止的测试被称为**冒烟测试**。

**第三部分**，是测试中最重要的部分，用于验证函数或方法的行为。断言不应该太严格也不应该太灵活。太多的灵活性会隐藏你在代码重构过程中可能犯的错误。过于严格的断言会导致测试*过度适应*并失败，即使变化不会导致问题。这将导致无论何时你做了哪怕是很小的代码更改，都必须更新测试，使得测试变得脆弱、不稳定，并且维护起来很麻烦。确定理想的断言数量是一门艺术，需要时间的磨练。就 python 而言，断言可以针对返回值进行，也可以通过模拟(如果有的话)进行。

> 另外，很容易滥用这一部分来显示增加的测试覆盖率。这就是为什么突变测试的概念开始发挥作用。我将在另一篇文章中解释这个概念。

测试的最后和第四部分用于结束测试执行。例如，如果您在测试开始时模仿了某个模块的某个方法，您可能需要恢复原来的功能。否则，它会在前面使用相同方法的测试中产生意外的行为。如上所述，这是一个拆卸功能可以派上用场的地方。然而，在 python 中使用 mocks 时，您可能不会注意到这种模式。这是因为，当您使用`patch`装饰器或上下文管理器时，模拟将在测试结束时自动恢复。由于这种模式，您很少需要在 pytest 中使用 setup 和 teardown 方法。

# Pytest 基础

虽然 Pytest 是一个很好的工具，但是我发现他们的文档描述性很强，但是很难读懂。因此，在这里，我将总结原始文档中最重要的概念。

## 安装和运行

您可以使用`pip install -U pytest`安装，然后简单地从根目录运行`pytest`来运行所有测试。

## 测试目录和文件名

尽管有许多可能性，但是定义测试的最佳位置是在源文件旁边的一个名为“test”的目录中。又名“测试作为应用程序代码的一部分”

测试文件可以被命名为`<source_name>_test.py`或`test_<source_name>.py`，但是请确保你坚持使用其中一种模式。这是原始文档中的一个例子。

```
setup.py
mypkg/
    __init__.py
    app.py
    view.py
    test/
        __init__.py
        test_app.py
        test_view.py
        ...
```

# 与 Setuptools 集成

大多数 python 项目都是基于`setuptools`的。如果您的 python 项目也在使用`setuptools`，那么您应该将`pytest`与`setup.py`集成在一起。

> pytest 文档清楚地解释了如何使用 pytest-runner 将 pytest 与 setuptools 集成。然而，它并没有解释为什么你应该这样做。

当我有这个问题时，我不知道为什么我应该做这个集成，因为我可以简单地从终端执行`pytest`。所以我做了显而易见的事情。我跳过了整合。

后来，在我刚刚忘记这种整合的时候，我遇到了一个问题。**使用 pytest-cov 生成的覆盖率报告完全错误！！**源文件显示覆盖率为 0%,所有测试文件都包含在报告中。我没想到会这样。

在付出太多努力后，我了解到，除非您将 pytest 与`setup.py`文件集成，否则测试不会像预期的那样针对源代码运行。除此之外，几乎没有其他理由说明为什么您应该将 pytest 与`setup.py`集成在一起。

1.  您可以在`setup.py`的`tests_require`选项中指定依赖关系。这将确保在实际运行 pytest 之前安装所有必需的助手包。
2.  您可以在安装配置文件中使用 pytest 的别名。例如，您可以如下定义您的 setup.cfg，这样做的话，pytest 将在您使用`sdist`命令创建一个源代码发行版之前运行。

```
**[aliases]** test=pytest

clean_all=
    clean --all
    rotate --match=.tar.gz --keep=0

build=
    clean_all
    test
    install
    sdist

**[tool:pytest]** addopts =
    --cov-config .coveragerc
    --cov-report html
    --cov=my_pkg
    --pylint
    --pylint-rcfile=.pylintrc
    --pylint-error-types=EF
```

还要注意，虽然与 setuptools 脚本没有直接关系，但是使用`setup.cfg`文件定义 pytest 选项是多么容易。

# 嘲弄

如前所述，在用任何语言编写单元测试时，模仿都扮演着重要的角色。在 python 中模仿方法最简单的方法是使用模仿库提供的`patch`装饰器。使用`patch`的主要优势是如上所述的自动模拟恢复行为。另一方面，与直接使用`Mock`或`MagicMock`相比，使用`patch`装饰器编写的测试看起来更干净、更容易理解。然而，在极少数情况下，您需要在模拟对象中有更多的灵活性。如果您碰巧直接使用核心类，那么在重置模拟对象时要小心。

该库创建的每个模拟对象都有直接完成所需断言的方法。您可以通过调用这些方法来检查是否调用了某个特定的方法以及使用了哪些参数。

您可以直接为模拟方法指定返回值。但是你也可以指定一个 side_effect 方法，这个方法将代替原来的方法被调用。当您希望基于调用方法时传递的参数返回一些值时，这个概念非常有用。

## 特殊返回值

当对使用外部库的方法编写测试时，返回值可能是特殊的对象。例如，对`request`库的实际调用的返回值是一个特殊的响应对象。

在这种情况下，我通过定义假类来摆脱困境。和上面的例子一样，我通过定义一个假的响应类来配置请求库调用的返回值。下面给出了一个非常基本的示例类。

因此现在我可以如下定义一个类的返回值，

```
mock_req.return_value = Response(status_code=200, data="abc123")
```

尽管 pytest 和 mock 库提供了许多有用的特性，但是基本特性对于大多数情况来说已经足够了。然而，你花在阅读图书馆文档上的时间是不会白费的。你一定会发现一些功能，它们可以用更少的代码以更好的方式做你已经做过的事情。因此，我强烈建议您一旦掌握了一些基础知识，至少浏览一下 pytest 和 mock 文档。

> 如果你觉得这个故事有趣，给这个故事一些掌声，鼓励我写更多。👏👏👏我很想通过评论听到你的反馈。