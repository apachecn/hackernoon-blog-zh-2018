# 使用简单索引优化 Postgres 中的复杂排序

> 原文：<https://medium.com/hackernoon/using-simple-indexes-to-optimize-complicated-sorts-in-postgres-1761b097d97c>

***建筑泡沫。*** *在这一系列的帖子中，我们的工程团队谈论了* [*Bubble*](https://bubble.is/) *的内部工作原理，这是一种基于云的可视化编程语言，它让编程变得人人都可以使用。*

我们在 Bubble 面临的一大挑战是将用户编写的查询转换成高性能的 SQL。用户可以定义自己的数据模式，并编写自定义搜索来过滤和排序结果。搜索通常嵌入在我们用户的应用程序逻辑中，所以它们需要快如闪电，并尊重我们的事务语义。

为此，我们将查询转换成 SQL，并在 Postgres 后端数据库上运行它们。让这既正确又高效是一个巨大的挑战。这篇文章是关于一个有趣的问题，我们最近遇到了一些缓慢的查询，我们试图加快速度，以及我们如何解决它。

(我将假设您熟悉使用索引来加速数据库中的搜索，至少在一般水平上是如此。如果没有，这是一本很棒的入门书:[使用索引，卢克](https://use-the-index-luke.com/sql/preface)。

我们事先不知道 Bubble 用户打算如何搜索他们创建的数据。因此，我们快速搜索的策略是，当我们检测到模式时，自动动态建立索引。如果我们看到一个缓慢的搜索发生几次，我们试图建立一个索引来加快它。

然而，索引是昂贵的。表上的每个索引都会增加表消耗的磁盘空间量，更糟糕的是，会增加每次写表的开销。因为每个索引都需要更新，所以在一个有一百个索引的表中插入一个新行就像是写一百次而不仅仅是一次！

所以，我们要确保我们建立的每个指数都有分量。我们希望索引可以用于一系列不同的搜索，而不仅仅是一个搜索。我们的首选索引类型是单列 b 树索引。b 树索引是 Postgres 的默认设置，它们可以用于等式匹配、不等式匹配和排序:它们是索引领域的万能工具。

然而，最近我们注意到一些奇怪的事情。在 WHERE 子句中没有任何内容的大型表上进行定制排序搜索的性能非常差，即使在我们排序的列上有 b 树索引。有时运行一个只返回 5-10 个结果的搜索需要几秒钟。

从某种意义上说，这并不令人惊讶。在数据库中，排序是一项非常昂贵的操作，因为即使您只想返回十个结果，您仍然需要检查每一行，以确定哪一行是前十个。因此，如果您的表中有一百万行，按排序顺序获得十个结果可能要花很长时间。

然而，索引提供了一种处理这种情况的方法。假设我们有一个用户正在构建一个游戏，并且有一个玩家在游戏中取得的分数表:

```
CREATE TABLE scores (
 uid bigserial PRIMARY KEY,
 player_id bigint,
 timestamp bigint,
 score int
);
```

并且用户想要显示前 10 个分数，以及谁得到了它们以及它们发生的日期，我们可以使用以下查询来完成:

```
SELECT * FROM scores ORDER BY score DESC LIMIT 10;
```

如果没有索引，Postgres 将需要进行全表扫描，读取每一个分数，以便找出最高的 10 个分数。

然而，使用 score 列上的 b 树索引，Postgres 可以进行索引扫描:它可以从最高到最低通读 score 索引，直到找到 10 个结果。因为我们的搜索没有其他限制，所以索引中的前十个条目是 Postgres 将返回的行，这使得这个查询非常快。

到目前为止，一切顺利。但是在实践中，我们的查询实际上比这要复杂一些。首先，Bubble 应用程序在客户端实时更新数据。这意味着我们需要我们的结果总是以一致的顺序返回，因为如果我们刷新搜索并且顺序改变了，我们不希望内容在页面上随机跳跃。因此，我们需要一种一致的方式来打破束缚。我们为此使用了 uid 列，因为它保证是唯一的。

我们的用户可能也想打破他们的束缚。例如，在高分图表中，您可能希望通过对第一个获得高分的人进行排名来打破平局。所以我们实际的排序条件可能是:

```
SELECT * FROM scores ORDER BY score DESC, timestamp, uid LIMIT 10;
```

我们还需要担心分数为空的行。在游戏分数表中，我们可能没有任何条目缺少分数。但是请记住，我们不知道我们的用户实际上想要构建什么。也许在某些情况下，空值确实是有意义的:无论哪种情况，我们都需要为它们做好准备。Bubble 总是在搜索结束时对空值进行排序，因为我们认为这是处理它们最直观的方式。Postgres 将空值排序为高于其他所有值:在升序搜索中，它们位于末尾，但在降序搜索中，它们位于开头。因此，我们需要覆盖它以获得我们想要的行为:

```
SELECT * FROM scores ORDER BY score DESC NULLS LAST, timestamp, uid LIMIT 10;
```

所以，关键时刻到了。我们建立了可靠的 b 树索引:

```
CREATE INDEX ON scores (score);
```

…给表格添加一百万个分数:

```
INSERT INTO scores (player_id, timestamp, score) VALUES (17, 1527875748779, 235);
… and so on …
```

开始我们的搜索！

**小测验**:会发生什么？

**回答** : Postgres 扫描整个百万行表🙁🙁🙁

原因是因为 Postgres 聪明，但没那么聪明。它知道可以读取 b 树索引来加速排序操作，并且知道如何为升序和降序搜索向前和向后读取索引。但是为了使用索引来加速排序，它需要知道索引中条目的顺序总是完全符合排序所要求的顺序。

我们的索引可能与排序顺序完全匹配，也可能不匹配。首先，我们要求空值排序低于数字，但是索引将它们存储为高于数字。不匹配的另一个可能原因是平局:如果两个条目有相同的分数，我们希望首先通过时间戳，然后通过 uid 打破平局。然而，索引是单列的:如果两个条目得分相同，Postgres 不保证它们的存储顺序。

从人类的角度来看，这些都是微小的差异。索引基本上已经按照正确的顺序排列，只需要一些小的调整就可以得到我们想要的。然而，从 Postgres 的角度来看，这些差异是完全的阻碍。它没有动态调整的代码，所以根本不能使用索引。如此接近…然而，如此遥远。

对此的一个解决方案是建立一个与搜索完全匹配的索引。例如:

```
CREATE INDEX ON scores (score DESC NULLS LAST, timestamp, uid);
```

但这是一个丑陋、可悲的解决方案。我们的用户经常以各种不同的方式对同一个表进行排序。我们真的想为所有可能的排序组合建立一个索引，并为每个组合付出性能代价吗？

与此同时，我们在分数栏上有一个非常可爱的索引，我们可能需要创建它来有效地比较分数，就放在那里，差不多，但还不够好。

Postgres 可能不够聪明，无法使用我们的分数索引，但没有理由我们不能比我们的数据库更聪明。

我们知道以下事实:

*   我们将在末尾对空值进行排序，所以在到达搜索末尾之前，我们不需要担心空值
*   除了分数相等之外，索引的顺序都是正确的。这意味着索引中的第 10 个最高分与我们的结果中的第 10 个最高分具有相同的分数编号，即使获得该分数的用户是不同的

所以，我们做的是这个。在搜索 real 之前，我们先进行初步搜索，以找到第 10 个最高分:

```
SELECT score FROM scores WHERE score IS NOT NULL ORDER BY score DESC OFFSET 9 LIMIT 1
```

Postgres *将*对这个查询进行索引扫描。我们已经将空值完全排除在搜索之外，并放弃了“空值最后”的排序。我们现在只对一列进行排序。因此，我们的索引顺序现在完全满足查询。这种搜索速度非常快:我们只需要读取索引中的前十个条目，并返回最后一个条目的分数。

如果这个初步查询没有返回任何结果，这意味着我们基本上是在尝试获取整个表(除非有一百万个空条目，在这种情况下，score 上的索引对我们没有多大帮助)。因此，在这种情况下，我们只执行原始查询，不做任何修改，因为在这种情况下，全表扫描可能是我们能做的最好的事情。

另一方面，如果我们确实得到了第 10 个分数，我们将它作为不等式约束添加到原始查询中。例如，如果第 10 个分数是 534，我们将原始查询改为:

```
SELECT * FROM scores WHERE score >= 534 ORDER BY score DESC NULLS LAST, data, uid LIMIT 10
```

这里有一个窍门:Postgres 不够聪明，无法使用索引来帮助排序，但它*足够聪明，可以扫描我们的分数索引来评估不平等性！如果您对这个查询运行 EXPLAIN 来查看 Postgres 如何执行它，您将看到它首先对 score > = 534 进行索引扫描过滤，然后使用我们的全排序排序对该扫描的输出进行排序，然后应用 10 行限制。*

这比全表扫描要快得多。如果第 10 名有平局，我们的“> = 534”条件可能返回超过 10 行，但是除非有一百万个平局，否则第一次索引扫描返回的总行数可能非常接近 10。Postgres 仍然需要手动排序，但它只需要排序 10 行左右的行，不需要排序最初的百万行。

因此，这个修改后的查询的性能几乎与我们为该特定搜索构建的高度特定的索引一样好，但我们是用一个通用的简单索引来实现的，我们也可以为一系列其他搜索重复使用这个索引。胜利！！

如果您想在实践中使用这种技术，有一点需要注意:如果在我们获取第 10 个分数的第一次查询和获取最终结果的第二次查询之间数据发生了变化(比如，如果您删除了一个高分)，那么“> =”不等式可能会导致返回少于 10 个结果。为了避免这种情况的发生，这两个搜索需要在同一个事务中，并且该事务需要以可重复读取或更高的隔离模式运行，而不是 Postgres 的默认读取提交模式。

(关于隔离模式的更多信息，请点击这里:[)https://www . PostgreSQL . org/docs/9.6/static/transaction-iso . html](https://www.postgresql.org/docs/9.6/static/transaction-iso.html)。TL；默认情况下，同一事务中的两次选择可以看到数据库的不同快照，但在可重复读取模式下，它们将看到数据库的相同快照)。

我们实际上在用 plv8 编写的存储过程中运行这两个查询，以最小化从服务器到数据库的往返延迟。在生产中运行 plv8 本身就是一个有趣的话题:也许是未来文章的主题！

*觉得这个有意思？* [*我们一直在寻找优秀的工程师加入我们*！](https://bubble.is/jobs)

*原载于 2018 年 6 月 4 日*[*blog . bubble . is*](/@jphaas1/using-simple-indexes-to-optimize-complicated-sorts-in-postgres-e01575b8cc36)*。*