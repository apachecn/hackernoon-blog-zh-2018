# 值对象而不是形式

> 原文：<https://medium.com/hackernoon/value-object-instead-of-form-777f1a559b1>

![](img/8c7189f8da03de168d6642a17297d148.png)

You think handling forms it’s the only way? But, is there any options?

## 用价值对象代替形式的实际好处

让我们考虑一下价值对象(VO) " *设计模式"*如何帮助你处理 web 表单，简化你的生活。

## 形式

假设我们需要在 PHP 中处理 HTTP 请求(在这两种情况下:“application/x-www-form-urlencoded”或“application/json”转换这两种请求的参数并使用它们在 PHP 中填充表单非常简单)。
通常我们会这样做(这里我要用`symfony/form`，因为它非常简单明了，很流行，你可以在 github 上找到它):
1)创建`form`类:

2)创建表单实例:`$task = new Form();`
3)用来自 HTTP 请求的参数填充表单:

```
$form->handleRequest($request);
```

现在我们可以处理这个表格了。到目前为止还没什么困难…
但是等一下…让我们回答下一个问题:

1.  这个表格有效吗？
2.  是否所有参数都填充了请求中的值？
3.  我可以修改任何参数值吗？
4.  我可以在下游服务、层等中松散地重用这种形式吗？

答案:

1.  没想法，只好跑:`$form->isValid()`
2.  不确定。如果有人遗漏了(这种情况很少见，但在技术上是可能的):`$form->handleRequest($request);` 意味着表单包含空白的初始化值，在我们的例子中
    `$form->getName()`将返回`null`。
3.  是的。只需调用公共 setter。
4.  肯定不是。因为表单不仅可以包含有效值，也可以包含无效值，这意味着我们必须用代码淹没服务，如:

```
if ($form->isSubmitted() && $form->isValid()) {
    // ...
}
```

## 价值对象

让我们处理相同的 HTTP 请求:
1)创建 VO 类:

2)创建 VO 实例:`$vo = newValueObject($request);`

就这样，不需要额外的步骤。我们来回答之前的问题:

1.  这个 VO 有效吗？
2.  是否所有参数都填充了请求中的值？
3.  我可以修改任何参数值吗？
4.  我可以在下游服务、层等中松散地重用这个 VO 吗？

答案:

1.  是啊！自 VO 创建—有效，因为 VO 在`__costruct`方法中包含自验证。如果提供的参数无效，将不会创建 VO，将会引发异常。
2.  是啊！否则将抛出异常，并且不会创建 VO。
3.  不要！VO 是不可变的，你改变不了什么。
4.  是啊！VO 总是有效的，你可以在任何应用程序层依赖它，你可以在方法中使用它作为类型提示，比如:
    `public function doSomething(ValueObject $vo)` 并且你不必用冗余的`if`块来淹没你的代码(更具声明性的风格)。

## 批评

您可能认为在构造函数中编写所有验证内容可能会让人不知所措——我在这里只使用了一个简单的小例子，目的是以最简单的方式提供主要思想。但是你可以考虑使用类似于`kint/vo`的选项，更多信息你可以在这里找到。

你也可以把在`__construct`期间的异常看作是用`try-catch`块淹没你的代码，但是在现实生活中，你必须为整个应用程序只有一个这样的块(不管它有多大),它将捕捉你的定制异常，并将所有错误提供到响应中，就像在`kint/vo`的情况下，你只是在一个地方捕捉`ValueObject\Exception\ValidationException`。

如果你不喜欢在值对象的构造函数中包含所有这些东西，也不想使用`new`关键字，你可以考虑下一个例子:

主要思想保持不变，唯一的区别是你如何创建(`$vo = ValueObject::fromArray([‘namex’ => ‘bond’]);`)和使用你的值对象。

## 结论

现在您知道了值对象如何帮助您以声明式方式编写更严格、更健壮、不可变的代码。

希望这篇文章对你有所帮助，你不仅可以使用 VO 来处理 HTTP 请求，还可以在你的组件、服务等之间建立完整的交互。在你的申请中。