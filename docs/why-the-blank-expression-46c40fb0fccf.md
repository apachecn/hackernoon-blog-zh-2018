# 为什么一脸茫然？App 白屏综合症的解决方案

> 原文：<https://medium.com/hackernoon/why-the-blank-expression-46c40fb0fccf>

随着 web 内容进入日常生活的各个方面，移动设备的性能也在不断提高，发展使得内容可以在各种平台和设备上访问。

![](img/2c10ed96e46238394755ae8a4a15cc41.png)

然而，如果没有适当的优化，网页内容可能会成为某些限制的受害者。使用 HTML 5 标记创建的内容经常遇到的一个问题是，当用户访问内容时，最初的加载速度很慢。网页加载时出现白屏，HTML 5 过程的复杂性往往导致加载时间过长，导致用户体验不佳。

本文探讨了提高应用程序功能模块的初始加载速度的可能方法，这些模块加载特定内容的网页。建议的优化可以应用于使初始加载体验像本机应用程序一样流畅。

# 初始页面加载——为什么延迟？

标记语言 HTML 广泛用于跨多个平台构建和呈现数字内容。虽然第五个版本 HTML 5 为网页带来了更好的多媒体和多平台支持，但它也受到初始加载时间缓慢的困扰。

这主要是由于加载 HTML 5 网页的复杂步骤:

> 初始化 webview →请求页面→下载数据→解析 HTML →请求 JS/CSS 资源→ DOM 渲染→解析 JS 执行→ JS 请求数据(有时不需要)→解析渲染→下载渲染图片

通常，在 DOM 渲染步骤之前会显示一个白屏。用户只有下载渲染图后才能浏览完整网页。在其他情况下，只显示页面的一部分。

![](img/186fe7c16f48825f70fef7eb41933ba4.png)

为了解决这个问题，可以进行前端、客户端和其他优化，以减少此类过程的持续时间，从而实现初始加载的零延迟。

# 前端优化

可以对页面的内部前端部分进行优化，以提高初始页面加载速度。这些优化包括:

**减少请求数量**

这是通过合并资源、减少 HTTP 请求的数量以及通过 minify/gzip 压缩、webP 和 lazyLoad 来实现的。

**加速请求的速度**

这是通过预先解析 DNS、减少域数量、并行加载和 CDN 分发来实现的。

**缓存**

这包括 HTTP 协议缓存请求、脱机缓存清单和本地存储上的脱机数据缓存。

**渲染**

这是通过利用 JS/CSS 优化、加载序列、服务器渲染和管道来实现的。

在上述解决方案中，网络请求对初始加载速度的影响最大；因此，前端的请求缓存策略应该是优化的重点。

缓存可以分为静态文件缓存(包含 HTML 和 JS/CSS/image 资源)和 json 数据缓存。静态文件缓存的协议由 HTTP 定义。一旦浏览器实现了这些协议，静态文件也可以被缓存(更多细节可以在[这里](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)找到)。对于静态文件，有两种类型的缓存:

> **那些问有没有更新的**
> 
> 这些来自后端的缓存请求基于诸如 If-Modified-Since/ETag 之类的协议要求更新。如果没有更新，页面返回 304，浏览器使用本地缓存。
> 
> **那些直接使用本地缓存的**
> 
> 这种类型的缓存根据协议中的缓存控制/过期字段确定多长时间不需要更新请求。当不需要这样的请求时，直接使用本地缓存。

基于以上所述，优化的前端缓存策略从 HTML 文件每次加载时向服务器请求更新开始，而 JS/CSS/Image 资源文件直接使用本地缓存，而不是请求更新。

这种方法的一个潜在问题是更新 JS/CSS 文件。解决方案是在构建过程中给每个资源文件一个版本号或哈希值。如果资源文件有更新，版本号和哈希值将会改变，从而改变资源请求的 URL。同时，相应的网页将被更新，并将请求新资源的 URL，从而更新资源。

关于 json 数据缓存，解决方案是使用从 localStorage 缓存请求的数据。第一次显示页面时可以使用本地数据，同时会发送更新请求。因此，下次可以使用新数据。这个过程仍然由 JavaScript 控制。

这些缓存策略可以实现完全缓存资源文件，如 JS/CSS，以及用户数据缓存。它还在加载页面时直接使用本地缓存数据，而不需要网络请求。然而，这对于网页的缓存来说是不可能的。如果“Expires”和“max-age time”的时间段设置得太长，并且只有本地缓存被长时间使用，则页面将不会及时更新。同时，如果“Expires”和“max-age time”的时间段设置得太短，页面将在每次加载时向网络请求更新，然后决定是否使用本地资源。

一般的前端策略是每当用户长时间看到白屏时就请求更新。这是由于缓存和 HTML 文件更新之间的冲突造成的。

通常情况下，前端采用每次加载页面都请求更新的策略。这使得白屏时间非常长，尤其是在网络连接不良的情况下。因此，HTML 页面中的“缓存”和“更新”之间存在目标冲突。

# 客户端优化

现在大多数应用程序中都嵌入了网页，客户端有权进行页面优化。因为客户端在实现缓存策略方面有更多的自由，所以所有的网页请求都可以被拦截，缓存可以由客户端自己管理。

为了克服 HTML 的缓存和更新之间的目标冲突，下面的方法显示了令人鼓舞的结果:

一旦客户端出现拦截请求，当 HTML 文件第一次被请求时，缓存数据。

当第二次加载网页时，不要发送第二次请求，而是直接使用缓存的数据。

这种对本地资源的直接使用消除了等待网络请求的需要，因此提高了网页的加载速度。同时可以尽可能频繁地维护实时更新，解决缓存问题。

这似乎完全解决了缓存问题，但实际上还有许多问题有待解决。改进缓存逻辑是解决这些问题的一种方法，但更好的解决方案是使用网页包。

## 改进的缓存逻辑

Webview 可以直接控制对缓存的访问，但不能控制对缓存逻辑的访问。这种不可控的缓存会导致多个问题，但每个问题都可以解决或变通。

**重要的 HTML/JS/CSS 缓存在缓存一些大图后被清空**

这个问题源于不可控的清除逻辑和有限的缓存空间。解决方案是配置一个预加载缓存列表，这些缓存需要在应用程序打开时或在预设时间提前请求更新。这个列表必须包含所有需要的网页模块和资源，并且必须考虑一个网页模块可能有多个页面的事实。这个列表可能很长，因此需要工具来生成和管理它。

**数据无法从磁盘预加载到内存**

这个问题源于不可控的磁盘 IO。可以通过客户端接管所有请求的缓存并选择不使用 webview 的默认缓存逻辑来解决这个问题。然后，缓存机制根据缓存优先级和缓存预加载自行实现。

**在后台 HTML/JS/CSS 更新期间完全下载非常耗时，而且网络连接很差**

这是因为涉及到大量的数据。解决方案是对每个 HTML 和资源文件执行增量更新。然而，这在实现和管理上有些不便。

**被运营商或其他第三方劫持的 HTML 页面被长时间缓存**

这个问题可以通过在客户端使用 httpdns + https 反劫持系统来解决。

尽管可行，但这些解决方案实现起来很麻烦，因为 HTML 和资源文件数量众多且分散，很难管理。

## 网页包

由于提出的使用场景是使用网页开发功能模块，并且考虑到管理分散的文件会产生问题，一个显而易见的解决方案是打包并交付所有相关的页面和资源。

该解决方案可以使用某些相对简单的方法来解决上述问题:

整个网页包可以预下载，其配置可以基于服务模块而不是文件进行。网页包包含与服务模块相关的所有页面，并且可以同时预加载所有页面。

网页包的核心文件和页面的动态图片资源文件的缓存是分开的，这使得缓存管理更加容易。此外，整个网页包可以预加载到内存中，减少磁盘 IO 所需的时间。

一个网页包可以很容易地基于版本进行增量更新。

网页包是通过一个加密和验证的档案，使运营商和第三方不可能劫持或篡改它。

具体解决方案总结如下:

1.使用后端的构建工具，将同一个服务模块相关的所有页面和资源打包到一个文件中，同时进行加密/签名。

2.在客户端，在定制的时间下载网页包，然后根据配置表进行解压缩/解密/验证。

3.打开服务后，根据配置表将页面转移到网页包入口页面。

4.拦截网络请求，并为网页包中的现有文件读取从网页包返回的数据。否则，应用 HTTP 协议的缓存逻辑。

5.当更新网页包时，服务器仅传送当前版本和最新版本之间的差异数据包，而客户端通过合并两个客户端来执行增量更新。

网页包是网页开发的一个可行的解决方案。还有许多其他的优化选项也应该考虑。

# 其他优化

还可以实施其他优化来补充网页包解决方案，包括:

使用公共资源包

Webview 预加载

数据预加载

回退优化

客户端界面优化

服务器渲染优化

## 使用公共资源包

每个包都使用相同的 JS 框架和全局 CSS 样式。这些资源被浪费了，因为它们出现在每个网页包中。相反，可以创建一个公共资源包来提供这些全局文件。

## Webview 预加载

对于 iOS 和 Android，webview 组件的初始化都存在加载时间长的问题，这可以通过预加载 webview 来克服。有两种类型的预加载:

**首次预压**

webview 的第一次初始化通常非常慢。webview 可以预先初始化，然后在应用程序打开时释放，这样当用户在网页模块中加载 webview 时，该过程会更快。

**Webview 池**

不同于每次打开一个网页都创建一个新的网络视图的老方法，两个或更多的网络视图可以被巧妙的使用。然而，这种方法的一个问题是当发生页面跳转时如何清除前一页。还有一个就是如果一个网页出现 JS 内存泄漏，其他页面会受到影响，无法释放。

## 数据预加载

理想情况下，第一次打开网页包时，所有 HTML/JS/CSS 都使用本地缓存，不需要网络请求。然而，页面上的用户数据仍然需要实时请求，这是可以应用优化的地方。发出并行数据请求可以节省大量加载时间。

当实现该解决方案时，需要预加载到网页包中的 URL 使用配置表。在 webview 初始化期间，客户端发送请求，并在预加载完成时发送缓存结果。

接下来，初始化完成后，webview 将开始请求预加载的 URL。客户端截取请求，并将其传送给管理器。如果预加载完成，客户端返回到内容。如果不是，那么客户端等待它这样做。

## 回退优化

网页包模块的一个潜在问题是，用户可能试图访问尚未下载的网页包模块，或者配置表检测到新版本，但旧版本仍在应用程序中使用。

有几种解决方案可以用来克服这个问题:

如果没有本地网页包或者现有的本地网页包不是最新的，可以执行同步阻止来下载最新的网页包。但是，这种解决方案可能会影响用户体验，因为网页包的大小相对较大。

如果存在旧版本，用户可以被允许直接使用它一次。这种解决方案可能会导致更新延迟，并且用户可能没有使用最新版本。

可以创建网页包的在线版本，网页包中的每个文件在服务器上具有相应的访问地址。当没有现有的网页包时，可以像正常打开网页一样直接访问相应的在线地址。与下载整个网页包相比，该解决方案创建了更好的用户体验，并确保用户访问最新版本。这也可以作为备用解决方案。在不可预见的情况下，如果网页软件包出现故障，用户可以直接访问在线版本，因此网页的功能不会受到影响。

这些回退优化的优点是它们可以根据需要混合和匹配。

## 客户端界面优化

如果在网络和客户端接口上使用 webkit 的 ajax 和 localStorage，会有很多限制，优化变得更加困难。

JS 可以在客户端提供这些接口，所以可以在客户端进行 DNS 预解析/IP 直连/长连接/并行请求等更具体的优化。关于存储，客户端的接口可用于执行有针对性的优化，如读写并发性/用户隔离。

## 服务器渲染优化

与早期的网页不同，大多数网页内容依赖于 JS 逻辑来确定要呈现的内容，这可能是一个非常耗时的过程。例如，等待 JS 请求 JSON 数据，然后将其拼接到 HTML 生成的 DOM 中并呈现到页面上，这是一个漫长的过程。

这个问题的解决方案包括从人工减少 JS 呈现逻辑到更彻底和基础的服务器呈现。这是所有内容由服务器返回的 HTML 决定的地方，不需要等待 JS 逻辑发生。

然而，这可能会带来某些挑战，例如开发模式的改变/流量的增加/服务器成本的增加。QQ Mobile 中的某些页面采用了一种称为“动态直接输出”的特定服务器渲染方法，有关更多详细信息，请参见本文[。](https://mp.weixin.qq.com/s/evzDnTsHrAr2b9jcevwBzA)

# 结论

从前端优化、客户端缓存、网页打包，到更细致的优化，网页初始加载速度的解决方案数不胜数。如果这些解决方案被适当地采用和正确地执行，打开网页的用户体验几乎可以与原生应用相媲美。

总而言之，优化网页的一般方法是“缓存、预加载、并行计算”:

缓存所有网络请求

在用户打开页面之前，加载尽可能多的内容

尽可能并行执行多个流程，而不是串行执行

(Original article by Chen Zhenzhuo 陈振焯)

# 阿里巴巴科技

关于阿里巴巴最新技术的第一手深入信息→在**上搜索 [**【阿里巴巴科技】**](http://www.facebook.com/AlibabaTechnology)**