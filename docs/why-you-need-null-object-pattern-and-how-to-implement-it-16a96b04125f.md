# 为什么需要空对象模式以及如何实现它

> 原文：<https://medium.com/hackernoon/why-you-need-null-object-pattern-and-how-to-implement-it-16a96b04125f>

![](img/d3d0228d8ae26e2369326a430184f21b.png)

*合著:* [*雷杰普*](https://www.linkedin.com/in/rexhepkqiku/)

外面有许多编程语言和框架，准备用来解决问题。尽管我们可能被要求解决数十亿个问题，但其中通常有一些共同的主题。正如我们通常试图解决业务问题一样，我们也希望提高工作质量。这样，我们就有了*设计模式*，它们是处理特定情况的一些最佳方式的抽象。

通过唯一标识符查找表的元素是我们经常做的事情，为此我们可能需要考虑实现*空对象模式*。

这种模式通过提供一个指示缺少对象的替换来处理缺少对象的情况。在大多数面向对象的语言中，比如 Java 或 C#，引用可能根本不指向任何对象。这样，我们需要检查我们是否有空引用，在那之后我们面对主要的错误之前。

让我们举一些例子来进一步说明这种模式。我们将通过一个非常简单的例子来使用 C#:

根据定义，我们总是期望接待一个*人*。实际上，我们可能经常遇到这种情况:这个 *personId* 不是我们的 *Persons* 表中任何元素的 Id。在这种情况下，许多开发人员的*解决方案可能是:*

这不是一个好的实现。当我们找不到一个*人*时，我们将得到一个*空值*，但我们实际上是在寻找一个*人*。

这个 *null* 结果与我们方法的名称不匹配。如果我们有一个特例，我们还想返回空值，那么我们必须将该方法重命名为*GetPersonByIdOrReturnNull*，这对调用该方法的客户端来说更有意义。

在这种情况下可能发生的另一个问题是，当我们必须获得返回对象的属性时，例如: *person。名称*。这是*的一个著名错误。NET* 开发者:*对象引用未设置为对象*的实例，或者 *NullPointerException* ，如果类似的语法将在 Java 中实现。

对于上述情况，更好的解决方案可能是:

在这种情况下，我们使用了*空对象模式*，它允许您返回一个 *Person* 对象，但是它的属性故意保留为空，例如:

这种模式的另一个好的实现如下:

在这种情况下，我们使用用户定义的异常。我们抛出并捕捉特定的异常，以此来更好地控制我们的应用程序，并尽可能避免出现 *NullReferenceException* 的情况。

抛出我们自己的特定异常可以帮助我们有更多的描述性错误，这可以在我们试图调试和解决问题时节省我们大量的时间。我们很快就能对我们面临的问题有一个更好的了解。

Ruby on Rails 中的 ActiveRecord 模块已经包含了该模式的一个简单实现，它是 Active Record 模式的一个实现，Active Record 模式本身是一个对象关系映射系统的描述。也就是说，当你通过一个主键搜索一个特定的对象时，你会得到一个异常。

Ruby on Rails 的创始人 David Heinemeier Hansson 在《用 Rails 进行敏捷 Web 开发[](https://www.amazon.com/dp/1934356166/)*一书中解释了这一点:*

*当你使用主键驱动的查找器时，你在寻找一个特定的记录。你希望它存在。对 Person.find(5)的调用基于我们对 people 表的了解。我们需要 id 为 5 的行。如果这个调用不成功——如果 id 为 5 的记录被销毁了——我们就处于异常情况。这要求引发异常，所以 Rails 引发 RecordNotFound。*

**另一方面，使用标准进行搜索的搜索者正在寻找匹配。因此，Person.find(:first，:conditions= > "name='Dave ' ")相当于告诉数据库(作为一个黑盒)"给我第一个名为 Dave 的 Person 行。"这展示了一种截然不同的检索方法；我们不能预先确定我们会得到一个结果。结果集完全有可能是空的。因此，在查找一行的查找器返回 nil，而在查找多行的查找器返回空数组的情况下，这是自然的、非异常的响应。**

*既然你已经阅读了这篇关于这种模式的文章，记住不要让 NULL 使你的应用程序成为傻瓜！*

**在*[*LinkedIn*](https://www.linkedin.com/in/rexhepkqiku/)*上找到合著者。**